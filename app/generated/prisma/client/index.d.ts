
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Scenario
 * 
 */
export type Scenario = $Result.DefaultSelection<Prisma.$ScenarioPayload>
/**
 * Model Character
 * 
 */
export type Character = $Result.DefaultSelection<Prisma.$CharacterPayload>
/**
 * Model CharacterSkill
 * 
 */
export type CharacterSkill = $Result.DefaultSelection<Prisma.$CharacterSkillPayload>
/**
 * Model Fortune
 * 
 */
export type Fortune = $Result.DefaultSelection<Prisma.$FortunePayload>
/**
 * Model Alignment
 * 
 */
export type Alignment = $Result.DefaultSelection<Prisma.$AlignmentPayload>
/**
 * Model Temperment
 * 
 */
export type Temperment = $Result.DefaultSelection<Prisma.$TempermentPayload>
/**
 * Model Strength
 * 
 */
export type Strength = $Result.DefaultSelection<Prisma.$StrengthPayload>
/**
 * Model Weakness
 * 
 */
export type Weakness = $Result.DefaultSelection<Prisma.$WeaknessPayload>
/**
 * Model Weapon
 * 
 */
export type Weapon = $Result.DefaultSelection<Prisma.$WeaponPayload>
/**
 * Model WeaponSkill
 * 
 */
export type WeaponSkill = $Result.DefaultSelection<Prisma.$WeaponSkillPayload>
/**
 * Model Damage
 * 
 */
export type Damage = $Result.DefaultSelection<Prisma.$DamagePayload>
/**
 * Model Weight
 * 
 */
export type Weight = $Result.DefaultSelection<Prisma.$WeightPayload>
/**
 * Model Ammo
 * 
 */
export type Ammo = $Result.DefaultSelection<Prisma.$AmmoPayload>
/**
 * Model Range
 * 
 */
export type Range = $Result.DefaultSelection<Prisma.$RangePayload>
/**
 * Model Suggestion
 * 
 */
export type Suggestion = $Result.DefaultSelection<Prisma.$SuggestionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  SUPERUSER: 'SUPERUSER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const SuggestionType: {
  Temperment: 'Temperment',
  Alignment: 'Alignment',
  Fortune: 'Fortune',
  Strength: 'Strength',
  Weakness: 'Weakness',
  CharacterSkill: 'CharacterSkill',
  WeaponSkill: 'WeaponSkill',
  Range: 'Range',
  Damage: 'Damage',
  Weight: 'Weight',
  Ammo: 'Ammo'
};

export type SuggestionType = (typeof SuggestionType)[keyof typeof SuggestionType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type SuggestionType = $Enums.SuggestionType

export const SuggestionType: typeof $Enums.SuggestionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scenario`: Exposes CRUD operations for the **Scenario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scenarios
    * const scenarios = await prisma.scenario.findMany()
    * ```
    */
  get scenario(): Prisma.ScenarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character`: Exposes CRUD operations for the **Character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.CharacterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characterSkill`: Exposes CRUD operations for the **CharacterSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterSkills
    * const characterSkills = await prisma.characterSkill.findMany()
    * ```
    */
  get characterSkill(): Prisma.CharacterSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fortune`: Exposes CRUD operations for the **Fortune** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fortunes
    * const fortunes = await prisma.fortune.findMany()
    * ```
    */
  get fortune(): Prisma.FortuneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alignment`: Exposes CRUD operations for the **Alignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alignments
    * const alignments = await prisma.alignment.findMany()
    * ```
    */
  get alignment(): Prisma.AlignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.temperment`: Exposes CRUD operations for the **Temperment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Temperments
    * const temperments = await prisma.temperment.findMany()
    * ```
    */
  get temperment(): Prisma.TempermentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.strength`: Exposes CRUD operations for the **Strength** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Strengths
    * const strengths = await prisma.strength.findMany()
    * ```
    */
  get strength(): Prisma.StrengthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weakness`: Exposes CRUD operations for the **Weakness** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weaknesses
    * const weaknesses = await prisma.weakness.findMany()
    * ```
    */
  get weakness(): Prisma.WeaknessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weapon`: Exposes CRUD operations for the **Weapon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weapons
    * const weapons = await prisma.weapon.findMany()
    * ```
    */
  get weapon(): Prisma.WeaponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weaponSkill`: Exposes CRUD operations for the **WeaponSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeaponSkills
    * const weaponSkills = await prisma.weaponSkill.findMany()
    * ```
    */
  get weaponSkill(): Prisma.WeaponSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.damage`: Exposes CRUD operations for the **Damage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Damages
    * const damages = await prisma.damage.findMany()
    * ```
    */
  get damage(): Prisma.DamageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.weight`: Exposes CRUD operations for the **Weight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weights
    * const weights = await prisma.weight.findMany()
    * ```
    */
  get weight(): Prisma.WeightDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ammo`: Exposes CRUD operations for the **Ammo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ammo
    * const ammo = await prisma.ammo.findMany()
    * ```
    */
  get ammo(): Prisma.AmmoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.range`: Exposes CRUD operations for the **Range** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ranges
    * const ranges = await prisma.range.findMany()
    * ```
    */
  get range(): Prisma.RangeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.suggestion`: Exposes CRUD operations for the **Suggestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suggestions
    * const suggestions = await prisma.suggestion.findMany()
    * ```
    */
  get suggestion(): Prisma.SuggestionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    User: 'User',
    Scenario: 'Scenario',
    Character: 'Character',
    CharacterSkill: 'CharacterSkill',
    Fortune: 'Fortune',
    Alignment: 'Alignment',
    Temperment: 'Temperment',
    Strength: 'Strength',
    Weakness: 'Weakness',
    Weapon: 'Weapon',
    WeaponSkill: 'WeaponSkill',
    Damage: 'Damage',
    Weight: 'Weight',
    Ammo: 'Ammo',
    Range: 'Range',
    Suggestion: 'Suggestion'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "session" | "verificationToken" | "user" | "scenario" | "character" | "characterSkill" | "fortune" | "alignment" | "temperment" | "strength" | "weakness" | "weapon" | "weaponSkill" | "damage" | "weight" | "ammo" | "range" | "suggestion"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Scenario: {
        payload: Prisma.$ScenarioPayload<ExtArgs>
        fields: Prisma.ScenarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScenarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScenarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          findFirst: {
            args: Prisma.ScenarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScenarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          findMany: {
            args: Prisma.ScenarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          create: {
            args: Prisma.ScenarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          createMany: {
            args: Prisma.ScenarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScenarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          delete: {
            args: Prisma.ScenarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          update: {
            args: Prisma.ScenarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          deleteMany: {
            args: Prisma.ScenarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScenarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScenarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          upsert: {
            args: Prisma.ScenarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          aggregate: {
            args: Prisma.ScenarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScenario>
          }
          groupBy: {
            args: Prisma.ScenarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScenarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScenarioCountArgs<ExtArgs>
            result: $Utils.Optional<ScenarioCountAggregateOutputType> | number
          }
        }
      }
      Character: {
        payload: Prisma.$CharacterPayload<ExtArgs>
        fields: Prisma.CharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findFirst: {
            args: Prisma.CharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findMany: {
            args: Prisma.CharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          create: {
            args: Prisma.CharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          createMany: {
            args: Prisma.CharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          delete: {
            args: Prisma.CharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          update: {
            args: Prisma.CharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          deleteMany: {
            args: Prisma.CharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          upsert: {
            args: Prisma.CharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          aggregate: {
            args: Prisma.CharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter>
          }
          groupBy: {
            args: Prisma.CharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterCountAggregateOutputType> | number
          }
        }
      }
      CharacterSkill: {
        payload: Prisma.$CharacterSkillPayload<ExtArgs>
        fields: Prisma.CharacterSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          findFirst: {
            args: Prisma.CharacterSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          findMany: {
            args: Prisma.CharacterSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>[]
          }
          create: {
            args: Prisma.CharacterSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          createMany: {
            args: Prisma.CharacterSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>[]
          }
          delete: {
            args: Prisma.CharacterSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          update: {
            args: Prisma.CharacterSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          deleteMany: {
            args: Prisma.CharacterSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>[]
          }
          upsert: {
            args: Prisma.CharacterSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          aggregate: {
            args: Prisma.CharacterSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterSkill>
          }
          groupBy: {
            args: Prisma.CharacterSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterSkillCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterSkillCountAggregateOutputType> | number
          }
        }
      }
      Fortune: {
        payload: Prisma.$FortunePayload<ExtArgs>
        fields: Prisma.FortuneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FortuneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FortunePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FortuneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FortunePayload>
          }
          findFirst: {
            args: Prisma.FortuneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FortunePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FortuneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FortunePayload>
          }
          findMany: {
            args: Prisma.FortuneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FortunePayload>[]
          }
          create: {
            args: Prisma.FortuneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FortunePayload>
          }
          createMany: {
            args: Prisma.FortuneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FortuneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FortunePayload>[]
          }
          delete: {
            args: Prisma.FortuneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FortunePayload>
          }
          update: {
            args: Prisma.FortuneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FortunePayload>
          }
          deleteMany: {
            args: Prisma.FortuneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FortuneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FortuneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FortunePayload>[]
          }
          upsert: {
            args: Prisma.FortuneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FortunePayload>
          }
          aggregate: {
            args: Prisma.FortuneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFortune>
          }
          groupBy: {
            args: Prisma.FortuneGroupByArgs<ExtArgs>
            result: $Utils.Optional<FortuneGroupByOutputType>[]
          }
          count: {
            args: Prisma.FortuneCountArgs<ExtArgs>
            result: $Utils.Optional<FortuneCountAggregateOutputType> | number
          }
        }
      }
      Alignment: {
        payload: Prisma.$AlignmentPayload<ExtArgs>
        fields: Prisma.AlignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          findFirst: {
            args: Prisma.AlignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          findMany: {
            args: Prisma.AlignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>[]
          }
          create: {
            args: Prisma.AlignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          createMany: {
            args: Prisma.AlignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>[]
          }
          delete: {
            args: Prisma.AlignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          update: {
            args: Prisma.AlignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          deleteMany: {
            args: Prisma.AlignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>[]
          }
          upsert: {
            args: Prisma.AlignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          aggregate: {
            args: Prisma.AlignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlignment>
          }
          groupBy: {
            args: Prisma.AlignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AlignmentCountAggregateOutputType> | number
          }
        }
      }
      Temperment: {
        payload: Prisma.$TempermentPayload<ExtArgs>
        fields: Prisma.TempermentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TempermentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempermentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TempermentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempermentPayload>
          }
          findFirst: {
            args: Prisma.TempermentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempermentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TempermentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempermentPayload>
          }
          findMany: {
            args: Prisma.TempermentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempermentPayload>[]
          }
          create: {
            args: Prisma.TempermentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempermentPayload>
          }
          createMany: {
            args: Prisma.TempermentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TempermentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempermentPayload>[]
          }
          delete: {
            args: Prisma.TempermentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempermentPayload>
          }
          update: {
            args: Prisma.TempermentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempermentPayload>
          }
          deleteMany: {
            args: Prisma.TempermentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TempermentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TempermentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempermentPayload>[]
          }
          upsert: {
            args: Prisma.TempermentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempermentPayload>
          }
          aggregate: {
            args: Prisma.TempermentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemperment>
          }
          groupBy: {
            args: Prisma.TempermentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TempermentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TempermentCountArgs<ExtArgs>
            result: $Utils.Optional<TempermentCountAggregateOutputType> | number
          }
        }
      }
      Strength: {
        payload: Prisma.$StrengthPayload<ExtArgs>
        fields: Prisma.StrengthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StrengthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StrengthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthPayload>
          }
          findFirst: {
            args: Prisma.StrengthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StrengthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthPayload>
          }
          findMany: {
            args: Prisma.StrengthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthPayload>[]
          }
          create: {
            args: Prisma.StrengthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthPayload>
          }
          createMany: {
            args: Prisma.StrengthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StrengthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthPayload>[]
          }
          delete: {
            args: Prisma.StrengthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthPayload>
          }
          update: {
            args: Prisma.StrengthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthPayload>
          }
          deleteMany: {
            args: Prisma.StrengthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StrengthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StrengthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthPayload>[]
          }
          upsert: {
            args: Prisma.StrengthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthPayload>
          }
          aggregate: {
            args: Prisma.StrengthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrength>
          }
          groupBy: {
            args: Prisma.StrengthGroupByArgs<ExtArgs>
            result: $Utils.Optional<StrengthGroupByOutputType>[]
          }
          count: {
            args: Prisma.StrengthCountArgs<ExtArgs>
            result: $Utils.Optional<StrengthCountAggregateOutputType> | number
          }
        }
      }
      Weakness: {
        payload: Prisma.$WeaknessPayload<ExtArgs>
        fields: Prisma.WeaknessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeaknessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaknessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeaknessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaknessPayload>
          }
          findFirst: {
            args: Prisma.WeaknessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaknessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeaknessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaknessPayload>
          }
          findMany: {
            args: Prisma.WeaknessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaknessPayload>[]
          }
          create: {
            args: Prisma.WeaknessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaknessPayload>
          }
          createMany: {
            args: Prisma.WeaknessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeaknessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaknessPayload>[]
          }
          delete: {
            args: Prisma.WeaknessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaknessPayload>
          }
          update: {
            args: Prisma.WeaknessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaknessPayload>
          }
          deleteMany: {
            args: Prisma.WeaknessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeaknessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeaknessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaknessPayload>[]
          }
          upsert: {
            args: Prisma.WeaknessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaknessPayload>
          }
          aggregate: {
            args: Prisma.WeaknessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeakness>
          }
          groupBy: {
            args: Prisma.WeaknessGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeaknessGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeaknessCountArgs<ExtArgs>
            result: $Utils.Optional<WeaknessCountAggregateOutputType> | number
          }
        }
      }
      Weapon: {
        payload: Prisma.$WeaponPayload<ExtArgs>
        fields: Prisma.WeaponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeaponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeaponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          findFirst: {
            args: Prisma.WeaponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeaponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          findMany: {
            args: Prisma.WeaponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>[]
          }
          create: {
            args: Prisma.WeaponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          createMany: {
            args: Prisma.WeaponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeaponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>[]
          }
          delete: {
            args: Prisma.WeaponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          update: {
            args: Prisma.WeaponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          deleteMany: {
            args: Prisma.WeaponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeaponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeaponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>[]
          }
          upsert: {
            args: Prisma.WeaponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponPayload>
          }
          aggregate: {
            args: Prisma.WeaponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeapon>
          }
          groupBy: {
            args: Prisma.WeaponGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeaponGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeaponCountArgs<ExtArgs>
            result: $Utils.Optional<WeaponCountAggregateOutputType> | number
          }
        }
      }
      WeaponSkill: {
        payload: Prisma.$WeaponSkillPayload<ExtArgs>
        fields: Prisma.WeaponSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeaponSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeaponSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponSkillPayload>
          }
          findFirst: {
            args: Prisma.WeaponSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeaponSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponSkillPayload>
          }
          findMany: {
            args: Prisma.WeaponSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponSkillPayload>[]
          }
          create: {
            args: Prisma.WeaponSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponSkillPayload>
          }
          createMany: {
            args: Prisma.WeaponSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeaponSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponSkillPayload>[]
          }
          delete: {
            args: Prisma.WeaponSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponSkillPayload>
          }
          update: {
            args: Prisma.WeaponSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponSkillPayload>
          }
          deleteMany: {
            args: Prisma.WeaponSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeaponSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeaponSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponSkillPayload>[]
          }
          upsert: {
            args: Prisma.WeaponSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeaponSkillPayload>
          }
          aggregate: {
            args: Prisma.WeaponSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeaponSkill>
          }
          groupBy: {
            args: Prisma.WeaponSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeaponSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeaponSkillCountArgs<ExtArgs>
            result: $Utils.Optional<WeaponSkillCountAggregateOutputType> | number
          }
        }
      }
      Damage: {
        payload: Prisma.$DamagePayload<ExtArgs>
        fields: Prisma.DamageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DamageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DamageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamagePayload>
          }
          findFirst: {
            args: Prisma.DamageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DamageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamagePayload>
          }
          findMany: {
            args: Prisma.DamageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamagePayload>[]
          }
          create: {
            args: Prisma.DamageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamagePayload>
          }
          createMany: {
            args: Prisma.DamageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DamageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamagePayload>[]
          }
          delete: {
            args: Prisma.DamageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamagePayload>
          }
          update: {
            args: Prisma.DamageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamagePayload>
          }
          deleteMany: {
            args: Prisma.DamageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DamageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DamageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamagePayload>[]
          }
          upsert: {
            args: Prisma.DamageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamagePayload>
          }
          aggregate: {
            args: Prisma.DamageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDamage>
          }
          groupBy: {
            args: Prisma.DamageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DamageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DamageCountArgs<ExtArgs>
            result: $Utils.Optional<DamageCountAggregateOutputType> | number
          }
        }
      }
      Weight: {
        payload: Prisma.$WeightPayload<ExtArgs>
        fields: Prisma.WeightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightPayload>
          }
          findFirst: {
            args: Prisma.WeightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightPayload>
          }
          findMany: {
            args: Prisma.WeightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightPayload>[]
          }
          create: {
            args: Prisma.WeightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightPayload>
          }
          createMany: {
            args: Prisma.WeightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WeightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightPayload>[]
          }
          delete: {
            args: Prisma.WeightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightPayload>
          }
          update: {
            args: Prisma.WeightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightPayload>
          }
          deleteMany: {
            args: Prisma.WeightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WeightUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightPayload>[]
          }
          upsert: {
            args: Prisma.WeightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeightPayload>
          }
          aggregate: {
            args: Prisma.WeightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeight>
          }
          groupBy: {
            args: Prisma.WeightGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeightGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeightCountArgs<ExtArgs>
            result: $Utils.Optional<WeightCountAggregateOutputType> | number
          }
        }
      }
      Ammo: {
        payload: Prisma.$AmmoPayload<ExtArgs>
        fields: Prisma.AmmoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmmoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmmoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoPayload>
          }
          findFirst: {
            args: Prisma.AmmoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmmoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoPayload>
          }
          findMany: {
            args: Prisma.AmmoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoPayload>[]
          }
          create: {
            args: Prisma.AmmoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoPayload>
          }
          createMany: {
            args: Prisma.AmmoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmmoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoPayload>[]
          }
          delete: {
            args: Prisma.AmmoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoPayload>
          }
          update: {
            args: Prisma.AmmoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoPayload>
          }
          deleteMany: {
            args: Prisma.AmmoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmmoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmmoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoPayload>[]
          }
          upsert: {
            args: Prisma.AmmoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmmoPayload>
          }
          aggregate: {
            args: Prisma.AmmoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmmo>
          }
          groupBy: {
            args: Prisma.AmmoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmmoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmmoCountArgs<ExtArgs>
            result: $Utils.Optional<AmmoCountAggregateOutputType> | number
          }
        }
      }
      Range: {
        payload: Prisma.$RangePayload<ExtArgs>
        fields: Prisma.RangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangePayload>
          }
          findFirst: {
            args: Prisma.RangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangePayload>
          }
          findMany: {
            args: Prisma.RangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangePayload>[]
          }
          create: {
            args: Prisma.RangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangePayload>
          }
          createMany: {
            args: Prisma.RangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangePayload>[]
          }
          delete: {
            args: Prisma.RangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangePayload>
          }
          update: {
            args: Prisma.RangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangePayload>
          }
          deleteMany: {
            args: Prisma.RangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RangeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangePayload>[]
          }
          upsert: {
            args: Prisma.RangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RangePayload>
          }
          aggregate: {
            args: Prisma.RangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRange>
          }
          groupBy: {
            args: Prisma.RangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RangeCountArgs<ExtArgs>
            result: $Utils.Optional<RangeCountAggregateOutputType> | number
          }
        }
      }
      Suggestion: {
        payload: Prisma.$SuggestionPayload<ExtArgs>
        fields: Prisma.SuggestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuggestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuggestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          findFirst: {
            args: Prisma.SuggestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuggestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          findMany: {
            args: Prisma.SuggestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>[]
          }
          create: {
            args: Prisma.SuggestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          createMany: {
            args: Prisma.SuggestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuggestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>[]
          }
          delete: {
            args: Prisma.SuggestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          update: {
            args: Prisma.SuggestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          deleteMany: {
            args: Prisma.SuggestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuggestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuggestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>[]
          }
          upsert: {
            args: Prisma.SuggestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuggestionPayload>
          }
          aggregate: {
            args: Prisma.SuggestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuggestion>
          }
          groupBy: {
            args: Prisma.SuggestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuggestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuggestionCountArgs<ExtArgs>
            result: $Utils.Optional<SuggestionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    user?: UserOmit
    scenario?: ScenarioOmit
    character?: CharacterOmit
    characterSkill?: CharacterSkillOmit
    fortune?: FortuneOmit
    alignment?: AlignmentOmit
    temperment?: TempermentOmit
    strength?: StrengthOmit
    weakness?: WeaknessOmit
    weapon?: WeaponOmit
    weaponSkill?: WeaponSkillOmit
    damage?: DamageOmit
    weight?: WeightOmit
    ammo?: AmmoOmit
    range?: RangeOmit
    suggestion?: SuggestionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    Scenario: number
    Weapon: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    Scenario?: boolean | UserCountOutputTypeCountScenarioArgs
    Weapon?: boolean | UserCountOutputTypeCountWeaponArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScenarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWeaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponWhereInput
  }


  /**
   * Count Type ScenarioCountOutputType
   */

  export type ScenarioCountOutputType = {
    character: number
  }

  export type ScenarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | ScenarioCountOutputTypeCountCharacterArgs
  }

  // Custom InputTypes
  /**
   * ScenarioCountOutputType without action
   */
  export type ScenarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioCountOutputType
     */
    select?: ScenarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScenarioCountOutputType without action
   */
  export type ScenarioCountOutputTypeCountCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }


  /**
   * Count Type CharacterCountOutputType
   */

  export type CharacterCountOutputType = {
    weapon: number
    skillSet: number
    scenario: number
    strength: number
    weakness: number
  }

  export type CharacterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | CharacterCountOutputTypeCountWeaponArgs
    skillSet?: boolean | CharacterCountOutputTypeCountSkillSetArgs
    scenario?: boolean | CharacterCountOutputTypeCountScenarioArgs
    strength?: boolean | CharacterCountOutputTypeCountStrengthArgs
    weakness?: boolean | CharacterCountOutputTypeCountWeaknessArgs
  }

  // Custom InputTypes
  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterCountOutputType
     */
    select?: CharacterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountWeaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountSkillSetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSkillWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountScenarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountStrengthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrengthWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountWeaknessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaknessWhereInput
  }


  /**
   * Count Type CharacterSkillCountOutputType
   */

  export type CharacterSkillCountOutputType = {
    character: number
  }

  export type CharacterSkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterSkillCountOutputTypeCountCharacterArgs
  }

  // Custom InputTypes
  /**
   * CharacterSkillCountOutputType without action
   */
  export type CharacterSkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkillCountOutputType
     */
    select?: CharacterSkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacterSkillCountOutputType without action
   */
  export type CharacterSkillCountOutputTypeCountCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }


  /**
   * Count Type FortuneCountOutputType
   */

  export type FortuneCountOutputType = {
    character: number
  }

  export type FortuneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | FortuneCountOutputTypeCountCharacterArgs
  }

  // Custom InputTypes
  /**
   * FortuneCountOutputType without action
   */
  export type FortuneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FortuneCountOutputType
     */
    select?: FortuneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FortuneCountOutputType without action
   */
  export type FortuneCountOutputTypeCountCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }


  /**
   * Count Type AlignmentCountOutputType
   */

  export type AlignmentCountOutputType = {
    character: number
  }

  export type AlignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | AlignmentCountOutputTypeCountCharacterArgs
  }

  // Custom InputTypes
  /**
   * AlignmentCountOutputType without action
   */
  export type AlignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlignmentCountOutputType
     */
    select?: AlignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlignmentCountOutputType without action
   */
  export type AlignmentCountOutputTypeCountCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }


  /**
   * Count Type TempermentCountOutputType
   */

  export type TempermentCountOutputType = {
    character: number
  }

  export type TempermentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | TempermentCountOutputTypeCountCharacterArgs
  }

  // Custom InputTypes
  /**
   * TempermentCountOutputType without action
   */
  export type TempermentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempermentCountOutputType
     */
    select?: TempermentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TempermentCountOutputType without action
   */
  export type TempermentCountOutputTypeCountCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }


  /**
   * Count Type StrengthCountOutputType
   */

  export type StrengthCountOutputType = {
    character: number
  }

  export type StrengthCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | StrengthCountOutputTypeCountCharacterArgs
  }

  // Custom InputTypes
  /**
   * StrengthCountOutputType without action
   */
  export type StrengthCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthCountOutputType
     */
    select?: StrengthCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StrengthCountOutputType without action
   */
  export type StrengthCountOutputTypeCountCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }


  /**
   * Count Type WeaknessCountOutputType
   */

  export type WeaknessCountOutputType = {
    character: number
  }

  export type WeaknessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | WeaknessCountOutputTypeCountCharacterArgs
  }

  // Custom InputTypes
  /**
   * WeaknessCountOutputType without action
   */
  export type WeaknessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaknessCountOutputType
     */
    select?: WeaknessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeaknessCountOutputType without action
   */
  export type WeaknessCountOutputTypeCountCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }


  /**
   * Count Type WeaponCountOutputType
   */

  export type WeaponCountOutputType = {
    character: number
    weaponSkill: number
  }

  export type WeaponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | WeaponCountOutputTypeCountCharacterArgs
    weaponSkill?: boolean | WeaponCountOutputTypeCountWeaponSkillArgs
  }

  // Custom InputTypes
  /**
   * WeaponCountOutputType without action
   */
  export type WeaponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponCountOutputType
     */
    select?: WeaponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeaponCountOutputType without action
   */
  export type WeaponCountOutputTypeCountCharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }

  /**
   * WeaponCountOutputType without action
   */
  export type WeaponCountOutputTypeCountWeaponSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponSkillWhereInput
  }


  /**
   * Count Type WeaponSkillCountOutputType
   */

  export type WeaponSkillCountOutputType = {
    weapon: number
  }

  export type WeaponSkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | WeaponSkillCountOutputTypeCountWeaponArgs
  }

  // Custom InputTypes
  /**
   * WeaponSkillCountOutputType without action
   */
  export type WeaponSkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkillCountOutputType
     */
    select?: WeaponSkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeaponSkillCountOutputType without action
   */
  export type WeaponSkillCountOutputTypeCountWeaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponWhereInput
  }


  /**
   * Count Type DamageCountOutputType
   */

  export type DamageCountOutputType = {
    weapon: number
  }

  export type DamageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | DamageCountOutputTypeCountWeaponArgs
  }

  // Custom InputTypes
  /**
   * DamageCountOutputType without action
   */
  export type DamageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageCountOutputType
     */
    select?: DamageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DamageCountOutputType without action
   */
  export type DamageCountOutputTypeCountWeaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponWhereInput
  }


  /**
   * Count Type WeightCountOutputType
   */

  export type WeightCountOutputType = {
    weapon: number
  }

  export type WeightCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | WeightCountOutputTypeCountWeaponArgs
  }

  // Custom InputTypes
  /**
   * WeightCountOutputType without action
   */
  export type WeightCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeightCountOutputType
     */
    select?: WeightCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeightCountOutputType without action
   */
  export type WeightCountOutputTypeCountWeaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponWhereInput
  }


  /**
   * Count Type AmmoCountOutputType
   */

  export type AmmoCountOutputType = {
    weapon: number
  }

  export type AmmoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | AmmoCountOutputTypeCountWeaponArgs
  }

  // Custom InputTypes
  /**
   * AmmoCountOutputType without action
   */
  export type AmmoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmmoCountOutputType
     */
    select?: AmmoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AmmoCountOutputType without action
   */
  export type AmmoCountOutputTypeCountWeaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponWhereInput
  }


  /**
   * Count Type RangeCountOutputType
   */

  export type RangeCountOutputType = {
    weapon: number
  }

  export type RangeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | RangeCountOutputTypeCountWeaponArgs
  }

  // Custom InputTypes
  /**
   * RangeCountOutputType without action
   */
  export type RangeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RangeCountOutputType
     */
    select?: RangeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RangeCountOutputType without action
   */
  export type RangeCountOutputTypeCountWeaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    role: $Enums.Role | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    role: $Enums.Role | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    role: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    role: $Enums.Role
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    Scenario?: boolean | User$ScenarioArgs<ExtArgs>
    Weapon?: boolean | User$WeaponArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "role", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    Scenario?: boolean | User$ScenarioArgs<ExtArgs>
    Weapon?: boolean | User$WeaponArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      Scenario: Prisma.$ScenarioPayload<ExtArgs>[]
      Weapon: Prisma.$WeaponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: Date | null
      image: string | null
      role: $Enums.Role
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Scenario<T extends User$ScenarioArgs<ExtArgs> = {}>(args?: Subset<T, User$ScenarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Weapon<T extends User$WeaponArgs<ExtArgs> = {}>(args?: Subset<T, User$WeaponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.Scenario
   */
  export type User$ScenarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    where?: ScenarioWhereInput
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    cursor?: ScenarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * User.Weapon
   */
  export type User$WeaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    where?: WeaponWhereInput
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    cursor?: WeaponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Scenario
   */

  export type AggregateScenario = {
    _count: ScenarioCountAggregateOutputType | null
    _min: ScenarioMinAggregateOutputType | null
    _max: ScenarioMaxAggregateOutputType | null
  }

  export type ScenarioMinAggregateOutputType = {
    id: string | null
    name: string | null
    universe: string | null
    description: string | null
    userId: string | null
  }

  export type ScenarioMaxAggregateOutputType = {
    id: string | null
    name: string | null
    universe: string | null
    description: string | null
    userId: string | null
  }

  export type ScenarioCountAggregateOutputType = {
    id: number
    name: number
    universe: number
    description: number
    userId: number
    _all: number
  }


  export type ScenarioMinAggregateInputType = {
    id?: true
    name?: true
    universe?: true
    description?: true
    userId?: true
  }

  export type ScenarioMaxAggregateInputType = {
    id?: true
    name?: true
    universe?: true
    description?: true
    userId?: true
  }

  export type ScenarioCountAggregateInputType = {
    id?: true
    name?: true
    universe?: true
    description?: true
    userId?: true
    _all?: true
  }

  export type ScenarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scenario to aggregate.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Scenarios
    **/
    _count?: true | ScenarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScenarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScenarioMaxAggregateInputType
  }

  export type GetScenarioAggregateType<T extends ScenarioAggregateArgs> = {
        [P in keyof T & keyof AggregateScenario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScenario[P]>
      : GetScalarType<T[P], AggregateScenario[P]>
  }




  export type ScenarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioWhereInput
    orderBy?: ScenarioOrderByWithAggregationInput | ScenarioOrderByWithAggregationInput[]
    by: ScenarioScalarFieldEnum[] | ScenarioScalarFieldEnum
    having?: ScenarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScenarioCountAggregateInputType | true
    _min?: ScenarioMinAggregateInputType
    _max?: ScenarioMaxAggregateInputType
  }

  export type ScenarioGroupByOutputType = {
    id: string
    name: string
    universe: string
    description: string | null
    userId: string
    _count: ScenarioCountAggregateOutputType | null
    _min: ScenarioMinAggregateOutputType | null
    _max: ScenarioMaxAggregateOutputType | null
  }

  type GetScenarioGroupByPayload<T extends ScenarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScenarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScenarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScenarioGroupByOutputType[P]>
            : GetScalarType<T[P], ScenarioGroupByOutputType[P]>
        }
      >
    >


  export type ScenarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    universe?: boolean
    description?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    character?: boolean | Scenario$characterArgs<ExtArgs>
    _count?: boolean | ScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    universe?: boolean
    description?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    universe?: boolean
    description?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectScalar = {
    id?: boolean
    name?: boolean
    universe?: boolean
    description?: boolean
    userId?: boolean
  }

  export type ScenarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "universe" | "description" | "userId", ExtArgs["result"]["scenario"]>
  export type ScenarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    character?: boolean | Scenario$characterArgs<ExtArgs>
    _count?: boolean | ScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScenarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ScenarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ScenarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Scenario"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      character: Prisma.$CharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      universe: string
      description: string | null
      userId: string
    }, ExtArgs["result"]["scenario"]>
    composites: {}
  }

  type ScenarioGetPayload<S extends boolean | null | undefined | ScenarioDefaultArgs> = $Result.GetResult<Prisma.$ScenarioPayload, S>

  type ScenarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScenarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScenarioCountAggregateInputType | true
    }

  export interface ScenarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Scenario'], meta: { name: 'Scenario' } }
    /**
     * Find zero or one Scenario that matches the filter.
     * @param {ScenarioFindUniqueArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScenarioFindUniqueArgs>(args: SelectSubset<T, ScenarioFindUniqueArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Scenario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScenarioFindUniqueOrThrowArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScenarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ScenarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scenario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindFirstArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScenarioFindFirstArgs>(args?: SelectSubset<T, ScenarioFindFirstArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scenario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindFirstOrThrowArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScenarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ScenarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Scenarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scenarios
     * const scenarios = await prisma.scenario.findMany()
     * 
     * // Get first 10 Scenarios
     * const scenarios = await prisma.scenario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scenarioWithIdOnly = await prisma.scenario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScenarioFindManyArgs>(args?: SelectSubset<T, ScenarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Scenario.
     * @param {ScenarioCreateArgs} args - Arguments to create a Scenario.
     * @example
     * // Create one Scenario
     * const Scenario = await prisma.scenario.create({
     *   data: {
     *     // ... data to create a Scenario
     *   }
     * })
     * 
     */
    create<T extends ScenarioCreateArgs>(args: SelectSubset<T, ScenarioCreateArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Scenarios.
     * @param {ScenarioCreateManyArgs} args - Arguments to create many Scenarios.
     * @example
     * // Create many Scenarios
     * const scenario = await prisma.scenario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScenarioCreateManyArgs>(args?: SelectSubset<T, ScenarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Scenarios and returns the data saved in the database.
     * @param {ScenarioCreateManyAndReturnArgs} args - Arguments to create many Scenarios.
     * @example
     * // Create many Scenarios
     * const scenario = await prisma.scenario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Scenarios and only return the `id`
     * const scenarioWithIdOnly = await prisma.scenario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScenarioCreateManyAndReturnArgs>(args?: SelectSubset<T, ScenarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Scenario.
     * @param {ScenarioDeleteArgs} args - Arguments to delete one Scenario.
     * @example
     * // Delete one Scenario
     * const Scenario = await prisma.scenario.delete({
     *   where: {
     *     // ... filter to delete one Scenario
     *   }
     * })
     * 
     */
    delete<T extends ScenarioDeleteArgs>(args: SelectSubset<T, ScenarioDeleteArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Scenario.
     * @param {ScenarioUpdateArgs} args - Arguments to update one Scenario.
     * @example
     * // Update one Scenario
     * const scenario = await prisma.scenario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScenarioUpdateArgs>(args: SelectSubset<T, ScenarioUpdateArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Scenarios.
     * @param {ScenarioDeleteManyArgs} args - Arguments to filter Scenarios to delete.
     * @example
     * // Delete a few Scenarios
     * const { count } = await prisma.scenario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScenarioDeleteManyArgs>(args?: SelectSubset<T, ScenarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scenarios
     * const scenario = await prisma.scenario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScenarioUpdateManyArgs>(args: SelectSubset<T, ScenarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scenarios and returns the data updated in the database.
     * @param {ScenarioUpdateManyAndReturnArgs} args - Arguments to update many Scenarios.
     * @example
     * // Update many Scenarios
     * const scenario = await prisma.scenario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Scenarios and only return the `id`
     * const scenarioWithIdOnly = await prisma.scenario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScenarioUpdateManyAndReturnArgs>(args: SelectSubset<T, ScenarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Scenario.
     * @param {ScenarioUpsertArgs} args - Arguments to update or create a Scenario.
     * @example
     * // Update or create a Scenario
     * const scenario = await prisma.scenario.upsert({
     *   create: {
     *     // ... data to create a Scenario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scenario we want to update
     *   }
     * })
     */
    upsert<T extends ScenarioUpsertArgs>(args: SelectSubset<T, ScenarioUpsertArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Scenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioCountArgs} args - Arguments to filter Scenarios to count.
     * @example
     * // Count the number of Scenarios
     * const count = await prisma.scenario.count({
     *   where: {
     *     // ... the filter for the Scenarios we want to count
     *   }
     * })
    **/
    count<T extends ScenarioCountArgs>(
      args?: Subset<T, ScenarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScenarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScenarioAggregateArgs>(args: Subset<T, ScenarioAggregateArgs>): Prisma.PrismaPromise<GetScenarioAggregateType<T>>

    /**
     * Group by Scenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScenarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScenarioGroupByArgs['orderBy'] }
        : { orderBy?: ScenarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScenarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScenarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Scenario model
   */
  readonly fields: ScenarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Scenario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScenarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    character<T extends Scenario$characterArgs<ExtArgs> = {}>(args?: Subset<T, Scenario$characterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Scenario model
   */
  interface ScenarioFieldRefs {
    readonly id: FieldRef<"Scenario", 'String'>
    readonly name: FieldRef<"Scenario", 'String'>
    readonly universe: FieldRef<"Scenario", 'String'>
    readonly description: FieldRef<"Scenario", 'String'>
    readonly userId: FieldRef<"Scenario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Scenario findUnique
   */
  export type ScenarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario findUniqueOrThrow
   */
  export type ScenarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario findFirst
   */
  export type ScenarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scenarios.
     */
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario findFirstOrThrow
   */
  export type ScenarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scenarios.
     */
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario findMany
   */
  export type ScenarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenarios to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario create
   */
  export type ScenarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Scenario.
     */
    data: XOR<ScenarioCreateInput, ScenarioUncheckedCreateInput>
  }

  /**
   * Scenario createMany
   */
  export type ScenarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Scenarios.
     */
    data: ScenarioCreateManyInput | ScenarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Scenario createManyAndReturn
   */
  export type ScenarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * The data used to create many Scenarios.
     */
    data: ScenarioCreateManyInput | ScenarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Scenario update
   */
  export type ScenarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Scenario.
     */
    data: XOR<ScenarioUpdateInput, ScenarioUncheckedUpdateInput>
    /**
     * Choose, which Scenario to update.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario updateMany
   */
  export type ScenarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Scenarios.
     */
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyInput>
    /**
     * Filter which Scenarios to update
     */
    where?: ScenarioWhereInput
    /**
     * Limit how many Scenarios to update.
     */
    limit?: number
  }

  /**
   * Scenario updateManyAndReturn
   */
  export type ScenarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * The data used to update Scenarios.
     */
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyInput>
    /**
     * Filter which Scenarios to update
     */
    where?: ScenarioWhereInput
    /**
     * Limit how many Scenarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Scenario upsert
   */
  export type ScenarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Scenario to update in case it exists.
     */
    where: ScenarioWhereUniqueInput
    /**
     * In case the Scenario found by the `where` argument doesn't exist, create a new Scenario with this data.
     */
    create: XOR<ScenarioCreateInput, ScenarioUncheckedCreateInput>
    /**
     * In case the Scenario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScenarioUpdateInput, ScenarioUncheckedUpdateInput>
  }

  /**
   * Scenario delete
   */
  export type ScenarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter which Scenario to delete.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario deleteMany
   */
  export type ScenarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scenarios to delete
     */
    where?: ScenarioWhereInput
    /**
     * Limit how many Scenarios to delete.
     */
    limit?: number
  }

  /**
   * Scenario.character
   */
  export type Scenario$characterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Scenario without action
   */
  export type ScenarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
  }


  /**
   * Model Character
   */

  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterAvgAggregateOutputType = {
    age: number | null
  }

  export type CharacterSumAggregateOutputType = {
    age: number | null
  }

  export type CharacterMinAggregateOutputType = {
    id: string | null
    name: string | null
    pj: boolean | null
    age: number | null
    image: string | null
    origin: string | null
    role: string | null
    injury: string | null
    extra: string | null
    fortuneId: string | null
    alignmentId: string | null
    tempermentId: string | null
  }

  export type CharacterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    pj: boolean | null
    age: number | null
    image: string | null
    origin: string | null
    role: string | null
    injury: string | null
    extra: string | null
    fortuneId: string | null
    alignmentId: string | null
    tempermentId: string | null
  }

  export type CharacterCountAggregateOutputType = {
    id: number
    name: number
    pj: number
    age: number
    image: number
    origin: number
    role: number
    injury: number
    extra: number
    fortuneId: number
    alignmentId: number
    tempermentId: number
    _all: number
  }


  export type CharacterAvgAggregateInputType = {
    age?: true
  }

  export type CharacterSumAggregateInputType = {
    age?: true
  }

  export type CharacterMinAggregateInputType = {
    id?: true
    name?: true
    pj?: true
    age?: true
    image?: true
    origin?: true
    role?: true
    injury?: true
    extra?: true
    fortuneId?: true
    alignmentId?: true
    tempermentId?: true
  }

  export type CharacterMaxAggregateInputType = {
    id?: true
    name?: true
    pj?: true
    age?: true
    image?: true
    origin?: true
    role?: true
    injury?: true
    extra?: true
    fortuneId?: true
    alignmentId?: true
    tempermentId?: true
  }

  export type CharacterCountAggregateInputType = {
    id?: true
    name?: true
    pj?: true
    age?: true
    image?: true
    origin?: true
    role?: true
    injury?: true
    extra?: true
    fortuneId?: true
    alignmentId?: true
    tempermentId?: true
    _all?: true
  }

  export type CharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character to aggregate.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithAggregationInput | CharacterOrderByWithAggregationInput[]
    by: CharacterScalarFieldEnum[] | CharacterScalarFieldEnum
    having?: CharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _avg?: CharacterAvgAggregateInputType
    _sum?: CharacterSumAggregateInputType
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }

  export type CharacterGroupByOutputType = {
    id: string
    name: string
    pj: boolean
    age: number | null
    image: string | null
    origin: string | null
    role: string | null
    injury: string | null
    extra: string | null
    fortuneId: string | null
    alignmentId: string | null
    tempermentId: string | null
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pj?: boolean
    age?: boolean
    image?: boolean
    origin?: boolean
    role?: boolean
    injury?: boolean
    extra?: boolean
    fortuneId?: boolean
    alignmentId?: boolean
    tempermentId?: boolean
    weapon?: boolean | Character$weaponArgs<ExtArgs>
    skillSet?: boolean | Character$skillSetArgs<ExtArgs>
    scenario?: boolean | Character$scenarioArgs<ExtArgs>
    strength?: boolean | Character$strengthArgs<ExtArgs>
    weakness?: boolean | Character$weaknessArgs<ExtArgs>
    fortune?: boolean | Character$fortuneArgs<ExtArgs>
    alignment?: boolean | Character$alignmentArgs<ExtArgs>
    temperment?: boolean | Character$tempermentArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pj?: boolean
    age?: boolean
    image?: boolean
    origin?: boolean
    role?: boolean
    injury?: boolean
    extra?: boolean
    fortuneId?: boolean
    alignmentId?: boolean
    tempermentId?: boolean
    fortune?: boolean | Character$fortuneArgs<ExtArgs>
    alignment?: boolean | Character$alignmentArgs<ExtArgs>
    temperment?: boolean | Character$tempermentArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pj?: boolean
    age?: boolean
    image?: boolean
    origin?: boolean
    role?: boolean
    injury?: boolean
    extra?: boolean
    fortuneId?: boolean
    alignmentId?: boolean
    tempermentId?: boolean
    fortune?: boolean | Character$fortuneArgs<ExtArgs>
    alignment?: boolean | Character$alignmentArgs<ExtArgs>
    temperment?: boolean | Character$tempermentArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectScalar = {
    id?: boolean
    name?: boolean
    pj?: boolean
    age?: boolean
    image?: boolean
    origin?: boolean
    role?: boolean
    injury?: boolean
    extra?: boolean
    fortuneId?: boolean
    alignmentId?: boolean
    tempermentId?: boolean
  }

  export type CharacterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "pj" | "age" | "image" | "origin" | "role" | "injury" | "extra" | "fortuneId" | "alignmentId" | "tempermentId", ExtArgs["result"]["character"]>
  export type CharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | Character$weaponArgs<ExtArgs>
    skillSet?: boolean | Character$skillSetArgs<ExtArgs>
    scenario?: boolean | Character$scenarioArgs<ExtArgs>
    strength?: boolean | Character$strengthArgs<ExtArgs>
    weakness?: boolean | Character$weaknessArgs<ExtArgs>
    fortune?: boolean | Character$fortuneArgs<ExtArgs>
    alignment?: boolean | Character$alignmentArgs<ExtArgs>
    temperment?: boolean | Character$tempermentArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharacterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fortune?: boolean | Character$fortuneArgs<ExtArgs>
    alignment?: boolean | Character$alignmentArgs<ExtArgs>
    temperment?: boolean | Character$tempermentArgs<ExtArgs>
  }
  export type CharacterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fortune?: boolean | Character$fortuneArgs<ExtArgs>
    alignment?: boolean | Character$alignmentArgs<ExtArgs>
    temperment?: boolean | Character$tempermentArgs<ExtArgs>
  }

  export type $CharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Character"
    objects: {
      weapon: Prisma.$WeaponPayload<ExtArgs>[]
      skillSet: Prisma.$CharacterSkillPayload<ExtArgs>[]
      scenario: Prisma.$ScenarioPayload<ExtArgs>[]
      strength: Prisma.$StrengthPayload<ExtArgs>[]
      weakness: Prisma.$WeaknessPayload<ExtArgs>[]
      fortune: Prisma.$FortunePayload<ExtArgs> | null
      alignment: Prisma.$AlignmentPayload<ExtArgs> | null
      temperment: Prisma.$TempermentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      pj: boolean
      age: number | null
      image: string | null
      origin: string | null
      role: string | null
      injury: string | null
      extra: string | null
      fortuneId: string | null
      alignmentId: string | null
      tempermentId: string | null
    }, ExtArgs["result"]["character"]>
    composites: {}
  }

  type CharacterGetPayload<S extends boolean | null | undefined | CharacterDefaultArgs> = $Result.GetResult<Prisma.$CharacterPayload, S>

  type CharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterCountAggregateInputType | true
    }

  export interface CharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Character'], meta: { name: 'Character' } }
    /**
     * Find zero or one Character that matches the filter.
     * @param {CharacterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterFindUniqueArgs>(args: SelectSubset<T, CharacterFindUniqueArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterFindUniqueOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterFindFirstArgs>(args?: SelectSubset<T, CharacterFindFirstArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterWithIdOnly = await prisma.character.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterFindManyArgs>(args?: SelectSubset<T, CharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character.
     * @param {CharacterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
     */
    create<T extends CharacterCreateArgs>(args: SelectSubset<T, CharacterCreateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Characters.
     * @param {CharacterCreateManyArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterCreateManyArgs>(args?: SelectSubset<T, CharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Characters and returns the data saved in the database.
     * @param {CharacterCreateManyAndReturnArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Characters and only return the `id`
     * const characterWithIdOnly = await prisma.character.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character.
     * @param {CharacterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
     */
    delete<T extends CharacterDeleteArgs>(args: SelectSubset<T, CharacterDeleteArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character.
     * @param {CharacterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterUpdateArgs>(args: SelectSubset<T, CharacterUpdateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Characters.
     * @param {CharacterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterDeleteManyArgs>(args?: SelectSubset<T, CharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterUpdateManyArgs>(args: SelectSubset<T, CharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters and returns the data updated in the database.
     * @param {CharacterUpdateManyAndReturnArgs} args - Arguments to update many Characters.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Characters and only return the `id`
     * const characterWithIdOnly = await prisma.character.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character.
     * @param {CharacterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
     */
    upsert<T extends CharacterUpsertArgs>(args: SelectSubset<T, CharacterUpsertArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharacterCountArgs>(
      args?: Subset<T, CharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): Prisma.PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Character model
   */
  readonly fields: CharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    weapon<T extends Character$weaponArgs<ExtArgs> = {}>(args?: Subset<T, Character$weaponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skillSet<T extends Character$skillSetArgs<ExtArgs> = {}>(args?: Subset<T, Character$skillSetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scenario<T extends Character$scenarioArgs<ExtArgs> = {}>(args?: Subset<T, Character$scenarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    strength<T extends Character$strengthArgs<ExtArgs> = {}>(args?: Subset<T, Character$strengthArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrengthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    weakness<T extends Character$weaknessArgs<ExtArgs> = {}>(args?: Subset<T, Character$weaknessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaknessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fortune<T extends Character$fortuneArgs<ExtArgs> = {}>(args?: Subset<T, Character$fortuneArgs<ExtArgs>>): Prisma__FortuneClient<$Result.GetResult<Prisma.$FortunePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    alignment<T extends Character$alignmentArgs<ExtArgs> = {}>(args?: Subset<T, Character$alignmentArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    temperment<T extends Character$tempermentArgs<ExtArgs> = {}>(args?: Subset<T, Character$tempermentArgs<ExtArgs>>): Prisma__TempermentClient<$Result.GetResult<Prisma.$TempermentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Character model
   */
  interface CharacterFieldRefs {
    readonly id: FieldRef<"Character", 'String'>
    readonly name: FieldRef<"Character", 'String'>
    readonly pj: FieldRef<"Character", 'Boolean'>
    readonly age: FieldRef<"Character", 'Int'>
    readonly image: FieldRef<"Character", 'String'>
    readonly origin: FieldRef<"Character", 'String'>
    readonly role: FieldRef<"Character", 'String'>
    readonly injury: FieldRef<"Character", 'String'>
    readonly extra: FieldRef<"Character", 'String'>
    readonly fortuneId: FieldRef<"Character", 'String'>
    readonly alignmentId: FieldRef<"Character", 'String'>
    readonly tempermentId: FieldRef<"Character", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Character findUnique
   */
  export type CharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findUniqueOrThrow
   */
  export type CharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findFirst
   */
  export type CharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findFirstOrThrow
   */
  export type CharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findMany
   */
  export type CharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character create
   */
  export type CharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a Character.
     */
    data: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
  }

  /**
   * Character createMany
   */
  export type CharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Character createManyAndReturn
   */
  export type CharacterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Character update
   */
  export type CharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a Character.
     */
    data: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
    /**
     * Choose, which Character to update.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character updateMany
   */
  export type CharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
  }

  /**
   * Character updateManyAndReturn
   */
  export type CharacterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Character upsert
   */
  export type CharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the Character to update in case it exists.
     */
    where: CharacterWhereUniqueInput
    /**
     * In case the Character found by the `where` argument doesn't exist, create a new Character with this data.
     */
    create: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
    /**
     * In case the Character was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
  }

  /**
   * Character delete
   */
  export type CharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter which Character to delete.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character deleteMany
   */
  export type CharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to delete
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to delete.
     */
    limit?: number
  }

  /**
   * Character.weapon
   */
  export type Character$weaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    where?: WeaponWhereInput
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    cursor?: WeaponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Character.skillSet
   */
  export type Character$skillSetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSkill
     */
    omit?: CharacterSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    where?: CharacterSkillWhereInput
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    cursor?: CharacterSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }

  /**
   * Character.scenario
   */
  export type Character$scenarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    where?: ScenarioWhereInput
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    cursor?: ScenarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Character.strength
   */
  export type Character$strengthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength
     */
    select?: StrengthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength
     */
    omit?: StrengthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthInclude<ExtArgs> | null
    where?: StrengthWhereInput
    orderBy?: StrengthOrderByWithRelationInput | StrengthOrderByWithRelationInput[]
    cursor?: StrengthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StrengthScalarFieldEnum | StrengthScalarFieldEnum[]
  }

  /**
   * Character.weakness
   */
  export type Character$weaknessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weakness
     */
    select?: WeaknessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weakness
     */
    omit?: WeaknessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaknessInclude<ExtArgs> | null
    where?: WeaknessWhereInput
    orderBy?: WeaknessOrderByWithRelationInput | WeaknessOrderByWithRelationInput[]
    cursor?: WeaknessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeaknessScalarFieldEnum | WeaknessScalarFieldEnum[]
  }

  /**
   * Character.fortune
   */
  export type Character$fortuneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fortune
     */
    select?: FortuneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fortune
     */
    omit?: FortuneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FortuneInclude<ExtArgs> | null
    where?: FortuneWhereInput
  }

  /**
   * Character.alignment
   */
  export type Character$alignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    where?: AlignmentWhereInput
  }

  /**
   * Character.temperment
   */
  export type Character$tempermentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temperment
     */
    select?: TempermentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Temperment
     */
    omit?: TempermentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempermentInclude<ExtArgs> | null
    where?: TempermentWhereInput
  }

  /**
   * Character without action
   */
  export type CharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
  }


  /**
   * Model CharacterSkill
   */

  export type AggregateCharacterSkill = {
    _count: CharacterSkillCountAggregateOutputType | null
    _min: CharacterSkillMinAggregateOutputType | null
    _max: CharacterSkillMaxAggregateOutputType | null
  }

  export type CharacterSkillMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CharacterSkillMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CharacterSkillCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CharacterSkillMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CharacterSkillMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CharacterSkillCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CharacterSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterSkill to aggregate.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterSkills
    **/
    _count?: true | CharacterSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterSkillMaxAggregateInputType
  }

  export type GetCharacterSkillAggregateType<T extends CharacterSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterSkill[P]>
      : GetScalarType<T[P], AggregateCharacterSkill[P]>
  }




  export type CharacterSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSkillWhereInput
    orderBy?: CharacterSkillOrderByWithAggregationInput | CharacterSkillOrderByWithAggregationInput[]
    by: CharacterSkillScalarFieldEnum[] | CharacterSkillScalarFieldEnum
    having?: CharacterSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterSkillCountAggregateInputType | true
    _min?: CharacterSkillMinAggregateInputType
    _max?: CharacterSkillMaxAggregateInputType
  }

  export type CharacterSkillGroupByOutputType = {
    id: string
    name: string
    _count: CharacterSkillCountAggregateOutputType | null
    _min: CharacterSkillMinAggregateOutputType | null
    _max: CharacterSkillMaxAggregateOutputType | null
  }

  type GetCharacterSkillGroupByPayload<T extends CharacterSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterSkillGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterSkillGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    character?: boolean | CharacterSkill$characterArgs<ExtArgs>
    _count?: boolean | CharacterSkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterSkill"]>

  export type CharacterSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["characterSkill"]>

  export type CharacterSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["characterSkill"]>

  export type CharacterSkillSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CharacterSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["characterSkill"]>
  export type CharacterSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterSkill$characterArgs<ExtArgs>
    _count?: boolean | CharacterSkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharacterSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CharacterSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CharacterSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterSkill"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["characterSkill"]>
    composites: {}
  }

  type CharacterSkillGetPayload<S extends boolean | null | undefined | CharacterSkillDefaultArgs> = $Result.GetResult<Prisma.$CharacterSkillPayload, S>

  type CharacterSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterSkillCountAggregateInputType | true
    }

  export interface CharacterSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterSkill'], meta: { name: 'CharacterSkill' } }
    /**
     * Find zero or one CharacterSkill that matches the filter.
     * @param {CharacterSkillFindUniqueArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterSkillFindUniqueArgs>(args: SelectSubset<T, CharacterSkillFindUniqueArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CharacterSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterSkillFindUniqueOrThrowArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillFindFirstArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterSkillFindFirstArgs>(args?: SelectSubset<T, CharacterSkillFindFirstArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillFindFirstOrThrowArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CharacterSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterSkills
     * const characterSkills = await prisma.characterSkill.findMany()
     * 
     * // Get first 10 CharacterSkills
     * const characterSkills = await prisma.characterSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterSkillWithIdOnly = await prisma.characterSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterSkillFindManyArgs>(args?: SelectSubset<T, CharacterSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CharacterSkill.
     * @param {CharacterSkillCreateArgs} args - Arguments to create a CharacterSkill.
     * @example
     * // Create one CharacterSkill
     * const CharacterSkill = await prisma.characterSkill.create({
     *   data: {
     *     // ... data to create a CharacterSkill
     *   }
     * })
     * 
     */
    create<T extends CharacterSkillCreateArgs>(args: SelectSubset<T, CharacterSkillCreateArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CharacterSkills.
     * @param {CharacterSkillCreateManyArgs} args - Arguments to create many CharacterSkills.
     * @example
     * // Create many CharacterSkills
     * const characterSkill = await prisma.characterSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterSkillCreateManyArgs>(args?: SelectSubset<T, CharacterSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterSkills and returns the data saved in the database.
     * @param {CharacterSkillCreateManyAndReturnArgs} args - Arguments to create many CharacterSkills.
     * @example
     * // Create many CharacterSkills
     * const characterSkill = await prisma.characterSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterSkills and only return the `id`
     * const characterSkillWithIdOnly = await prisma.characterSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CharacterSkill.
     * @param {CharacterSkillDeleteArgs} args - Arguments to delete one CharacterSkill.
     * @example
     * // Delete one CharacterSkill
     * const CharacterSkill = await prisma.characterSkill.delete({
     *   where: {
     *     // ... filter to delete one CharacterSkill
     *   }
     * })
     * 
     */
    delete<T extends CharacterSkillDeleteArgs>(args: SelectSubset<T, CharacterSkillDeleteArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CharacterSkill.
     * @param {CharacterSkillUpdateArgs} args - Arguments to update one CharacterSkill.
     * @example
     * // Update one CharacterSkill
     * const characterSkill = await prisma.characterSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterSkillUpdateArgs>(args: SelectSubset<T, CharacterSkillUpdateArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CharacterSkills.
     * @param {CharacterSkillDeleteManyArgs} args - Arguments to filter CharacterSkills to delete.
     * @example
     * // Delete a few CharacterSkills
     * const { count } = await prisma.characterSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterSkillDeleteManyArgs>(args?: SelectSubset<T, CharacterSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterSkills
     * const characterSkill = await prisma.characterSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterSkillUpdateManyArgs>(args: SelectSubset<T, CharacterSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterSkills and returns the data updated in the database.
     * @param {CharacterSkillUpdateManyAndReturnArgs} args - Arguments to update many CharacterSkills.
     * @example
     * // Update many CharacterSkills
     * const characterSkill = await prisma.characterSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CharacterSkills and only return the `id`
     * const characterSkillWithIdOnly = await prisma.characterSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CharacterSkill.
     * @param {CharacterSkillUpsertArgs} args - Arguments to update or create a CharacterSkill.
     * @example
     * // Update or create a CharacterSkill
     * const characterSkill = await prisma.characterSkill.upsert({
     *   create: {
     *     // ... data to create a CharacterSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterSkill we want to update
     *   }
     * })
     */
    upsert<T extends CharacterSkillUpsertArgs>(args: SelectSubset<T, CharacterSkillUpsertArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CharacterSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillCountArgs} args - Arguments to filter CharacterSkills to count.
     * @example
     * // Count the number of CharacterSkills
     * const count = await prisma.characterSkill.count({
     *   where: {
     *     // ... the filter for the CharacterSkills we want to count
     *   }
     * })
    **/
    count<T extends CharacterSkillCountArgs>(
      args?: Subset<T, CharacterSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterSkillAggregateArgs>(args: Subset<T, CharacterSkillAggregateArgs>): Prisma.PrismaPromise<GetCharacterSkillAggregateType<T>>

    /**
     * Group by CharacterSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterSkillGroupByArgs['orderBy'] }
        : { orderBy?: CharacterSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterSkill model
   */
  readonly fields: CharacterSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CharacterSkill$characterArgs<ExtArgs> = {}>(args?: Subset<T, CharacterSkill$characterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterSkill model
   */
  interface CharacterSkillFieldRefs {
    readonly id: FieldRef<"CharacterSkill", 'String'>
    readonly name: FieldRef<"CharacterSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CharacterSkill findUnique
   */
  export type CharacterSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSkill
     */
    omit?: CharacterSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where: CharacterSkillWhereUniqueInput
  }

  /**
   * CharacterSkill findUniqueOrThrow
   */
  export type CharacterSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSkill
     */
    omit?: CharacterSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where: CharacterSkillWhereUniqueInput
  }

  /**
   * CharacterSkill findFirst
   */
  export type CharacterSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSkill
     */
    omit?: CharacterSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterSkills.
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterSkills.
     */
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }

  /**
   * CharacterSkill findFirstOrThrow
   */
  export type CharacterSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSkill
     */
    omit?: CharacterSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterSkills.
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterSkills.
     */
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }

  /**
   * CharacterSkill findMany
   */
  export type CharacterSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSkill
     */
    omit?: CharacterSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkills to fetch.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterSkills.
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }

  /**
   * CharacterSkill create
   */
  export type CharacterSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSkill
     */
    omit?: CharacterSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterSkill.
     */
    data: XOR<CharacterSkillCreateInput, CharacterSkillUncheckedCreateInput>
  }

  /**
   * CharacterSkill createMany
   */
  export type CharacterSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterSkills.
     */
    data: CharacterSkillCreateManyInput | CharacterSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterSkill createManyAndReturn
   */
  export type CharacterSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSkill
     */
    omit?: CharacterSkillOmit<ExtArgs> | null
    /**
     * The data used to create many CharacterSkills.
     */
    data: CharacterSkillCreateManyInput | CharacterSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterSkill update
   */
  export type CharacterSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSkill
     */
    omit?: CharacterSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterSkill.
     */
    data: XOR<CharacterSkillUpdateInput, CharacterSkillUncheckedUpdateInput>
    /**
     * Choose, which CharacterSkill to update.
     */
    where: CharacterSkillWhereUniqueInput
  }

  /**
   * CharacterSkill updateMany
   */
  export type CharacterSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterSkills.
     */
    data: XOR<CharacterSkillUpdateManyMutationInput, CharacterSkillUncheckedUpdateManyInput>
    /**
     * Filter which CharacterSkills to update
     */
    where?: CharacterSkillWhereInput
    /**
     * Limit how many CharacterSkills to update.
     */
    limit?: number
  }

  /**
   * CharacterSkill updateManyAndReturn
   */
  export type CharacterSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSkill
     */
    omit?: CharacterSkillOmit<ExtArgs> | null
    /**
     * The data used to update CharacterSkills.
     */
    data: XOR<CharacterSkillUpdateManyMutationInput, CharacterSkillUncheckedUpdateManyInput>
    /**
     * Filter which CharacterSkills to update
     */
    where?: CharacterSkillWhereInput
    /**
     * Limit how many CharacterSkills to update.
     */
    limit?: number
  }

  /**
   * CharacterSkill upsert
   */
  export type CharacterSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSkill
     */
    omit?: CharacterSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterSkill to update in case it exists.
     */
    where: CharacterSkillWhereUniqueInput
    /**
     * In case the CharacterSkill found by the `where` argument doesn't exist, create a new CharacterSkill with this data.
     */
    create: XOR<CharacterSkillCreateInput, CharacterSkillUncheckedCreateInput>
    /**
     * In case the CharacterSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterSkillUpdateInput, CharacterSkillUncheckedUpdateInput>
  }

  /**
   * CharacterSkill delete
   */
  export type CharacterSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSkill
     */
    omit?: CharacterSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter which CharacterSkill to delete.
     */
    where: CharacterSkillWhereUniqueInput
  }

  /**
   * CharacterSkill deleteMany
   */
  export type CharacterSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterSkills to delete
     */
    where?: CharacterSkillWhereInput
    /**
     * Limit how many CharacterSkills to delete.
     */
    limit?: number
  }

  /**
   * CharacterSkill.character
   */
  export type CharacterSkill$characterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * CharacterSkill without action
   */
  export type CharacterSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterSkill
     */
    omit?: CharacterSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
  }


  /**
   * Model Fortune
   */

  export type AggregateFortune = {
    _count: FortuneCountAggregateOutputType | null
    _min: FortuneMinAggregateOutputType | null
    _max: FortuneMaxAggregateOutputType | null
  }

  export type FortuneMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type FortuneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type FortuneCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type FortuneMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type FortuneMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type FortuneCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type FortuneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fortune to aggregate.
     */
    where?: FortuneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fortunes to fetch.
     */
    orderBy?: FortuneOrderByWithRelationInput | FortuneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FortuneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fortunes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fortunes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fortunes
    **/
    _count?: true | FortuneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FortuneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FortuneMaxAggregateInputType
  }

  export type GetFortuneAggregateType<T extends FortuneAggregateArgs> = {
        [P in keyof T & keyof AggregateFortune]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFortune[P]>
      : GetScalarType<T[P], AggregateFortune[P]>
  }




  export type FortuneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FortuneWhereInput
    orderBy?: FortuneOrderByWithAggregationInput | FortuneOrderByWithAggregationInput[]
    by: FortuneScalarFieldEnum[] | FortuneScalarFieldEnum
    having?: FortuneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FortuneCountAggregateInputType | true
    _min?: FortuneMinAggregateInputType
    _max?: FortuneMaxAggregateInputType
  }

  export type FortuneGroupByOutputType = {
    id: string
    name: string
    description: string | null
    _count: FortuneCountAggregateOutputType | null
    _min: FortuneMinAggregateOutputType | null
    _max: FortuneMaxAggregateOutputType | null
  }

  type GetFortuneGroupByPayload<T extends FortuneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FortuneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FortuneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FortuneGroupByOutputType[P]>
            : GetScalarType<T[P], FortuneGroupByOutputType[P]>
        }
      >
    >


  export type FortuneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    character?: boolean | Fortune$characterArgs<ExtArgs>
    _count?: boolean | FortuneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fortune"]>

  export type FortuneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["fortune"]>

  export type FortuneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["fortune"]>

  export type FortuneSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type FortuneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["fortune"]>
  export type FortuneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | Fortune$characterArgs<ExtArgs>
    _count?: boolean | FortuneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FortuneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FortuneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FortunePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fortune"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
    }, ExtArgs["result"]["fortune"]>
    composites: {}
  }

  type FortuneGetPayload<S extends boolean | null | undefined | FortuneDefaultArgs> = $Result.GetResult<Prisma.$FortunePayload, S>

  type FortuneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FortuneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FortuneCountAggregateInputType | true
    }

  export interface FortuneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fortune'], meta: { name: 'Fortune' } }
    /**
     * Find zero or one Fortune that matches the filter.
     * @param {FortuneFindUniqueArgs} args - Arguments to find a Fortune
     * @example
     * // Get one Fortune
     * const fortune = await prisma.fortune.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FortuneFindUniqueArgs>(args: SelectSubset<T, FortuneFindUniqueArgs<ExtArgs>>): Prisma__FortuneClient<$Result.GetResult<Prisma.$FortunePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fortune that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FortuneFindUniqueOrThrowArgs} args - Arguments to find a Fortune
     * @example
     * // Get one Fortune
     * const fortune = await prisma.fortune.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FortuneFindUniqueOrThrowArgs>(args: SelectSubset<T, FortuneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FortuneClient<$Result.GetResult<Prisma.$FortunePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fortune that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FortuneFindFirstArgs} args - Arguments to find a Fortune
     * @example
     * // Get one Fortune
     * const fortune = await prisma.fortune.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FortuneFindFirstArgs>(args?: SelectSubset<T, FortuneFindFirstArgs<ExtArgs>>): Prisma__FortuneClient<$Result.GetResult<Prisma.$FortunePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fortune that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FortuneFindFirstOrThrowArgs} args - Arguments to find a Fortune
     * @example
     * // Get one Fortune
     * const fortune = await prisma.fortune.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FortuneFindFirstOrThrowArgs>(args?: SelectSubset<T, FortuneFindFirstOrThrowArgs<ExtArgs>>): Prisma__FortuneClient<$Result.GetResult<Prisma.$FortunePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fortunes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FortuneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fortunes
     * const fortunes = await prisma.fortune.findMany()
     * 
     * // Get first 10 Fortunes
     * const fortunes = await prisma.fortune.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fortuneWithIdOnly = await prisma.fortune.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FortuneFindManyArgs>(args?: SelectSubset<T, FortuneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FortunePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fortune.
     * @param {FortuneCreateArgs} args - Arguments to create a Fortune.
     * @example
     * // Create one Fortune
     * const Fortune = await prisma.fortune.create({
     *   data: {
     *     // ... data to create a Fortune
     *   }
     * })
     * 
     */
    create<T extends FortuneCreateArgs>(args: SelectSubset<T, FortuneCreateArgs<ExtArgs>>): Prisma__FortuneClient<$Result.GetResult<Prisma.$FortunePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fortunes.
     * @param {FortuneCreateManyArgs} args - Arguments to create many Fortunes.
     * @example
     * // Create many Fortunes
     * const fortune = await prisma.fortune.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FortuneCreateManyArgs>(args?: SelectSubset<T, FortuneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fortunes and returns the data saved in the database.
     * @param {FortuneCreateManyAndReturnArgs} args - Arguments to create many Fortunes.
     * @example
     * // Create many Fortunes
     * const fortune = await prisma.fortune.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fortunes and only return the `id`
     * const fortuneWithIdOnly = await prisma.fortune.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FortuneCreateManyAndReturnArgs>(args?: SelectSubset<T, FortuneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FortunePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fortune.
     * @param {FortuneDeleteArgs} args - Arguments to delete one Fortune.
     * @example
     * // Delete one Fortune
     * const Fortune = await prisma.fortune.delete({
     *   where: {
     *     // ... filter to delete one Fortune
     *   }
     * })
     * 
     */
    delete<T extends FortuneDeleteArgs>(args: SelectSubset<T, FortuneDeleteArgs<ExtArgs>>): Prisma__FortuneClient<$Result.GetResult<Prisma.$FortunePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fortune.
     * @param {FortuneUpdateArgs} args - Arguments to update one Fortune.
     * @example
     * // Update one Fortune
     * const fortune = await prisma.fortune.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FortuneUpdateArgs>(args: SelectSubset<T, FortuneUpdateArgs<ExtArgs>>): Prisma__FortuneClient<$Result.GetResult<Prisma.$FortunePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fortunes.
     * @param {FortuneDeleteManyArgs} args - Arguments to filter Fortunes to delete.
     * @example
     * // Delete a few Fortunes
     * const { count } = await prisma.fortune.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FortuneDeleteManyArgs>(args?: SelectSubset<T, FortuneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fortunes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FortuneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fortunes
     * const fortune = await prisma.fortune.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FortuneUpdateManyArgs>(args: SelectSubset<T, FortuneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fortunes and returns the data updated in the database.
     * @param {FortuneUpdateManyAndReturnArgs} args - Arguments to update many Fortunes.
     * @example
     * // Update many Fortunes
     * const fortune = await prisma.fortune.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fortunes and only return the `id`
     * const fortuneWithIdOnly = await prisma.fortune.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FortuneUpdateManyAndReturnArgs>(args: SelectSubset<T, FortuneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FortunePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fortune.
     * @param {FortuneUpsertArgs} args - Arguments to update or create a Fortune.
     * @example
     * // Update or create a Fortune
     * const fortune = await prisma.fortune.upsert({
     *   create: {
     *     // ... data to create a Fortune
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fortune we want to update
     *   }
     * })
     */
    upsert<T extends FortuneUpsertArgs>(args: SelectSubset<T, FortuneUpsertArgs<ExtArgs>>): Prisma__FortuneClient<$Result.GetResult<Prisma.$FortunePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fortunes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FortuneCountArgs} args - Arguments to filter Fortunes to count.
     * @example
     * // Count the number of Fortunes
     * const count = await prisma.fortune.count({
     *   where: {
     *     // ... the filter for the Fortunes we want to count
     *   }
     * })
    **/
    count<T extends FortuneCountArgs>(
      args?: Subset<T, FortuneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FortuneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fortune.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FortuneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FortuneAggregateArgs>(args: Subset<T, FortuneAggregateArgs>): Prisma.PrismaPromise<GetFortuneAggregateType<T>>

    /**
     * Group by Fortune.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FortuneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FortuneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FortuneGroupByArgs['orderBy'] }
        : { orderBy?: FortuneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FortuneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFortuneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fortune model
   */
  readonly fields: FortuneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fortune.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FortuneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends Fortune$characterArgs<ExtArgs> = {}>(args?: Subset<T, Fortune$characterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fortune model
   */
  interface FortuneFieldRefs {
    readonly id: FieldRef<"Fortune", 'String'>
    readonly name: FieldRef<"Fortune", 'String'>
    readonly description: FieldRef<"Fortune", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Fortune findUnique
   */
  export type FortuneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fortune
     */
    select?: FortuneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fortune
     */
    omit?: FortuneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FortuneInclude<ExtArgs> | null
    /**
     * Filter, which Fortune to fetch.
     */
    where: FortuneWhereUniqueInput
  }

  /**
   * Fortune findUniqueOrThrow
   */
  export type FortuneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fortune
     */
    select?: FortuneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fortune
     */
    omit?: FortuneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FortuneInclude<ExtArgs> | null
    /**
     * Filter, which Fortune to fetch.
     */
    where: FortuneWhereUniqueInput
  }

  /**
   * Fortune findFirst
   */
  export type FortuneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fortune
     */
    select?: FortuneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fortune
     */
    omit?: FortuneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FortuneInclude<ExtArgs> | null
    /**
     * Filter, which Fortune to fetch.
     */
    where?: FortuneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fortunes to fetch.
     */
    orderBy?: FortuneOrderByWithRelationInput | FortuneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fortunes.
     */
    cursor?: FortuneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fortunes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fortunes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fortunes.
     */
    distinct?: FortuneScalarFieldEnum | FortuneScalarFieldEnum[]
  }

  /**
   * Fortune findFirstOrThrow
   */
  export type FortuneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fortune
     */
    select?: FortuneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fortune
     */
    omit?: FortuneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FortuneInclude<ExtArgs> | null
    /**
     * Filter, which Fortune to fetch.
     */
    where?: FortuneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fortunes to fetch.
     */
    orderBy?: FortuneOrderByWithRelationInput | FortuneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fortunes.
     */
    cursor?: FortuneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fortunes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fortunes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fortunes.
     */
    distinct?: FortuneScalarFieldEnum | FortuneScalarFieldEnum[]
  }

  /**
   * Fortune findMany
   */
  export type FortuneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fortune
     */
    select?: FortuneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fortune
     */
    omit?: FortuneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FortuneInclude<ExtArgs> | null
    /**
     * Filter, which Fortunes to fetch.
     */
    where?: FortuneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fortunes to fetch.
     */
    orderBy?: FortuneOrderByWithRelationInput | FortuneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fortunes.
     */
    cursor?: FortuneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fortunes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fortunes.
     */
    skip?: number
    distinct?: FortuneScalarFieldEnum | FortuneScalarFieldEnum[]
  }

  /**
   * Fortune create
   */
  export type FortuneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fortune
     */
    select?: FortuneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fortune
     */
    omit?: FortuneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FortuneInclude<ExtArgs> | null
    /**
     * The data needed to create a Fortune.
     */
    data: XOR<FortuneCreateInput, FortuneUncheckedCreateInput>
  }

  /**
   * Fortune createMany
   */
  export type FortuneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fortunes.
     */
    data: FortuneCreateManyInput | FortuneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fortune createManyAndReturn
   */
  export type FortuneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fortune
     */
    select?: FortuneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fortune
     */
    omit?: FortuneOmit<ExtArgs> | null
    /**
     * The data used to create many Fortunes.
     */
    data: FortuneCreateManyInput | FortuneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fortune update
   */
  export type FortuneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fortune
     */
    select?: FortuneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fortune
     */
    omit?: FortuneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FortuneInclude<ExtArgs> | null
    /**
     * The data needed to update a Fortune.
     */
    data: XOR<FortuneUpdateInput, FortuneUncheckedUpdateInput>
    /**
     * Choose, which Fortune to update.
     */
    where: FortuneWhereUniqueInput
  }

  /**
   * Fortune updateMany
   */
  export type FortuneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fortunes.
     */
    data: XOR<FortuneUpdateManyMutationInput, FortuneUncheckedUpdateManyInput>
    /**
     * Filter which Fortunes to update
     */
    where?: FortuneWhereInput
    /**
     * Limit how many Fortunes to update.
     */
    limit?: number
  }

  /**
   * Fortune updateManyAndReturn
   */
  export type FortuneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fortune
     */
    select?: FortuneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fortune
     */
    omit?: FortuneOmit<ExtArgs> | null
    /**
     * The data used to update Fortunes.
     */
    data: XOR<FortuneUpdateManyMutationInput, FortuneUncheckedUpdateManyInput>
    /**
     * Filter which Fortunes to update
     */
    where?: FortuneWhereInput
    /**
     * Limit how many Fortunes to update.
     */
    limit?: number
  }

  /**
   * Fortune upsert
   */
  export type FortuneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fortune
     */
    select?: FortuneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fortune
     */
    omit?: FortuneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FortuneInclude<ExtArgs> | null
    /**
     * The filter to search for the Fortune to update in case it exists.
     */
    where: FortuneWhereUniqueInput
    /**
     * In case the Fortune found by the `where` argument doesn't exist, create a new Fortune with this data.
     */
    create: XOR<FortuneCreateInput, FortuneUncheckedCreateInput>
    /**
     * In case the Fortune was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FortuneUpdateInput, FortuneUncheckedUpdateInput>
  }

  /**
   * Fortune delete
   */
  export type FortuneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fortune
     */
    select?: FortuneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fortune
     */
    omit?: FortuneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FortuneInclude<ExtArgs> | null
    /**
     * Filter which Fortune to delete.
     */
    where: FortuneWhereUniqueInput
  }

  /**
   * Fortune deleteMany
   */
  export type FortuneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fortunes to delete
     */
    where?: FortuneWhereInput
    /**
     * Limit how many Fortunes to delete.
     */
    limit?: number
  }

  /**
   * Fortune.character
   */
  export type Fortune$characterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Fortune without action
   */
  export type FortuneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fortune
     */
    select?: FortuneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fortune
     */
    omit?: FortuneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FortuneInclude<ExtArgs> | null
  }


  /**
   * Model Alignment
   */

  export type AggregateAlignment = {
    _count: AlignmentCountAggregateOutputType | null
    _min: AlignmentMinAggregateOutputType | null
    _max: AlignmentMaxAggregateOutputType | null
  }

  export type AlignmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type AlignmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type AlignmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type AlignmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type AlignmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type AlignmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type AlignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alignment to aggregate.
     */
    where?: AlignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alignments to fetch.
     */
    orderBy?: AlignmentOrderByWithRelationInput | AlignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alignments
    **/
    _count?: true | AlignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlignmentMaxAggregateInputType
  }

  export type GetAlignmentAggregateType<T extends AlignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAlignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlignment[P]>
      : GetScalarType<T[P], AggregateAlignment[P]>
  }




  export type AlignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlignmentWhereInput
    orderBy?: AlignmentOrderByWithAggregationInput | AlignmentOrderByWithAggregationInput[]
    by: AlignmentScalarFieldEnum[] | AlignmentScalarFieldEnum
    having?: AlignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlignmentCountAggregateInputType | true
    _min?: AlignmentMinAggregateInputType
    _max?: AlignmentMaxAggregateInputType
  }

  export type AlignmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    _count: AlignmentCountAggregateOutputType | null
    _min: AlignmentMinAggregateOutputType | null
    _max: AlignmentMaxAggregateOutputType | null
  }

  type GetAlignmentGroupByPayload<T extends AlignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AlignmentGroupByOutputType[P]>
        }
      >
    >


  export type AlignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    character?: boolean | Alignment$characterArgs<ExtArgs>
    _count?: boolean | AlignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alignment"]>

  export type AlignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["alignment"]>

  export type AlignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["alignment"]>

  export type AlignmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type AlignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["alignment"]>
  export type AlignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | Alignment$characterArgs<ExtArgs>
    _count?: boolean | AlignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AlignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AlignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alignment"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
    }, ExtArgs["result"]["alignment"]>
    composites: {}
  }

  type AlignmentGetPayload<S extends boolean | null | undefined | AlignmentDefaultArgs> = $Result.GetResult<Prisma.$AlignmentPayload, S>

  type AlignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlignmentCountAggregateInputType | true
    }

  export interface AlignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alignment'], meta: { name: 'Alignment' } }
    /**
     * Find zero or one Alignment that matches the filter.
     * @param {AlignmentFindUniqueArgs} args - Arguments to find a Alignment
     * @example
     * // Get one Alignment
     * const alignment = await prisma.alignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlignmentFindUniqueArgs>(args: SelectSubset<T, AlignmentFindUniqueArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlignmentFindUniqueOrThrowArgs} args - Arguments to find a Alignment
     * @example
     * // Get one Alignment
     * const alignment = await prisma.alignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AlignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentFindFirstArgs} args - Arguments to find a Alignment
     * @example
     * // Get one Alignment
     * const alignment = await prisma.alignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlignmentFindFirstArgs>(args?: SelectSubset<T, AlignmentFindFirstArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentFindFirstOrThrowArgs} args - Arguments to find a Alignment
     * @example
     * // Get one Alignment
     * const alignment = await prisma.alignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AlignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alignments
     * const alignments = await prisma.alignment.findMany()
     * 
     * // Get first 10 Alignments
     * const alignments = await prisma.alignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alignmentWithIdOnly = await prisma.alignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlignmentFindManyArgs>(args?: SelectSubset<T, AlignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alignment.
     * @param {AlignmentCreateArgs} args - Arguments to create a Alignment.
     * @example
     * // Create one Alignment
     * const Alignment = await prisma.alignment.create({
     *   data: {
     *     // ... data to create a Alignment
     *   }
     * })
     * 
     */
    create<T extends AlignmentCreateArgs>(args: SelectSubset<T, AlignmentCreateArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alignments.
     * @param {AlignmentCreateManyArgs} args - Arguments to create many Alignments.
     * @example
     * // Create many Alignments
     * const alignment = await prisma.alignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlignmentCreateManyArgs>(args?: SelectSubset<T, AlignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alignments and returns the data saved in the database.
     * @param {AlignmentCreateManyAndReturnArgs} args - Arguments to create many Alignments.
     * @example
     * // Create many Alignments
     * const alignment = await prisma.alignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alignments and only return the `id`
     * const alignmentWithIdOnly = await prisma.alignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AlignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Alignment.
     * @param {AlignmentDeleteArgs} args - Arguments to delete one Alignment.
     * @example
     * // Delete one Alignment
     * const Alignment = await prisma.alignment.delete({
     *   where: {
     *     // ... filter to delete one Alignment
     *   }
     * })
     * 
     */
    delete<T extends AlignmentDeleteArgs>(args: SelectSubset<T, AlignmentDeleteArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alignment.
     * @param {AlignmentUpdateArgs} args - Arguments to update one Alignment.
     * @example
     * // Update one Alignment
     * const alignment = await prisma.alignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlignmentUpdateArgs>(args: SelectSubset<T, AlignmentUpdateArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alignments.
     * @param {AlignmentDeleteManyArgs} args - Arguments to filter Alignments to delete.
     * @example
     * // Delete a few Alignments
     * const { count } = await prisma.alignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlignmentDeleteManyArgs>(args?: SelectSubset<T, AlignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alignments
     * const alignment = await prisma.alignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlignmentUpdateManyArgs>(args: SelectSubset<T, AlignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alignments and returns the data updated in the database.
     * @param {AlignmentUpdateManyAndReturnArgs} args - Arguments to update many Alignments.
     * @example
     * // Update many Alignments
     * const alignment = await prisma.alignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alignments and only return the `id`
     * const alignmentWithIdOnly = await prisma.alignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AlignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Alignment.
     * @param {AlignmentUpsertArgs} args - Arguments to update or create a Alignment.
     * @example
     * // Update or create a Alignment
     * const alignment = await prisma.alignment.upsert({
     *   create: {
     *     // ... data to create a Alignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alignment we want to update
     *   }
     * })
     */
    upsert<T extends AlignmentUpsertArgs>(args: SelectSubset<T, AlignmentUpsertArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentCountArgs} args - Arguments to filter Alignments to count.
     * @example
     * // Count the number of Alignments
     * const count = await prisma.alignment.count({
     *   where: {
     *     // ... the filter for the Alignments we want to count
     *   }
     * })
    **/
    count<T extends AlignmentCountArgs>(
      args?: Subset<T, AlignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlignmentAggregateArgs>(args: Subset<T, AlignmentAggregateArgs>): Prisma.PrismaPromise<GetAlignmentAggregateType<T>>

    /**
     * Group by Alignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlignmentGroupByArgs['orderBy'] }
        : { orderBy?: AlignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alignment model
   */
  readonly fields: AlignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends Alignment$characterArgs<ExtArgs> = {}>(args?: Subset<T, Alignment$characterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alignment model
   */
  interface AlignmentFieldRefs {
    readonly id: FieldRef<"Alignment", 'String'>
    readonly name: FieldRef<"Alignment", 'String'>
    readonly description: FieldRef<"Alignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Alignment findUnique
   */
  export type AlignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignment to fetch.
     */
    where: AlignmentWhereUniqueInput
  }

  /**
   * Alignment findUniqueOrThrow
   */
  export type AlignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignment to fetch.
     */
    where: AlignmentWhereUniqueInput
  }

  /**
   * Alignment findFirst
   */
  export type AlignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignment to fetch.
     */
    where?: AlignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alignments to fetch.
     */
    orderBy?: AlignmentOrderByWithRelationInput | AlignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alignments.
     */
    cursor?: AlignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alignments.
     */
    distinct?: AlignmentScalarFieldEnum | AlignmentScalarFieldEnum[]
  }

  /**
   * Alignment findFirstOrThrow
   */
  export type AlignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignment to fetch.
     */
    where?: AlignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alignments to fetch.
     */
    orderBy?: AlignmentOrderByWithRelationInput | AlignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alignments.
     */
    cursor?: AlignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alignments.
     */
    distinct?: AlignmentScalarFieldEnum | AlignmentScalarFieldEnum[]
  }

  /**
   * Alignment findMany
   */
  export type AlignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignments to fetch.
     */
    where?: AlignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alignments to fetch.
     */
    orderBy?: AlignmentOrderByWithRelationInput | AlignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alignments.
     */
    cursor?: AlignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alignments.
     */
    skip?: number
    distinct?: AlignmentScalarFieldEnum | AlignmentScalarFieldEnum[]
  }

  /**
   * Alignment create
   */
  export type AlignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Alignment.
     */
    data: XOR<AlignmentCreateInput, AlignmentUncheckedCreateInput>
  }

  /**
   * Alignment createMany
   */
  export type AlignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alignments.
     */
    data: AlignmentCreateManyInput | AlignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alignment createManyAndReturn
   */
  export type AlignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * The data used to create many Alignments.
     */
    data: AlignmentCreateManyInput | AlignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alignment update
   */
  export type AlignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Alignment.
     */
    data: XOR<AlignmentUpdateInput, AlignmentUncheckedUpdateInput>
    /**
     * Choose, which Alignment to update.
     */
    where: AlignmentWhereUniqueInput
  }

  /**
   * Alignment updateMany
   */
  export type AlignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alignments.
     */
    data: XOR<AlignmentUpdateManyMutationInput, AlignmentUncheckedUpdateManyInput>
    /**
     * Filter which Alignments to update
     */
    where?: AlignmentWhereInput
    /**
     * Limit how many Alignments to update.
     */
    limit?: number
  }

  /**
   * Alignment updateManyAndReturn
   */
  export type AlignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * The data used to update Alignments.
     */
    data: XOR<AlignmentUpdateManyMutationInput, AlignmentUncheckedUpdateManyInput>
    /**
     * Filter which Alignments to update
     */
    where?: AlignmentWhereInput
    /**
     * Limit how many Alignments to update.
     */
    limit?: number
  }

  /**
   * Alignment upsert
   */
  export type AlignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Alignment to update in case it exists.
     */
    where: AlignmentWhereUniqueInput
    /**
     * In case the Alignment found by the `where` argument doesn't exist, create a new Alignment with this data.
     */
    create: XOR<AlignmentCreateInput, AlignmentUncheckedCreateInput>
    /**
     * In case the Alignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlignmentUpdateInput, AlignmentUncheckedUpdateInput>
  }

  /**
   * Alignment delete
   */
  export type AlignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter which Alignment to delete.
     */
    where: AlignmentWhereUniqueInput
  }

  /**
   * Alignment deleteMany
   */
  export type AlignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alignments to delete
     */
    where?: AlignmentWhereInput
    /**
     * Limit how many Alignments to delete.
     */
    limit?: number
  }

  /**
   * Alignment.character
   */
  export type Alignment$characterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Alignment without action
   */
  export type AlignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
  }


  /**
   * Model Temperment
   */

  export type AggregateTemperment = {
    _count: TempermentCountAggregateOutputType | null
    _min: TempermentMinAggregateOutputType | null
    _max: TempermentMaxAggregateOutputType | null
  }

  export type TempermentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type TempermentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type TempermentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type TempermentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type TempermentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type TempermentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type TempermentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Temperment to aggregate.
     */
    where?: TempermentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temperments to fetch.
     */
    orderBy?: TempermentOrderByWithRelationInput | TempermentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TempermentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temperments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temperments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Temperments
    **/
    _count?: true | TempermentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TempermentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TempermentMaxAggregateInputType
  }

  export type GetTempermentAggregateType<T extends TempermentAggregateArgs> = {
        [P in keyof T & keyof AggregateTemperment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemperment[P]>
      : GetScalarType<T[P], AggregateTemperment[P]>
  }




  export type TempermentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TempermentWhereInput
    orderBy?: TempermentOrderByWithAggregationInput | TempermentOrderByWithAggregationInput[]
    by: TempermentScalarFieldEnum[] | TempermentScalarFieldEnum
    having?: TempermentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TempermentCountAggregateInputType | true
    _min?: TempermentMinAggregateInputType
    _max?: TempermentMaxAggregateInputType
  }

  export type TempermentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    _count: TempermentCountAggregateOutputType | null
    _min: TempermentMinAggregateOutputType | null
    _max: TempermentMaxAggregateOutputType | null
  }

  type GetTempermentGroupByPayload<T extends TempermentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TempermentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TempermentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TempermentGroupByOutputType[P]>
            : GetScalarType<T[P], TempermentGroupByOutputType[P]>
        }
      >
    >


  export type TempermentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    character?: boolean | Temperment$characterArgs<ExtArgs>
    _count?: boolean | TempermentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["temperment"]>

  export type TempermentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["temperment"]>

  export type TempermentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["temperment"]>

  export type TempermentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type TempermentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["temperment"]>
  export type TempermentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | Temperment$characterArgs<ExtArgs>
    _count?: boolean | TempermentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TempermentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TempermentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TempermentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Temperment"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
    }, ExtArgs["result"]["temperment"]>
    composites: {}
  }

  type TempermentGetPayload<S extends boolean | null | undefined | TempermentDefaultArgs> = $Result.GetResult<Prisma.$TempermentPayload, S>

  type TempermentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TempermentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TempermentCountAggregateInputType | true
    }

  export interface TempermentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Temperment'], meta: { name: 'Temperment' } }
    /**
     * Find zero or one Temperment that matches the filter.
     * @param {TempermentFindUniqueArgs} args - Arguments to find a Temperment
     * @example
     * // Get one Temperment
     * const temperment = await prisma.temperment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TempermentFindUniqueArgs>(args: SelectSubset<T, TempermentFindUniqueArgs<ExtArgs>>): Prisma__TempermentClient<$Result.GetResult<Prisma.$TempermentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Temperment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TempermentFindUniqueOrThrowArgs} args - Arguments to find a Temperment
     * @example
     * // Get one Temperment
     * const temperment = await prisma.temperment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TempermentFindUniqueOrThrowArgs>(args: SelectSubset<T, TempermentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TempermentClient<$Result.GetResult<Prisma.$TempermentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Temperment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempermentFindFirstArgs} args - Arguments to find a Temperment
     * @example
     * // Get one Temperment
     * const temperment = await prisma.temperment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TempermentFindFirstArgs>(args?: SelectSubset<T, TempermentFindFirstArgs<ExtArgs>>): Prisma__TempermentClient<$Result.GetResult<Prisma.$TempermentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Temperment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempermentFindFirstOrThrowArgs} args - Arguments to find a Temperment
     * @example
     * // Get one Temperment
     * const temperment = await prisma.temperment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TempermentFindFirstOrThrowArgs>(args?: SelectSubset<T, TempermentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TempermentClient<$Result.GetResult<Prisma.$TempermentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Temperments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempermentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Temperments
     * const temperments = await prisma.temperment.findMany()
     * 
     * // Get first 10 Temperments
     * const temperments = await prisma.temperment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tempermentWithIdOnly = await prisma.temperment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TempermentFindManyArgs>(args?: SelectSubset<T, TempermentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempermentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Temperment.
     * @param {TempermentCreateArgs} args - Arguments to create a Temperment.
     * @example
     * // Create one Temperment
     * const Temperment = await prisma.temperment.create({
     *   data: {
     *     // ... data to create a Temperment
     *   }
     * })
     * 
     */
    create<T extends TempermentCreateArgs>(args: SelectSubset<T, TempermentCreateArgs<ExtArgs>>): Prisma__TempermentClient<$Result.GetResult<Prisma.$TempermentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Temperments.
     * @param {TempermentCreateManyArgs} args - Arguments to create many Temperments.
     * @example
     * // Create many Temperments
     * const temperment = await prisma.temperment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TempermentCreateManyArgs>(args?: SelectSubset<T, TempermentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Temperments and returns the data saved in the database.
     * @param {TempermentCreateManyAndReturnArgs} args - Arguments to create many Temperments.
     * @example
     * // Create many Temperments
     * const temperment = await prisma.temperment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Temperments and only return the `id`
     * const tempermentWithIdOnly = await prisma.temperment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TempermentCreateManyAndReturnArgs>(args?: SelectSubset<T, TempermentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempermentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Temperment.
     * @param {TempermentDeleteArgs} args - Arguments to delete one Temperment.
     * @example
     * // Delete one Temperment
     * const Temperment = await prisma.temperment.delete({
     *   where: {
     *     // ... filter to delete one Temperment
     *   }
     * })
     * 
     */
    delete<T extends TempermentDeleteArgs>(args: SelectSubset<T, TempermentDeleteArgs<ExtArgs>>): Prisma__TempermentClient<$Result.GetResult<Prisma.$TempermentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Temperment.
     * @param {TempermentUpdateArgs} args - Arguments to update one Temperment.
     * @example
     * // Update one Temperment
     * const temperment = await prisma.temperment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TempermentUpdateArgs>(args: SelectSubset<T, TempermentUpdateArgs<ExtArgs>>): Prisma__TempermentClient<$Result.GetResult<Prisma.$TempermentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Temperments.
     * @param {TempermentDeleteManyArgs} args - Arguments to filter Temperments to delete.
     * @example
     * // Delete a few Temperments
     * const { count } = await prisma.temperment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TempermentDeleteManyArgs>(args?: SelectSubset<T, TempermentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Temperments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempermentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Temperments
     * const temperment = await prisma.temperment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TempermentUpdateManyArgs>(args: SelectSubset<T, TempermentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Temperments and returns the data updated in the database.
     * @param {TempermentUpdateManyAndReturnArgs} args - Arguments to update many Temperments.
     * @example
     * // Update many Temperments
     * const temperment = await prisma.temperment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Temperments and only return the `id`
     * const tempermentWithIdOnly = await prisma.temperment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TempermentUpdateManyAndReturnArgs>(args: SelectSubset<T, TempermentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempermentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Temperment.
     * @param {TempermentUpsertArgs} args - Arguments to update or create a Temperment.
     * @example
     * // Update or create a Temperment
     * const temperment = await prisma.temperment.upsert({
     *   create: {
     *     // ... data to create a Temperment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Temperment we want to update
     *   }
     * })
     */
    upsert<T extends TempermentUpsertArgs>(args: SelectSubset<T, TempermentUpsertArgs<ExtArgs>>): Prisma__TempermentClient<$Result.GetResult<Prisma.$TempermentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Temperments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempermentCountArgs} args - Arguments to filter Temperments to count.
     * @example
     * // Count the number of Temperments
     * const count = await prisma.temperment.count({
     *   where: {
     *     // ... the filter for the Temperments we want to count
     *   }
     * })
    **/
    count<T extends TempermentCountArgs>(
      args?: Subset<T, TempermentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TempermentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Temperment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempermentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TempermentAggregateArgs>(args: Subset<T, TempermentAggregateArgs>): Prisma.PrismaPromise<GetTempermentAggregateType<T>>

    /**
     * Group by Temperment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempermentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TempermentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TempermentGroupByArgs['orderBy'] }
        : { orderBy?: TempermentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TempermentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTempermentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Temperment model
   */
  readonly fields: TempermentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Temperment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TempermentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends Temperment$characterArgs<ExtArgs> = {}>(args?: Subset<T, Temperment$characterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Temperment model
   */
  interface TempermentFieldRefs {
    readonly id: FieldRef<"Temperment", 'String'>
    readonly name: FieldRef<"Temperment", 'String'>
    readonly description: FieldRef<"Temperment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Temperment findUnique
   */
  export type TempermentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temperment
     */
    select?: TempermentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Temperment
     */
    omit?: TempermentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempermentInclude<ExtArgs> | null
    /**
     * Filter, which Temperment to fetch.
     */
    where: TempermentWhereUniqueInput
  }

  /**
   * Temperment findUniqueOrThrow
   */
  export type TempermentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temperment
     */
    select?: TempermentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Temperment
     */
    omit?: TempermentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempermentInclude<ExtArgs> | null
    /**
     * Filter, which Temperment to fetch.
     */
    where: TempermentWhereUniqueInput
  }

  /**
   * Temperment findFirst
   */
  export type TempermentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temperment
     */
    select?: TempermentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Temperment
     */
    omit?: TempermentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempermentInclude<ExtArgs> | null
    /**
     * Filter, which Temperment to fetch.
     */
    where?: TempermentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temperments to fetch.
     */
    orderBy?: TempermentOrderByWithRelationInput | TempermentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Temperments.
     */
    cursor?: TempermentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temperments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temperments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Temperments.
     */
    distinct?: TempermentScalarFieldEnum | TempermentScalarFieldEnum[]
  }

  /**
   * Temperment findFirstOrThrow
   */
  export type TempermentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temperment
     */
    select?: TempermentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Temperment
     */
    omit?: TempermentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempermentInclude<ExtArgs> | null
    /**
     * Filter, which Temperment to fetch.
     */
    where?: TempermentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temperments to fetch.
     */
    orderBy?: TempermentOrderByWithRelationInput | TempermentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Temperments.
     */
    cursor?: TempermentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temperments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temperments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Temperments.
     */
    distinct?: TempermentScalarFieldEnum | TempermentScalarFieldEnum[]
  }

  /**
   * Temperment findMany
   */
  export type TempermentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temperment
     */
    select?: TempermentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Temperment
     */
    omit?: TempermentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempermentInclude<ExtArgs> | null
    /**
     * Filter, which Temperments to fetch.
     */
    where?: TempermentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temperments to fetch.
     */
    orderBy?: TempermentOrderByWithRelationInput | TempermentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Temperments.
     */
    cursor?: TempermentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temperments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temperments.
     */
    skip?: number
    distinct?: TempermentScalarFieldEnum | TempermentScalarFieldEnum[]
  }

  /**
   * Temperment create
   */
  export type TempermentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temperment
     */
    select?: TempermentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Temperment
     */
    omit?: TempermentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempermentInclude<ExtArgs> | null
    /**
     * The data needed to create a Temperment.
     */
    data: XOR<TempermentCreateInput, TempermentUncheckedCreateInput>
  }

  /**
   * Temperment createMany
   */
  export type TempermentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Temperments.
     */
    data: TempermentCreateManyInput | TempermentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Temperment createManyAndReturn
   */
  export type TempermentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temperment
     */
    select?: TempermentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Temperment
     */
    omit?: TempermentOmit<ExtArgs> | null
    /**
     * The data used to create many Temperments.
     */
    data: TempermentCreateManyInput | TempermentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Temperment update
   */
  export type TempermentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temperment
     */
    select?: TempermentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Temperment
     */
    omit?: TempermentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempermentInclude<ExtArgs> | null
    /**
     * The data needed to update a Temperment.
     */
    data: XOR<TempermentUpdateInput, TempermentUncheckedUpdateInput>
    /**
     * Choose, which Temperment to update.
     */
    where: TempermentWhereUniqueInput
  }

  /**
   * Temperment updateMany
   */
  export type TempermentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Temperments.
     */
    data: XOR<TempermentUpdateManyMutationInput, TempermentUncheckedUpdateManyInput>
    /**
     * Filter which Temperments to update
     */
    where?: TempermentWhereInput
    /**
     * Limit how many Temperments to update.
     */
    limit?: number
  }

  /**
   * Temperment updateManyAndReturn
   */
  export type TempermentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temperment
     */
    select?: TempermentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Temperment
     */
    omit?: TempermentOmit<ExtArgs> | null
    /**
     * The data used to update Temperments.
     */
    data: XOR<TempermentUpdateManyMutationInput, TempermentUncheckedUpdateManyInput>
    /**
     * Filter which Temperments to update
     */
    where?: TempermentWhereInput
    /**
     * Limit how many Temperments to update.
     */
    limit?: number
  }

  /**
   * Temperment upsert
   */
  export type TempermentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temperment
     */
    select?: TempermentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Temperment
     */
    omit?: TempermentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempermentInclude<ExtArgs> | null
    /**
     * The filter to search for the Temperment to update in case it exists.
     */
    where: TempermentWhereUniqueInput
    /**
     * In case the Temperment found by the `where` argument doesn't exist, create a new Temperment with this data.
     */
    create: XOR<TempermentCreateInput, TempermentUncheckedCreateInput>
    /**
     * In case the Temperment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TempermentUpdateInput, TempermentUncheckedUpdateInput>
  }

  /**
   * Temperment delete
   */
  export type TempermentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temperment
     */
    select?: TempermentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Temperment
     */
    omit?: TempermentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempermentInclude<ExtArgs> | null
    /**
     * Filter which Temperment to delete.
     */
    where: TempermentWhereUniqueInput
  }

  /**
   * Temperment deleteMany
   */
  export type TempermentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Temperments to delete
     */
    where?: TempermentWhereInput
    /**
     * Limit how many Temperments to delete.
     */
    limit?: number
  }

  /**
   * Temperment.character
   */
  export type Temperment$characterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Temperment without action
   */
  export type TempermentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Temperment
     */
    select?: TempermentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Temperment
     */
    omit?: TempermentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TempermentInclude<ExtArgs> | null
  }


  /**
   * Model Strength
   */

  export type AggregateStrength = {
    _count: StrengthCountAggregateOutputType | null
    _min: StrengthMinAggregateOutputType | null
    _max: StrengthMaxAggregateOutputType | null
  }

  export type StrengthMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type StrengthMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type StrengthCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type StrengthMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type StrengthMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type StrengthCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type StrengthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Strength to aggregate.
     */
    where?: StrengthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strengths to fetch.
     */
    orderBy?: StrengthOrderByWithRelationInput | StrengthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StrengthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strengths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strengths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Strengths
    **/
    _count?: true | StrengthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrengthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrengthMaxAggregateInputType
  }

  export type GetStrengthAggregateType<T extends StrengthAggregateArgs> = {
        [P in keyof T & keyof AggregateStrength]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrength[P]>
      : GetScalarType<T[P], AggregateStrength[P]>
  }




  export type StrengthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrengthWhereInput
    orderBy?: StrengthOrderByWithAggregationInput | StrengthOrderByWithAggregationInput[]
    by: StrengthScalarFieldEnum[] | StrengthScalarFieldEnum
    having?: StrengthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrengthCountAggregateInputType | true
    _min?: StrengthMinAggregateInputType
    _max?: StrengthMaxAggregateInputType
  }

  export type StrengthGroupByOutputType = {
    id: string
    name: string
    _count: StrengthCountAggregateOutputType | null
    _min: StrengthMinAggregateOutputType | null
    _max: StrengthMaxAggregateOutputType | null
  }

  type GetStrengthGroupByPayload<T extends StrengthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StrengthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrengthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrengthGroupByOutputType[P]>
            : GetScalarType<T[P], StrengthGroupByOutputType[P]>
        }
      >
    >


  export type StrengthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    character?: boolean | Strength$characterArgs<ExtArgs>
    _count?: boolean | StrengthCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strength"]>

  export type StrengthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["strength"]>

  export type StrengthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["strength"]>

  export type StrengthSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type StrengthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["strength"]>
  export type StrengthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | Strength$characterArgs<ExtArgs>
    _count?: boolean | StrengthCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StrengthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StrengthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StrengthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Strength"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["strength"]>
    composites: {}
  }

  type StrengthGetPayload<S extends boolean | null | undefined | StrengthDefaultArgs> = $Result.GetResult<Prisma.$StrengthPayload, S>

  type StrengthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StrengthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StrengthCountAggregateInputType | true
    }

  export interface StrengthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Strength'], meta: { name: 'Strength' } }
    /**
     * Find zero or one Strength that matches the filter.
     * @param {StrengthFindUniqueArgs} args - Arguments to find a Strength
     * @example
     * // Get one Strength
     * const strength = await prisma.strength.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StrengthFindUniqueArgs>(args: SelectSubset<T, StrengthFindUniqueArgs<ExtArgs>>): Prisma__StrengthClient<$Result.GetResult<Prisma.$StrengthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Strength that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StrengthFindUniqueOrThrowArgs} args - Arguments to find a Strength
     * @example
     * // Get one Strength
     * const strength = await prisma.strength.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StrengthFindUniqueOrThrowArgs>(args: SelectSubset<T, StrengthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StrengthClient<$Result.GetResult<Prisma.$StrengthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Strength that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthFindFirstArgs} args - Arguments to find a Strength
     * @example
     * // Get one Strength
     * const strength = await prisma.strength.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StrengthFindFirstArgs>(args?: SelectSubset<T, StrengthFindFirstArgs<ExtArgs>>): Prisma__StrengthClient<$Result.GetResult<Prisma.$StrengthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Strength that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthFindFirstOrThrowArgs} args - Arguments to find a Strength
     * @example
     * // Get one Strength
     * const strength = await prisma.strength.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StrengthFindFirstOrThrowArgs>(args?: SelectSubset<T, StrengthFindFirstOrThrowArgs<ExtArgs>>): Prisma__StrengthClient<$Result.GetResult<Prisma.$StrengthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Strengths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Strengths
     * const strengths = await prisma.strength.findMany()
     * 
     * // Get first 10 Strengths
     * const strengths = await prisma.strength.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strengthWithIdOnly = await prisma.strength.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StrengthFindManyArgs>(args?: SelectSubset<T, StrengthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrengthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Strength.
     * @param {StrengthCreateArgs} args - Arguments to create a Strength.
     * @example
     * // Create one Strength
     * const Strength = await prisma.strength.create({
     *   data: {
     *     // ... data to create a Strength
     *   }
     * })
     * 
     */
    create<T extends StrengthCreateArgs>(args: SelectSubset<T, StrengthCreateArgs<ExtArgs>>): Prisma__StrengthClient<$Result.GetResult<Prisma.$StrengthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Strengths.
     * @param {StrengthCreateManyArgs} args - Arguments to create many Strengths.
     * @example
     * // Create many Strengths
     * const strength = await prisma.strength.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StrengthCreateManyArgs>(args?: SelectSubset<T, StrengthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Strengths and returns the data saved in the database.
     * @param {StrengthCreateManyAndReturnArgs} args - Arguments to create many Strengths.
     * @example
     * // Create many Strengths
     * const strength = await prisma.strength.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Strengths and only return the `id`
     * const strengthWithIdOnly = await prisma.strength.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StrengthCreateManyAndReturnArgs>(args?: SelectSubset<T, StrengthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrengthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Strength.
     * @param {StrengthDeleteArgs} args - Arguments to delete one Strength.
     * @example
     * // Delete one Strength
     * const Strength = await prisma.strength.delete({
     *   where: {
     *     // ... filter to delete one Strength
     *   }
     * })
     * 
     */
    delete<T extends StrengthDeleteArgs>(args: SelectSubset<T, StrengthDeleteArgs<ExtArgs>>): Prisma__StrengthClient<$Result.GetResult<Prisma.$StrengthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Strength.
     * @param {StrengthUpdateArgs} args - Arguments to update one Strength.
     * @example
     * // Update one Strength
     * const strength = await prisma.strength.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StrengthUpdateArgs>(args: SelectSubset<T, StrengthUpdateArgs<ExtArgs>>): Prisma__StrengthClient<$Result.GetResult<Prisma.$StrengthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Strengths.
     * @param {StrengthDeleteManyArgs} args - Arguments to filter Strengths to delete.
     * @example
     * // Delete a few Strengths
     * const { count } = await prisma.strength.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StrengthDeleteManyArgs>(args?: SelectSubset<T, StrengthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Strengths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Strengths
     * const strength = await prisma.strength.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StrengthUpdateManyArgs>(args: SelectSubset<T, StrengthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Strengths and returns the data updated in the database.
     * @param {StrengthUpdateManyAndReturnArgs} args - Arguments to update many Strengths.
     * @example
     * // Update many Strengths
     * const strength = await prisma.strength.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Strengths and only return the `id`
     * const strengthWithIdOnly = await prisma.strength.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StrengthUpdateManyAndReturnArgs>(args: SelectSubset<T, StrengthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrengthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Strength.
     * @param {StrengthUpsertArgs} args - Arguments to update or create a Strength.
     * @example
     * // Update or create a Strength
     * const strength = await prisma.strength.upsert({
     *   create: {
     *     // ... data to create a Strength
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Strength we want to update
     *   }
     * })
     */
    upsert<T extends StrengthUpsertArgs>(args: SelectSubset<T, StrengthUpsertArgs<ExtArgs>>): Prisma__StrengthClient<$Result.GetResult<Prisma.$StrengthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Strengths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthCountArgs} args - Arguments to filter Strengths to count.
     * @example
     * // Count the number of Strengths
     * const count = await prisma.strength.count({
     *   where: {
     *     // ... the filter for the Strengths we want to count
     *   }
     * })
    **/
    count<T extends StrengthCountArgs>(
      args?: Subset<T, StrengthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrengthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Strength.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrengthAggregateArgs>(args: Subset<T, StrengthAggregateArgs>): Prisma.PrismaPromise<GetStrengthAggregateType<T>>

    /**
     * Group by Strength.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StrengthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StrengthGroupByArgs['orderBy'] }
        : { orderBy?: StrengthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StrengthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrengthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Strength model
   */
  readonly fields: StrengthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Strength.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StrengthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends Strength$characterArgs<ExtArgs> = {}>(args?: Subset<T, Strength$characterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Strength model
   */
  interface StrengthFieldRefs {
    readonly id: FieldRef<"Strength", 'String'>
    readonly name: FieldRef<"Strength", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Strength findUnique
   */
  export type StrengthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength
     */
    select?: StrengthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength
     */
    omit?: StrengthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthInclude<ExtArgs> | null
    /**
     * Filter, which Strength to fetch.
     */
    where: StrengthWhereUniqueInput
  }

  /**
   * Strength findUniqueOrThrow
   */
  export type StrengthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength
     */
    select?: StrengthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength
     */
    omit?: StrengthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthInclude<ExtArgs> | null
    /**
     * Filter, which Strength to fetch.
     */
    where: StrengthWhereUniqueInput
  }

  /**
   * Strength findFirst
   */
  export type StrengthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength
     */
    select?: StrengthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength
     */
    omit?: StrengthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthInclude<ExtArgs> | null
    /**
     * Filter, which Strength to fetch.
     */
    where?: StrengthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strengths to fetch.
     */
    orderBy?: StrengthOrderByWithRelationInput | StrengthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Strengths.
     */
    cursor?: StrengthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strengths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strengths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Strengths.
     */
    distinct?: StrengthScalarFieldEnum | StrengthScalarFieldEnum[]
  }

  /**
   * Strength findFirstOrThrow
   */
  export type StrengthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength
     */
    select?: StrengthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength
     */
    omit?: StrengthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthInclude<ExtArgs> | null
    /**
     * Filter, which Strength to fetch.
     */
    where?: StrengthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strengths to fetch.
     */
    orderBy?: StrengthOrderByWithRelationInput | StrengthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Strengths.
     */
    cursor?: StrengthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strengths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strengths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Strengths.
     */
    distinct?: StrengthScalarFieldEnum | StrengthScalarFieldEnum[]
  }

  /**
   * Strength findMany
   */
  export type StrengthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength
     */
    select?: StrengthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength
     */
    omit?: StrengthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthInclude<ExtArgs> | null
    /**
     * Filter, which Strengths to fetch.
     */
    where?: StrengthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strengths to fetch.
     */
    orderBy?: StrengthOrderByWithRelationInput | StrengthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Strengths.
     */
    cursor?: StrengthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strengths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strengths.
     */
    skip?: number
    distinct?: StrengthScalarFieldEnum | StrengthScalarFieldEnum[]
  }

  /**
   * Strength create
   */
  export type StrengthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength
     */
    select?: StrengthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength
     */
    omit?: StrengthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthInclude<ExtArgs> | null
    /**
     * The data needed to create a Strength.
     */
    data: XOR<StrengthCreateInput, StrengthUncheckedCreateInput>
  }

  /**
   * Strength createMany
   */
  export type StrengthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Strengths.
     */
    data: StrengthCreateManyInput | StrengthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Strength createManyAndReturn
   */
  export type StrengthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength
     */
    select?: StrengthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Strength
     */
    omit?: StrengthOmit<ExtArgs> | null
    /**
     * The data used to create many Strengths.
     */
    data: StrengthCreateManyInput | StrengthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Strength update
   */
  export type StrengthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength
     */
    select?: StrengthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength
     */
    omit?: StrengthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthInclude<ExtArgs> | null
    /**
     * The data needed to update a Strength.
     */
    data: XOR<StrengthUpdateInput, StrengthUncheckedUpdateInput>
    /**
     * Choose, which Strength to update.
     */
    where: StrengthWhereUniqueInput
  }

  /**
   * Strength updateMany
   */
  export type StrengthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Strengths.
     */
    data: XOR<StrengthUpdateManyMutationInput, StrengthUncheckedUpdateManyInput>
    /**
     * Filter which Strengths to update
     */
    where?: StrengthWhereInput
    /**
     * Limit how many Strengths to update.
     */
    limit?: number
  }

  /**
   * Strength updateManyAndReturn
   */
  export type StrengthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength
     */
    select?: StrengthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Strength
     */
    omit?: StrengthOmit<ExtArgs> | null
    /**
     * The data used to update Strengths.
     */
    data: XOR<StrengthUpdateManyMutationInput, StrengthUncheckedUpdateManyInput>
    /**
     * Filter which Strengths to update
     */
    where?: StrengthWhereInput
    /**
     * Limit how many Strengths to update.
     */
    limit?: number
  }

  /**
   * Strength upsert
   */
  export type StrengthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength
     */
    select?: StrengthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength
     */
    omit?: StrengthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthInclude<ExtArgs> | null
    /**
     * The filter to search for the Strength to update in case it exists.
     */
    where: StrengthWhereUniqueInput
    /**
     * In case the Strength found by the `where` argument doesn't exist, create a new Strength with this data.
     */
    create: XOR<StrengthCreateInput, StrengthUncheckedCreateInput>
    /**
     * In case the Strength was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StrengthUpdateInput, StrengthUncheckedUpdateInput>
  }

  /**
   * Strength delete
   */
  export type StrengthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength
     */
    select?: StrengthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength
     */
    omit?: StrengthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthInclude<ExtArgs> | null
    /**
     * Filter which Strength to delete.
     */
    where: StrengthWhereUniqueInput
  }

  /**
   * Strength deleteMany
   */
  export type StrengthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Strengths to delete
     */
    where?: StrengthWhereInput
    /**
     * Limit how many Strengths to delete.
     */
    limit?: number
  }

  /**
   * Strength.character
   */
  export type Strength$characterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Strength without action
   */
  export type StrengthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength
     */
    select?: StrengthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength
     */
    omit?: StrengthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthInclude<ExtArgs> | null
  }


  /**
   * Model Weakness
   */

  export type AggregateWeakness = {
    _count: WeaknessCountAggregateOutputType | null
    _min: WeaknessMinAggregateOutputType | null
    _max: WeaknessMaxAggregateOutputType | null
  }

  export type WeaknessMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type WeaknessMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type WeaknessCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type WeaknessMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type WeaknessMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type WeaknessCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type WeaknessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weakness to aggregate.
     */
    where?: WeaknessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weaknesses to fetch.
     */
    orderBy?: WeaknessOrderByWithRelationInput | WeaknessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeaknessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weaknesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weaknesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weaknesses
    **/
    _count?: true | WeaknessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeaknessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeaknessMaxAggregateInputType
  }

  export type GetWeaknessAggregateType<T extends WeaknessAggregateArgs> = {
        [P in keyof T & keyof AggregateWeakness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeakness[P]>
      : GetScalarType<T[P], AggregateWeakness[P]>
  }




  export type WeaknessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaknessWhereInput
    orderBy?: WeaknessOrderByWithAggregationInput | WeaknessOrderByWithAggregationInput[]
    by: WeaknessScalarFieldEnum[] | WeaknessScalarFieldEnum
    having?: WeaknessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeaknessCountAggregateInputType | true
    _min?: WeaknessMinAggregateInputType
    _max?: WeaknessMaxAggregateInputType
  }

  export type WeaknessGroupByOutputType = {
    id: string
    name: string
    _count: WeaknessCountAggregateOutputType | null
    _min: WeaknessMinAggregateOutputType | null
    _max: WeaknessMaxAggregateOutputType | null
  }

  type GetWeaknessGroupByPayload<T extends WeaknessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeaknessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeaknessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeaknessGroupByOutputType[P]>
            : GetScalarType<T[P], WeaknessGroupByOutputType[P]>
        }
      >
    >


  export type WeaknessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    character?: boolean | Weakness$characterArgs<ExtArgs>
    _count?: boolean | WeaknessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weakness"]>

  export type WeaknessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["weakness"]>

  export type WeaknessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["weakness"]>

  export type WeaknessSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type WeaknessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["weakness"]>
  export type WeaknessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | Weakness$characterArgs<ExtArgs>
    _count?: boolean | WeaknessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WeaknessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WeaknessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WeaknessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Weakness"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["weakness"]>
    composites: {}
  }

  type WeaknessGetPayload<S extends boolean | null | undefined | WeaknessDefaultArgs> = $Result.GetResult<Prisma.$WeaknessPayload, S>

  type WeaknessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeaknessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeaknessCountAggregateInputType | true
    }

  export interface WeaknessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Weakness'], meta: { name: 'Weakness' } }
    /**
     * Find zero or one Weakness that matches the filter.
     * @param {WeaknessFindUniqueArgs} args - Arguments to find a Weakness
     * @example
     * // Get one Weakness
     * const weakness = await prisma.weakness.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeaknessFindUniqueArgs>(args: SelectSubset<T, WeaknessFindUniqueArgs<ExtArgs>>): Prisma__WeaknessClient<$Result.GetResult<Prisma.$WeaknessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Weakness that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeaknessFindUniqueOrThrowArgs} args - Arguments to find a Weakness
     * @example
     * // Get one Weakness
     * const weakness = await prisma.weakness.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeaknessFindUniqueOrThrowArgs>(args: SelectSubset<T, WeaknessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeaknessClient<$Result.GetResult<Prisma.$WeaknessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weakness that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaknessFindFirstArgs} args - Arguments to find a Weakness
     * @example
     * // Get one Weakness
     * const weakness = await prisma.weakness.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeaknessFindFirstArgs>(args?: SelectSubset<T, WeaknessFindFirstArgs<ExtArgs>>): Prisma__WeaknessClient<$Result.GetResult<Prisma.$WeaknessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weakness that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaknessFindFirstOrThrowArgs} args - Arguments to find a Weakness
     * @example
     * // Get one Weakness
     * const weakness = await prisma.weakness.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeaknessFindFirstOrThrowArgs>(args?: SelectSubset<T, WeaknessFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeaknessClient<$Result.GetResult<Prisma.$WeaknessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Weaknesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaknessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weaknesses
     * const weaknesses = await prisma.weakness.findMany()
     * 
     * // Get first 10 Weaknesses
     * const weaknesses = await prisma.weakness.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weaknessWithIdOnly = await prisma.weakness.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeaknessFindManyArgs>(args?: SelectSubset<T, WeaknessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaknessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Weakness.
     * @param {WeaknessCreateArgs} args - Arguments to create a Weakness.
     * @example
     * // Create one Weakness
     * const Weakness = await prisma.weakness.create({
     *   data: {
     *     // ... data to create a Weakness
     *   }
     * })
     * 
     */
    create<T extends WeaknessCreateArgs>(args: SelectSubset<T, WeaknessCreateArgs<ExtArgs>>): Prisma__WeaknessClient<$Result.GetResult<Prisma.$WeaknessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Weaknesses.
     * @param {WeaknessCreateManyArgs} args - Arguments to create many Weaknesses.
     * @example
     * // Create many Weaknesses
     * const weakness = await prisma.weakness.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeaknessCreateManyArgs>(args?: SelectSubset<T, WeaknessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Weaknesses and returns the data saved in the database.
     * @param {WeaknessCreateManyAndReturnArgs} args - Arguments to create many Weaknesses.
     * @example
     * // Create many Weaknesses
     * const weakness = await prisma.weakness.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Weaknesses and only return the `id`
     * const weaknessWithIdOnly = await prisma.weakness.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeaknessCreateManyAndReturnArgs>(args?: SelectSubset<T, WeaknessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaknessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Weakness.
     * @param {WeaknessDeleteArgs} args - Arguments to delete one Weakness.
     * @example
     * // Delete one Weakness
     * const Weakness = await prisma.weakness.delete({
     *   where: {
     *     // ... filter to delete one Weakness
     *   }
     * })
     * 
     */
    delete<T extends WeaknessDeleteArgs>(args: SelectSubset<T, WeaknessDeleteArgs<ExtArgs>>): Prisma__WeaknessClient<$Result.GetResult<Prisma.$WeaknessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Weakness.
     * @param {WeaknessUpdateArgs} args - Arguments to update one Weakness.
     * @example
     * // Update one Weakness
     * const weakness = await prisma.weakness.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeaknessUpdateArgs>(args: SelectSubset<T, WeaknessUpdateArgs<ExtArgs>>): Prisma__WeaknessClient<$Result.GetResult<Prisma.$WeaknessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Weaknesses.
     * @param {WeaknessDeleteManyArgs} args - Arguments to filter Weaknesses to delete.
     * @example
     * // Delete a few Weaknesses
     * const { count } = await prisma.weakness.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeaknessDeleteManyArgs>(args?: SelectSubset<T, WeaknessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weaknesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaknessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weaknesses
     * const weakness = await prisma.weakness.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeaknessUpdateManyArgs>(args: SelectSubset<T, WeaknessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weaknesses and returns the data updated in the database.
     * @param {WeaknessUpdateManyAndReturnArgs} args - Arguments to update many Weaknesses.
     * @example
     * // Update many Weaknesses
     * const weakness = await prisma.weakness.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Weaknesses and only return the `id`
     * const weaknessWithIdOnly = await prisma.weakness.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeaknessUpdateManyAndReturnArgs>(args: SelectSubset<T, WeaknessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaknessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Weakness.
     * @param {WeaknessUpsertArgs} args - Arguments to update or create a Weakness.
     * @example
     * // Update or create a Weakness
     * const weakness = await prisma.weakness.upsert({
     *   create: {
     *     // ... data to create a Weakness
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weakness we want to update
     *   }
     * })
     */
    upsert<T extends WeaknessUpsertArgs>(args: SelectSubset<T, WeaknessUpsertArgs<ExtArgs>>): Prisma__WeaknessClient<$Result.GetResult<Prisma.$WeaknessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Weaknesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaknessCountArgs} args - Arguments to filter Weaknesses to count.
     * @example
     * // Count the number of Weaknesses
     * const count = await prisma.weakness.count({
     *   where: {
     *     // ... the filter for the Weaknesses we want to count
     *   }
     * })
    **/
    count<T extends WeaknessCountArgs>(
      args?: Subset<T, WeaknessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeaknessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weakness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaknessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeaknessAggregateArgs>(args: Subset<T, WeaknessAggregateArgs>): Prisma.PrismaPromise<GetWeaknessAggregateType<T>>

    /**
     * Group by Weakness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaknessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeaknessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeaknessGroupByArgs['orderBy'] }
        : { orderBy?: WeaknessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeaknessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeaknessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Weakness model
   */
  readonly fields: WeaknessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weakness.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeaknessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends Weakness$characterArgs<ExtArgs> = {}>(args?: Subset<T, Weakness$characterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Weakness model
   */
  interface WeaknessFieldRefs {
    readonly id: FieldRef<"Weakness", 'String'>
    readonly name: FieldRef<"Weakness", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Weakness findUnique
   */
  export type WeaknessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weakness
     */
    select?: WeaknessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weakness
     */
    omit?: WeaknessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaknessInclude<ExtArgs> | null
    /**
     * Filter, which Weakness to fetch.
     */
    where: WeaknessWhereUniqueInput
  }

  /**
   * Weakness findUniqueOrThrow
   */
  export type WeaknessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weakness
     */
    select?: WeaknessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weakness
     */
    omit?: WeaknessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaknessInclude<ExtArgs> | null
    /**
     * Filter, which Weakness to fetch.
     */
    where: WeaknessWhereUniqueInput
  }

  /**
   * Weakness findFirst
   */
  export type WeaknessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weakness
     */
    select?: WeaknessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weakness
     */
    omit?: WeaknessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaknessInclude<ExtArgs> | null
    /**
     * Filter, which Weakness to fetch.
     */
    where?: WeaknessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weaknesses to fetch.
     */
    orderBy?: WeaknessOrderByWithRelationInput | WeaknessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weaknesses.
     */
    cursor?: WeaknessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weaknesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weaknesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weaknesses.
     */
    distinct?: WeaknessScalarFieldEnum | WeaknessScalarFieldEnum[]
  }

  /**
   * Weakness findFirstOrThrow
   */
  export type WeaknessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weakness
     */
    select?: WeaknessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weakness
     */
    omit?: WeaknessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaknessInclude<ExtArgs> | null
    /**
     * Filter, which Weakness to fetch.
     */
    where?: WeaknessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weaknesses to fetch.
     */
    orderBy?: WeaknessOrderByWithRelationInput | WeaknessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weaknesses.
     */
    cursor?: WeaknessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weaknesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weaknesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weaknesses.
     */
    distinct?: WeaknessScalarFieldEnum | WeaknessScalarFieldEnum[]
  }

  /**
   * Weakness findMany
   */
  export type WeaknessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weakness
     */
    select?: WeaknessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weakness
     */
    omit?: WeaknessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaknessInclude<ExtArgs> | null
    /**
     * Filter, which Weaknesses to fetch.
     */
    where?: WeaknessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weaknesses to fetch.
     */
    orderBy?: WeaknessOrderByWithRelationInput | WeaknessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weaknesses.
     */
    cursor?: WeaknessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weaknesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weaknesses.
     */
    skip?: number
    distinct?: WeaknessScalarFieldEnum | WeaknessScalarFieldEnum[]
  }

  /**
   * Weakness create
   */
  export type WeaknessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weakness
     */
    select?: WeaknessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weakness
     */
    omit?: WeaknessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaknessInclude<ExtArgs> | null
    /**
     * The data needed to create a Weakness.
     */
    data: XOR<WeaknessCreateInput, WeaknessUncheckedCreateInput>
  }

  /**
   * Weakness createMany
   */
  export type WeaknessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Weaknesses.
     */
    data: WeaknessCreateManyInput | WeaknessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weakness createManyAndReturn
   */
  export type WeaknessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weakness
     */
    select?: WeaknessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weakness
     */
    omit?: WeaknessOmit<ExtArgs> | null
    /**
     * The data used to create many Weaknesses.
     */
    data: WeaknessCreateManyInput | WeaknessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weakness update
   */
  export type WeaknessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weakness
     */
    select?: WeaknessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weakness
     */
    omit?: WeaknessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaknessInclude<ExtArgs> | null
    /**
     * The data needed to update a Weakness.
     */
    data: XOR<WeaknessUpdateInput, WeaknessUncheckedUpdateInput>
    /**
     * Choose, which Weakness to update.
     */
    where: WeaknessWhereUniqueInput
  }

  /**
   * Weakness updateMany
   */
  export type WeaknessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Weaknesses.
     */
    data: XOR<WeaknessUpdateManyMutationInput, WeaknessUncheckedUpdateManyInput>
    /**
     * Filter which Weaknesses to update
     */
    where?: WeaknessWhereInput
    /**
     * Limit how many Weaknesses to update.
     */
    limit?: number
  }

  /**
   * Weakness updateManyAndReturn
   */
  export type WeaknessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weakness
     */
    select?: WeaknessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weakness
     */
    omit?: WeaknessOmit<ExtArgs> | null
    /**
     * The data used to update Weaknesses.
     */
    data: XOR<WeaknessUpdateManyMutationInput, WeaknessUncheckedUpdateManyInput>
    /**
     * Filter which Weaknesses to update
     */
    where?: WeaknessWhereInput
    /**
     * Limit how many Weaknesses to update.
     */
    limit?: number
  }

  /**
   * Weakness upsert
   */
  export type WeaknessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weakness
     */
    select?: WeaknessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weakness
     */
    omit?: WeaknessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaknessInclude<ExtArgs> | null
    /**
     * The filter to search for the Weakness to update in case it exists.
     */
    where: WeaknessWhereUniqueInput
    /**
     * In case the Weakness found by the `where` argument doesn't exist, create a new Weakness with this data.
     */
    create: XOR<WeaknessCreateInput, WeaknessUncheckedCreateInput>
    /**
     * In case the Weakness was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeaknessUpdateInput, WeaknessUncheckedUpdateInput>
  }

  /**
   * Weakness delete
   */
  export type WeaknessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weakness
     */
    select?: WeaknessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weakness
     */
    omit?: WeaknessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaknessInclude<ExtArgs> | null
    /**
     * Filter which Weakness to delete.
     */
    where: WeaknessWhereUniqueInput
  }

  /**
   * Weakness deleteMany
   */
  export type WeaknessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weaknesses to delete
     */
    where?: WeaknessWhereInput
    /**
     * Limit how many Weaknesses to delete.
     */
    limit?: number
  }

  /**
   * Weakness.character
   */
  export type Weakness$characterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Weakness without action
   */
  export type WeaknessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weakness
     */
    select?: WeaknessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weakness
     */
    omit?: WeaknessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaknessInclude<ExtArgs> | null
  }


  /**
   * Model Weapon
   */

  export type AggregateWeapon = {
    _count: WeaponCountAggregateOutputType | null
    _min: WeaponMinAggregateOutputType | null
    _max: WeaponMaxAggregateOutputType | null
  }

  export type WeaponMinAggregateOutputType = {
    id: string | null
    name: string | null
    melee: boolean | null
    description: string | null
    userId: string | null
    damageId: string | null
    weightId: string | null
    rangeId: string | null
    ammoId: string | null
  }

  export type WeaponMaxAggregateOutputType = {
    id: string | null
    name: string | null
    melee: boolean | null
    description: string | null
    userId: string | null
    damageId: string | null
    weightId: string | null
    rangeId: string | null
    ammoId: string | null
  }

  export type WeaponCountAggregateOutputType = {
    id: number
    name: number
    melee: number
    description: number
    userId: number
    damageId: number
    weightId: number
    rangeId: number
    ammoId: number
    _all: number
  }


  export type WeaponMinAggregateInputType = {
    id?: true
    name?: true
    melee?: true
    description?: true
    userId?: true
    damageId?: true
    weightId?: true
    rangeId?: true
    ammoId?: true
  }

  export type WeaponMaxAggregateInputType = {
    id?: true
    name?: true
    melee?: true
    description?: true
    userId?: true
    damageId?: true
    weightId?: true
    rangeId?: true
    ammoId?: true
  }

  export type WeaponCountAggregateInputType = {
    id?: true
    name?: true
    melee?: true
    description?: true
    userId?: true
    damageId?: true
    weightId?: true
    rangeId?: true
    ammoId?: true
    _all?: true
  }

  export type WeaponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weapon to aggregate.
     */
    where?: WeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weapons to fetch.
     */
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weapons
    **/
    _count?: true | WeaponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeaponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeaponMaxAggregateInputType
  }

  export type GetWeaponAggregateType<T extends WeaponAggregateArgs> = {
        [P in keyof T & keyof AggregateWeapon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeapon[P]>
      : GetScalarType<T[P], AggregateWeapon[P]>
  }




  export type WeaponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponWhereInput
    orderBy?: WeaponOrderByWithAggregationInput | WeaponOrderByWithAggregationInput[]
    by: WeaponScalarFieldEnum[] | WeaponScalarFieldEnum
    having?: WeaponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeaponCountAggregateInputType | true
    _min?: WeaponMinAggregateInputType
    _max?: WeaponMaxAggregateInputType
  }

  export type WeaponGroupByOutputType = {
    id: string
    name: string
    melee: boolean
    description: string | null
    userId: string
    damageId: string
    weightId: string
    rangeId: string
    ammoId: string | null
    _count: WeaponCountAggregateOutputType | null
    _min: WeaponMinAggregateOutputType | null
    _max: WeaponMaxAggregateOutputType | null
  }

  type GetWeaponGroupByPayload<T extends WeaponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeaponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeaponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeaponGroupByOutputType[P]>
            : GetScalarType<T[P], WeaponGroupByOutputType[P]>
        }
      >
    >


  export type WeaponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    melee?: boolean
    description?: boolean
    userId?: boolean
    damageId?: boolean
    weightId?: boolean
    rangeId?: boolean
    ammoId?: boolean
    character?: boolean | Weapon$characterArgs<ExtArgs>
    weaponSkill?: boolean | Weapon$weaponSkillArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    damage?: boolean | DamageDefaultArgs<ExtArgs>
    weight?: boolean | WeightDefaultArgs<ExtArgs>
    range?: boolean | RangeDefaultArgs<ExtArgs>
    ammo?: boolean | Weapon$ammoArgs<ExtArgs>
    _count?: boolean | WeaponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weapon"]>

  export type WeaponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    melee?: boolean
    description?: boolean
    userId?: boolean
    damageId?: boolean
    weightId?: boolean
    rangeId?: boolean
    ammoId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    damage?: boolean | DamageDefaultArgs<ExtArgs>
    weight?: boolean | WeightDefaultArgs<ExtArgs>
    range?: boolean | RangeDefaultArgs<ExtArgs>
    ammo?: boolean | Weapon$ammoArgs<ExtArgs>
  }, ExtArgs["result"]["weapon"]>

  export type WeaponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    melee?: boolean
    description?: boolean
    userId?: boolean
    damageId?: boolean
    weightId?: boolean
    rangeId?: boolean
    ammoId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    damage?: boolean | DamageDefaultArgs<ExtArgs>
    weight?: boolean | WeightDefaultArgs<ExtArgs>
    range?: boolean | RangeDefaultArgs<ExtArgs>
    ammo?: boolean | Weapon$ammoArgs<ExtArgs>
  }, ExtArgs["result"]["weapon"]>

  export type WeaponSelectScalar = {
    id?: boolean
    name?: boolean
    melee?: boolean
    description?: boolean
    userId?: boolean
    damageId?: boolean
    weightId?: boolean
    rangeId?: boolean
    ammoId?: boolean
  }

  export type WeaponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "melee" | "description" | "userId" | "damageId" | "weightId" | "rangeId" | "ammoId", ExtArgs["result"]["weapon"]>
  export type WeaponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | Weapon$characterArgs<ExtArgs>
    weaponSkill?: boolean | Weapon$weaponSkillArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    damage?: boolean | DamageDefaultArgs<ExtArgs>
    weight?: boolean | WeightDefaultArgs<ExtArgs>
    range?: boolean | RangeDefaultArgs<ExtArgs>
    ammo?: boolean | Weapon$ammoArgs<ExtArgs>
    _count?: boolean | WeaponCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WeaponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    damage?: boolean | DamageDefaultArgs<ExtArgs>
    weight?: boolean | WeightDefaultArgs<ExtArgs>
    range?: boolean | RangeDefaultArgs<ExtArgs>
    ammo?: boolean | Weapon$ammoArgs<ExtArgs>
  }
  export type WeaponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    damage?: boolean | DamageDefaultArgs<ExtArgs>
    weight?: boolean | WeightDefaultArgs<ExtArgs>
    range?: boolean | RangeDefaultArgs<ExtArgs>
    ammo?: boolean | Weapon$ammoArgs<ExtArgs>
  }

  export type $WeaponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Weapon"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>[]
      weaponSkill: Prisma.$WeaponSkillPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      damage: Prisma.$DamagePayload<ExtArgs>
      weight: Prisma.$WeightPayload<ExtArgs>
      range: Prisma.$RangePayload<ExtArgs>
      ammo: Prisma.$AmmoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      melee: boolean
      description: string | null
      userId: string
      damageId: string
      weightId: string
      rangeId: string
      ammoId: string | null
    }, ExtArgs["result"]["weapon"]>
    composites: {}
  }

  type WeaponGetPayload<S extends boolean | null | undefined | WeaponDefaultArgs> = $Result.GetResult<Prisma.$WeaponPayload, S>

  type WeaponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeaponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeaponCountAggregateInputType | true
    }

  export interface WeaponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Weapon'], meta: { name: 'Weapon' } }
    /**
     * Find zero or one Weapon that matches the filter.
     * @param {WeaponFindUniqueArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeaponFindUniqueArgs>(args: SelectSubset<T, WeaponFindUniqueArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Weapon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeaponFindUniqueOrThrowArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeaponFindUniqueOrThrowArgs>(args: SelectSubset<T, WeaponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weapon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponFindFirstArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeaponFindFirstArgs>(args?: SelectSubset<T, WeaponFindFirstArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weapon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponFindFirstOrThrowArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeaponFindFirstOrThrowArgs>(args?: SelectSubset<T, WeaponFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Weapons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weapons
     * const weapons = await prisma.weapon.findMany()
     * 
     * // Get first 10 Weapons
     * const weapons = await prisma.weapon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weaponWithIdOnly = await prisma.weapon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeaponFindManyArgs>(args?: SelectSubset<T, WeaponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Weapon.
     * @param {WeaponCreateArgs} args - Arguments to create a Weapon.
     * @example
     * // Create one Weapon
     * const Weapon = await prisma.weapon.create({
     *   data: {
     *     // ... data to create a Weapon
     *   }
     * })
     * 
     */
    create<T extends WeaponCreateArgs>(args: SelectSubset<T, WeaponCreateArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Weapons.
     * @param {WeaponCreateManyArgs} args - Arguments to create many Weapons.
     * @example
     * // Create many Weapons
     * const weapon = await prisma.weapon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeaponCreateManyArgs>(args?: SelectSubset<T, WeaponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Weapons and returns the data saved in the database.
     * @param {WeaponCreateManyAndReturnArgs} args - Arguments to create many Weapons.
     * @example
     * // Create many Weapons
     * const weapon = await prisma.weapon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Weapons and only return the `id`
     * const weaponWithIdOnly = await prisma.weapon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeaponCreateManyAndReturnArgs>(args?: SelectSubset<T, WeaponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Weapon.
     * @param {WeaponDeleteArgs} args - Arguments to delete one Weapon.
     * @example
     * // Delete one Weapon
     * const Weapon = await prisma.weapon.delete({
     *   where: {
     *     // ... filter to delete one Weapon
     *   }
     * })
     * 
     */
    delete<T extends WeaponDeleteArgs>(args: SelectSubset<T, WeaponDeleteArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Weapon.
     * @param {WeaponUpdateArgs} args - Arguments to update one Weapon.
     * @example
     * // Update one Weapon
     * const weapon = await prisma.weapon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeaponUpdateArgs>(args: SelectSubset<T, WeaponUpdateArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Weapons.
     * @param {WeaponDeleteManyArgs} args - Arguments to filter Weapons to delete.
     * @example
     * // Delete a few Weapons
     * const { count } = await prisma.weapon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeaponDeleteManyArgs>(args?: SelectSubset<T, WeaponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weapons
     * const weapon = await prisma.weapon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeaponUpdateManyArgs>(args: SelectSubset<T, WeaponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weapons and returns the data updated in the database.
     * @param {WeaponUpdateManyAndReturnArgs} args - Arguments to update many Weapons.
     * @example
     * // Update many Weapons
     * const weapon = await prisma.weapon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Weapons and only return the `id`
     * const weaponWithIdOnly = await prisma.weapon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeaponUpdateManyAndReturnArgs>(args: SelectSubset<T, WeaponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Weapon.
     * @param {WeaponUpsertArgs} args - Arguments to update or create a Weapon.
     * @example
     * // Update or create a Weapon
     * const weapon = await prisma.weapon.upsert({
     *   create: {
     *     // ... data to create a Weapon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weapon we want to update
     *   }
     * })
     */
    upsert<T extends WeaponUpsertArgs>(args: SelectSubset<T, WeaponUpsertArgs<ExtArgs>>): Prisma__WeaponClient<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Weapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponCountArgs} args - Arguments to filter Weapons to count.
     * @example
     * // Count the number of Weapons
     * const count = await prisma.weapon.count({
     *   where: {
     *     // ... the filter for the Weapons we want to count
     *   }
     * })
    **/
    count<T extends WeaponCountArgs>(
      args?: Subset<T, WeaponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeaponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeaponAggregateArgs>(args: Subset<T, WeaponAggregateArgs>): Prisma.PrismaPromise<GetWeaponAggregateType<T>>

    /**
     * Group by Weapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeaponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeaponGroupByArgs['orderBy'] }
        : { orderBy?: WeaponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeaponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeaponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Weapon model
   */
  readonly fields: WeaponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weapon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeaponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends Weapon$characterArgs<ExtArgs> = {}>(args?: Subset<T, Weapon$characterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    weaponSkill<T extends Weapon$weaponSkillArgs<ExtArgs> = {}>(args?: Subset<T, Weapon$weaponSkillArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    damage<T extends DamageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DamageDefaultArgs<ExtArgs>>): Prisma__DamageClient<$Result.GetResult<Prisma.$DamagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    weight<T extends WeightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WeightDefaultArgs<ExtArgs>>): Prisma__WeightClient<$Result.GetResult<Prisma.$WeightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    range<T extends RangeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RangeDefaultArgs<ExtArgs>>): Prisma__RangeClient<$Result.GetResult<Prisma.$RangePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ammo<T extends Weapon$ammoArgs<ExtArgs> = {}>(args?: Subset<T, Weapon$ammoArgs<ExtArgs>>): Prisma__AmmoClient<$Result.GetResult<Prisma.$AmmoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Weapon model
   */
  interface WeaponFieldRefs {
    readonly id: FieldRef<"Weapon", 'String'>
    readonly name: FieldRef<"Weapon", 'String'>
    readonly melee: FieldRef<"Weapon", 'Boolean'>
    readonly description: FieldRef<"Weapon", 'String'>
    readonly userId: FieldRef<"Weapon", 'String'>
    readonly damageId: FieldRef<"Weapon", 'String'>
    readonly weightId: FieldRef<"Weapon", 'String'>
    readonly rangeId: FieldRef<"Weapon", 'String'>
    readonly ammoId: FieldRef<"Weapon", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Weapon findUnique
   */
  export type WeaponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * Filter, which Weapon to fetch.
     */
    where: WeaponWhereUniqueInput
  }

  /**
   * Weapon findUniqueOrThrow
   */
  export type WeaponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * Filter, which Weapon to fetch.
     */
    where: WeaponWhereUniqueInput
  }

  /**
   * Weapon findFirst
   */
  export type WeaponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * Filter, which Weapon to fetch.
     */
    where?: WeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weapons to fetch.
     */
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weapons.
     */
    cursor?: WeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weapons.
     */
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Weapon findFirstOrThrow
   */
  export type WeaponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * Filter, which Weapon to fetch.
     */
    where?: WeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weapons to fetch.
     */
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weapons.
     */
    cursor?: WeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weapons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weapons.
     */
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Weapon findMany
   */
  export type WeaponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * Filter, which Weapons to fetch.
     */
    where?: WeaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weapons to fetch.
     */
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weapons.
     */
    cursor?: WeaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weapons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weapons.
     */
    skip?: number
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Weapon create
   */
  export type WeaponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * The data needed to create a Weapon.
     */
    data: XOR<WeaponCreateInput, WeaponUncheckedCreateInput>
  }

  /**
   * Weapon createMany
   */
  export type WeaponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Weapons.
     */
    data: WeaponCreateManyInput | WeaponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weapon createManyAndReturn
   */
  export type WeaponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * The data used to create many Weapons.
     */
    data: WeaponCreateManyInput | WeaponCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Weapon update
   */
  export type WeaponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * The data needed to update a Weapon.
     */
    data: XOR<WeaponUpdateInput, WeaponUncheckedUpdateInput>
    /**
     * Choose, which Weapon to update.
     */
    where: WeaponWhereUniqueInput
  }

  /**
   * Weapon updateMany
   */
  export type WeaponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Weapons.
     */
    data: XOR<WeaponUpdateManyMutationInput, WeaponUncheckedUpdateManyInput>
    /**
     * Filter which Weapons to update
     */
    where?: WeaponWhereInput
    /**
     * Limit how many Weapons to update.
     */
    limit?: number
  }

  /**
   * Weapon updateManyAndReturn
   */
  export type WeaponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * The data used to update Weapons.
     */
    data: XOR<WeaponUpdateManyMutationInput, WeaponUncheckedUpdateManyInput>
    /**
     * Filter which Weapons to update
     */
    where?: WeaponWhereInput
    /**
     * Limit how many Weapons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Weapon upsert
   */
  export type WeaponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * The filter to search for the Weapon to update in case it exists.
     */
    where: WeaponWhereUniqueInput
    /**
     * In case the Weapon found by the `where` argument doesn't exist, create a new Weapon with this data.
     */
    create: XOR<WeaponCreateInput, WeaponUncheckedCreateInput>
    /**
     * In case the Weapon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeaponUpdateInput, WeaponUncheckedUpdateInput>
  }

  /**
   * Weapon delete
   */
  export type WeaponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    /**
     * Filter which Weapon to delete.
     */
    where: WeaponWhereUniqueInput
  }

  /**
   * Weapon deleteMany
   */
  export type WeaponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weapons to delete
     */
    where?: WeaponWhereInput
    /**
     * Limit how many Weapons to delete.
     */
    limit?: number
  }

  /**
   * Weapon.character
   */
  export type Weapon$characterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Weapon.weaponSkill
   */
  export type Weapon$weaponSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkill
     */
    select?: WeaponSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponSkill
     */
    omit?: WeaponSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponSkillInclude<ExtArgs> | null
    where?: WeaponSkillWhereInput
    orderBy?: WeaponSkillOrderByWithRelationInput | WeaponSkillOrderByWithRelationInput[]
    cursor?: WeaponSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeaponSkillScalarFieldEnum | WeaponSkillScalarFieldEnum[]
  }

  /**
   * Weapon.ammo
   */
  export type Weapon$ammoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammo
     */
    select?: AmmoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammo
     */
    omit?: AmmoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoInclude<ExtArgs> | null
    where?: AmmoWhereInput
  }

  /**
   * Weapon without action
   */
  export type WeaponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
  }


  /**
   * Model WeaponSkill
   */

  export type AggregateWeaponSkill = {
    _count: WeaponSkillCountAggregateOutputType | null
    _min: WeaponSkillMinAggregateOutputType | null
    _max: WeaponSkillMaxAggregateOutputType | null
  }

  export type WeaponSkillMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type WeaponSkillMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type WeaponSkillCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type WeaponSkillMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type WeaponSkillMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type WeaponSkillCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type WeaponSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeaponSkill to aggregate.
     */
    where?: WeaponSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeaponSkills to fetch.
     */
    orderBy?: WeaponSkillOrderByWithRelationInput | WeaponSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeaponSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeaponSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeaponSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeaponSkills
    **/
    _count?: true | WeaponSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeaponSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeaponSkillMaxAggregateInputType
  }

  export type GetWeaponSkillAggregateType<T extends WeaponSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateWeaponSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeaponSkill[P]>
      : GetScalarType<T[P], AggregateWeaponSkill[P]>
  }




  export type WeaponSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeaponSkillWhereInput
    orderBy?: WeaponSkillOrderByWithAggregationInput | WeaponSkillOrderByWithAggregationInput[]
    by: WeaponSkillScalarFieldEnum[] | WeaponSkillScalarFieldEnum
    having?: WeaponSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeaponSkillCountAggregateInputType | true
    _min?: WeaponSkillMinAggregateInputType
    _max?: WeaponSkillMaxAggregateInputType
  }

  export type WeaponSkillGroupByOutputType = {
    id: string
    name: string
    _count: WeaponSkillCountAggregateOutputType | null
    _min: WeaponSkillMinAggregateOutputType | null
    _max: WeaponSkillMaxAggregateOutputType | null
  }

  type GetWeaponSkillGroupByPayload<T extends WeaponSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeaponSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeaponSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeaponSkillGroupByOutputType[P]>
            : GetScalarType<T[P], WeaponSkillGroupByOutputType[P]>
        }
      >
    >


  export type WeaponSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weapon?: boolean | WeaponSkill$weaponArgs<ExtArgs>
    _count?: boolean | WeaponSkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weaponSkill"]>

  export type WeaponSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["weaponSkill"]>

  export type WeaponSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["weaponSkill"]>

  export type WeaponSkillSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type WeaponSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["weaponSkill"]>
  export type WeaponSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | WeaponSkill$weaponArgs<ExtArgs>
    _count?: boolean | WeaponSkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WeaponSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WeaponSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WeaponSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeaponSkill"
    objects: {
      weapon: Prisma.$WeaponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["weaponSkill"]>
    composites: {}
  }

  type WeaponSkillGetPayload<S extends boolean | null | undefined | WeaponSkillDefaultArgs> = $Result.GetResult<Prisma.$WeaponSkillPayload, S>

  type WeaponSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeaponSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeaponSkillCountAggregateInputType | true
    }

  export interface WeaponSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeaponSkill'], meta: { name: 'WeaponSkill' } }
    /**
     * Find zero or one WeaponSkill that matches the filter.
     * @param {WeaponSkillFindUniqueArgs} args - Arguments to find a WeaponSkill
     * @example
     * // Get one WeaponSkill
     * const weaponSkill = await prisma.weaponSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeaponSkillFindUniqueArgs>(args: SelectSubset<T, WeaponSkillFindUniqueArgs<ExtArgs>>): Prisma__WeaponSkillClient<$Result.GetResult<Prisma.$WeaponSkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WeaponSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeaponSkillFindUniqueOrThrowArgs} args - Arguments to find a WeaponSkill
     * @example
     * // Get one WeaponSkill
     * const weaponSkill = await prisma.weaponSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeaponSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, WeaponSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeaponSkillClient<$Result.GetResult<Prisma.$WeaponSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeaponSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponSkillFindFirstArgs} args - Arguments to find a WeaponSkill
     * @example
     * // Get one WeaponSkill
     * const weaponSkill = await prisma.weaponSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeaponSkillFindFirstArgs>(args?: SelectSubset<T, WeaponSkillFindFirstArgs<ExtArgs>>): Prisma__WeaponSkillClient<$Result.GetResult<Prisma.$WeaponSkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WeaponSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponSkillFindFirstOrThrowArgs} args - Arguments to find a WeaponSkill
     * @example
     * // Get one WeaponSkill
     * const weaponSkill = await prisma.weaponSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeaponSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, WeaponSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeaponSkillClient<$Result.GetResult<Prisma.$WeaponSkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WeaponSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeaponSkills
     * const weaponSkills = await prisma.weaponSkill.findMany()
     * 
     * // Get first 10 WeaponSkills
     * const weaponSkills = await prisma.weaponSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weaponSkillWithIdOnly = await prisma.weaponSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeaponSkillFindManyArgs>(args?: SelectSubset<T, WeaponSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WeaponSkill.
     * @param {WeaponSkillCreateArgs} args - Arguments to create a WeaponSkill.
     * @example
     * // Create one WeaponSkill
     * const WeaponSkill = await prisma.weaponSkill.create({
     *   data: {
     *     // ... data to create a WeaponSkill
     *   }
     * })
     * 
     */
    create<T extends WeaponSkillCreateArgs>(args: SelectSubset<T, WeaponSkillCreateArgs<ExtArgs>>): Prisma__WeaponSkillClient<$Result.GetResult<Prisma.$WeaponSkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WeaponSkills.
     * @param {WeaponSkillCreateManyArgs} args - Arguments to create many WeaponSkills.
     * @example
     * // Create many WeaponSkills
     * const weaponSkill = await prisma.weaponSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeaponSkillCreateManyArgs>(args?: SelectSubset<T, WeaponSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WeaponSkills and returns the data saved in the database.
     * @param {WeaponSkillCreateManyAndReturnArgs} args - Arguments to create many WeaponSkills.
     * @example
     * // Create many WeaponSkills
     * const weaponSkill = await prisma.weaponSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WeaponSkills and only return the `id`
     * const weaponSkillWithIdOnly = await prisma.weaponSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeaponSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, WeaponSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponSkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WeaponSkill.
     * @param {WeaponSkillDeleteArgs} args - Arguments to delete one WeaponSkill.
     * @example
     * // Delete one WeaponSkill
     * const WeaponSkill = await prisma.weaponSkill.delete({
     *   where: {
     *     // ... filter to delete one WeaponSkill
     *   }
     * })
     * 
     */
    delete<T extends WeaponSkillDeleteArgs>(args: SelectSubset<T, WeaponSkillDeleteArgs<ExtArgs>>): Prisma__WeaponSkillClient<$Result.GetResult<Prisma.$WeaponSkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WeaponSkill.
     * @param {WeaponSkillUpdateArgs} args - Arguments to update one WeaponSkill.
     * @example
     * // Update one WeaponSkill
     * const weaponSkill = await prisma.weaponSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeaponSkillUpdateArgs>(args: SelectSubset<T, WeaponSkillUpdateArgs<ExtArgs>>): Prisma__WeaponSkillClient<$Result.GetResult<Prisma.$WeaponSkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WeaponSkills.
     * @param {WeaponSkillDeleteManyArgs} args - Arguments to filter WeaponSkills to delete.
     * @example
     * // Delete a few WeaponSkills
     * const { count } = await prisma.weaponSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeaponSkillDeleteManyArgs>(args?: SelectSubset<T, WeaponSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeaponSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeaponSkills
     * const weaponSkill = await prisma.weaponSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeaponSkillUpdateManyArgs>(args: SelectSubset<T, WeaponSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeaponSkills and returns the data updated in the database.
     * @param {WeaponSkillUpdateManyAndReturnArgs} args - Arguments to update many WeaponSkills.
     * @example
     * // Update many WeaponSkills
     * const weaponSkill = await prisma.weaponSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WeaponSkills and only return the `id`
     * const weaponSkillWithIdOnly = await prisma.weaponSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeaponSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, WeaponSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponSkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WeaponSkill.
     * @param {WeaponSkillUpsertArgs} args - Arguments to update or create a WeaponSkill.
     * @example
     * // Update or create a WeaponSkill
     * const weaponSkill = await prisma.weaponSkill.upsert({
     *   create: {
     *     // ... data to create a WeaponSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeaponSkill we want to update
     *   }
     * })
     */
    upsert<T extends WeaponSkillUpsertArgs>(args: SelectSubset<T, WeaponSkillUpsertArgs<ExtArgs>>): Prisma__WeaponSkillClient<$Result.GetResult<Prisma.$WeaponSkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WeaponSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponSkillCountArgs} args - Arguments to filter WeaponSkills to count.
     * @example
     * // Count the number of WeaponSkills
     * const count = await prisma.weaponSkill.count({
     *   where: {
     *     // ... the filter for the WeaponSkills we want to count
     *   }
     * })
    **/
    count<T extends WeaponSkillCountArgs>(
      args?: Subset<T, WeaponSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeaponSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeaponSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeaponSkillAggregateArgs>(args: Subset<T, WeaponSkillAggregateArgs>): Prisma.PrismaPromise<GetWeaponSkillAggregateType<T>>

    /**
     * Group by WeaponSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeaponSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeaponSkillGroupByArgs['orderBy'] }
        : { orderBy?: WeaponSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeaponSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeaponSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeaponSkill model
   */
  readonly fields: WeaponSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeaponSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeaponSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    weapon<T extends WeaponSkill$weaponArgs<ExtArgs> = {}>(args?: Subset<T, WeaponSkill$weaponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeaponSkill model
   */
  interface WeaponSkillFieldRefs {
    readonly id: FieldRef<"WeaponSkill", 'String'>
    readonly name: FieldRef<"WeaponSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WeaponSkill findUnique
   */
  export type WeaponSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkill
     */
    select?: WeaponSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponSkill
     */
    omit?: WeaponSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponSkillInclude<ExtArgs> | null
    /**
     * Filter, which WeaponSkill to fetch.
     */
    where: WeaponSkillWhereUniqueInput
  }

  /**
   * WeaponSkill findUniqueOrThrow
   */
  export type WeaponSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkill
     */
    select?: WeaponSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponSkill
     */
    omit?: WeaponSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponSkillInclude<ExtArgs> | null
    /**
     * Filter, which WeaponSkill to fetch.
     */
    where: WeaponSkillWhereUniqueInput
  }

  /**
   * WeaponSkill findFirst
   */
  export type WeaponSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkill
     */
    select?: WeaponSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponSkill
     */
    omit?: WeaponSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponSkillInclude<ExtArgs> | null
    /**
     * Filter, which WeaponSkill to fetch.
     */
    where?: WeaponSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeaponSkills to fetch.
     */
    orderBy?: WeaponSkillOrderByWithRelationInput | WeaponSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeaponSkills.
     */
    cursor?: WeaponSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeaponSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeaponSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeaponSkills.
     */
    distinct?: WeaponSkillScalarFieldEnum | WeaponSkillScalarFieldEnum[]
  }

  /**
   * WeaponSkill findFirstOrThrow
   */
  export type WeaponSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkill
     */
    select?: WeaponSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponSkill
     */
    omit?: WeaponSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponSkillInclude<ExtArgs> | null
    /**
     * Filter, which WeaponSkill to fetch.
     */
    where?: WeaponSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeaponSkills to fetch.
     */
    orderBy?: WeaponSkillOrderByWithRelationInput | WeaponSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeaponSkills.
     */
    cursor?: WeaponSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeaponSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeaponSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeaponSkills.
     */
    distinct?: WeaponSkillScalarFieldEnum | WeaponSkillScalarFieldEnum[]
  }

  /**
   * WeaponSkill findMany
   */
  export type WeaponSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkill
     */
    select?: WeaponSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponSkill
     */
    omit?: WeaponSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponSkillInclude<ExtArgs> | null
    /**
     * Filter, which WeaponSkills to fetch.
     */
    where?: WeaponSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeaponSkills to fetch.
     */
    orderBy?: WeaponSkillOrderByWithRelationInput | WeaponSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeaponSkills.
     */
    cursor?: WeaponSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeaponSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeaponSkills.
     */
    skip?: number
    distinct?: WeaponSkillScalarFieldEnum | WeaponSkillScalarFieldEnum[]
  }

  /**
   * WeaponSkill create
   */
  export type WeaponSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkill
     */
    select?: WeaponSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponSkill
     */
    omit?: WeaponSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a WeaponSkill.
     */
    data: XOR<WeaponSkillCreateInput, WeaponSkillUncheckedCreateInput>
  }

  /**
   * WeaponSkill createMany
   */
  export type WeaponSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeaponSkills.
     */
    data: WeaponSkillCreateManyInput | WeaponSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeaponSkill createManyAndReturn
   */
  export type WeaponSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkill
     */
    select?: WeaponSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponSkill
     */
    omit?: WeaponSkillOmit<ExtArgs> | null
    /**
     * The data used to create many WeaponSkills.
     */
    data: WeaponSkillCreateManyInput | WeaponSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeaponSkill update
   */
  export type WeaponSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkill
     */
    select?: WeaponSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponSkill
     */
    omit?: WeaponSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a WeaponSkill.
     */
    data: XOR<WeaponSkillUpdateInput, WeaponSkillUncheckedUpdateInput>
    /**
     * Choose, which WeaponSkill to update.
     */
    where: WeaponSkillWhereUniqueInput
  }

  /**
   * WeaponSkill updateMany
   */
  export type WeaponSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeaponSkills.
     */
    data: XOR<WeaponSkillUpdateManyMutationInput, WeaponSkillUncheckedUpdateManyInput>
    /**
     * Filter which WeaponSkills to update
     */
    where?: WeaponSkillWhereInput
    /**
     * Limit how many WeaponSkills to update.
     */
    limit?: number
  }

  /**
   * WeaponSkill updateManyAndReturn
   */
  export type WeaponSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkill
     */
    select?: WeaponSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponSkill
     */
    omit?: WeaponSkillOmit<ExtArgs> | null
    /**
     * The data used to update WeaponSkills.
     */
    data: XOR<WeaponSkillUpdateManyMutationInput, WeaponSkillUncheckedUpdateManyInput>
    /**
     * Filter which WeaponSkills to update
     */
    where?: WeaponSkillWhereInput
    /**
     * Limit how many WeaponSkills to update.
     */
    limit?: number
  }

  /**
   * WeaponSkill upsert
   */
  export type WeaponSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkill
     */
    select?: WeaponSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponSkill
     */
    omit?: WeaponSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the WeaponSkill to update in case it exists.
     */
    where: WeaponSkillWhereUniqueInput
    /**
     * In case the WeaponSkill found by the `where` argument doesn't exist, create a new WeaponSkill with this data.
     */
    create: XOR<WeaponSkillCreateInput, WeaponSkillUncheckedCreateInput>
    /**
     * In case the WeaponSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeaponSkillUpdateInput, WeaponSkillUncheckedUpdateInput>
  }

  /**
   * WeaponSkill delete
   */
  export type WeaponSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkill
     */
    select?: WeaponSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponSkill
     */
    omit?: WeaponSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponSkillInclude<ExtArgs> | null
    /**
     * Filter which WeaponSkill to delete.
     */
    where: WeaponSkillWhereUniqueInput
  }

  /**
   * WeaponSkill deleteMany
   */
  export type WeaponSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeaponSkills to delete
     */
    where?: WeaponSkillWhereInput
    /**
     * Limit how many WeaponSkills to delete.
     */
    limit?: number
  }

  /**
   * WeaponSkill.weapon
   */
  export type WeaponSkill$weaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    where?: WeaponWhereInput
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    cursor?: WeaponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * WeaponSkill without action
   */
  export type WeaponSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeaponSkill
     */
    select?: WeaponSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WeaponSkill
     */
    omit?: WeaponSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponSkillInclude<ExtArgs> | null
  }


  /**
   * Model Damage
   */

  export type AggregateDamage = {
    _count: DamageCountAggregateOutputType | null
    _min: DamageMinAggregateOutputType | null
    _max: DamageMaxAggregateOutputType | null
  }

  export type DamageMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type DamageMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type DamageCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DamageMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DamageMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DamageCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DamageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Damage to aggregate.
     */
    where?: DamageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Damages to fetch.
     */
    orderBy?: DamageOrderByWithRelationInput | DamageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DamageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Damages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Damages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Damages
    **/
    _count?: true | DamageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DamageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DamageMaxAggregateInputType
  }

  export type GetDamageAggregateType<T extends DamageAggregateArgs> = {
        [P in keyof T & keyof AggregateDamage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDamage[P]>
      : GetScalarType<T[P], AggregateDamage[P]>
  }




  export type DamageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DamageWhereInput
    orderBy?: DamageOrderByWithAggregationInput | DamageOrderByWithAggregationInput[]
    by: DamageScalarFieldEnum[] | DamageScalarFieldEnum
    having?: DamageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DamageCountAggregateInputType | true
    _min?: DamageMinAggregateInputType
    _max?: DamageMaxAggregateInputType
  }

  export type DamageGroupByOutputType = {
    id: string
    name: string
    _count: DamageCountAggregateOutputType | null
    _min: DamageMinAggregateOutputType | null
    _max: DamageMaxAggregateOutputType | null
  }

  type GetDamageGroupByPayload<T extends DamageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DamageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DamageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DamageGroupByOutputType[P]>
            : GetScalarType<T[P], DamageGroupByOutputType[P]>
        }
      >
    >


  export type DamageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weapon?: boolean | Damage$weaponArgs<ExtArgs>
    _count?: boolean | DamageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["damage"]>

  export type DamageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["damage"]>

  export type DamageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["damage"]>

  export type DamageSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DamageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["damage"]>
  export type DamageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | Damage$weaponArgs<ExtArgs>
    _count?: boolean | DamageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DamageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DamageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DamagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Damage"
    objects: {
      weapon: Prisma.$WeaponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["damage"]>
    composites: {}
  }

  type DamageGetPayload<S extends boolean | null | undefined | DamageDefaultArgs> = $Result.GetResult<Prisma.$DamagePayload, S>

  type DamageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DamageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DamageCountAggregateInputType | true
    }

  export interface DamageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Damage'], meta: { name: 'Damage' } }
    /**
     * Find zero or one Damage that matches the filter.
     * @param {DamageFindUniqueArgs} args - Arguments to find a Damage
     * @example
     * // Get one Damage
     * const damage = await prisma.damage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DamageFindUniqueArgs>(args: SelectSubset<T, DamageFindUniqueArgs<ExtArgs>>): Prisma__DamageClient<$Result.GetResult<Prisma.$DamagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Damage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DamageFindUniqueOrThrowArgs} args - Arguments to find a Damage
     * @example
     * // Get one Damage
     * const damage = await prisma.damage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DamageFindUniqueOrThrowArgs>(args: SelectSubset<T, DamageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DamageClient<$Result.GetResult<Prisma.$DamagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Damage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageFindFirstArgs} args - Arguments to find a Damage
     * @example
     * // Get one Damage
     * const damage = await prisma.damage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DamageFindFirstArgs>(args?: SelectSubset<T, DamageFindFirstArgs<ExtArgs>>): Prisma__DamageClient<$Result.GetResult<Prisma.$DamagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Damage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageFindFirstOrThrowArgs} args - Arguments to find a Damage
     * @example
     * // Get one Damage
     * const damage = await prisma.damage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DamageFindFirstOrThrowArgs>(args?: SelectSubset<T, DamageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DamageClient<$Result.GetResult<Prisma.$DamagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Damages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Damages
     * const damages = await prisma.damage.findMany()
     * 
     * // Get first 10 Damages
     * const damages = await prisma.damage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const damageWithIdOnly = await prisma.damage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DamageFindManyArgs>(args?: SelectSubset<T, DamageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Damage.
     * @param {DamageCreateArgs} args - Arguments to create a Damage.
     * @example
     * // Create one Damage
     * const Damage = await prisma.damage.create({
     *   data: {
     *     // ... data to create a Damage
     *   }
     * })
     * 
     */
    create<T extends DamageCreateArgs>(args: SelectSubset<T, DamageCreateArgs<ExtArgs>>): Prisma__DamageClient<$Result.GetResult<Prisma.$DamagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Damages.
     * @param {DamageCreateManyArgs} args - Arguments to create many Damages.
     * @example
     * // Create many Damages
     * const damage = await prisma.damage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DamageCreateManyArgs>(args?: SelectSubset<T, DamageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Damages and returns the data saved in the database.
     * @param {DamageCreateManyAndReturnArgs} args - Arguments to create many Damages.
     * @example
     * // Create many Damages
     * const damage = await prisma.damage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Damages and only return the `id`
     * const damageWithIdOnly = await prisma.damage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DamageCreateManyAndReturnArgs>(args?: SelectSubset<T, DamageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Damage.
     * @param {DamageDeleteArgs} args - Arguments to delete one Damage.
     * @example
     * // Delete one Damage
     * const Damage = await prisma.damage.delete({
     *   where: {
     *     // ... filter to delete one Damage
     *   }
     * })
     * 
     */
    delete<T extends DamageDeleteArgs>(args: SelectSubset<T, DamageDeleteArgs<ExtArgs>>): Prisma__DamageClient<$Result.GetResult<Prisma.$DamagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Damage.
     * @param {DamageUpdateArgs} args - Arguments to update one Damage.
     * @example
     * // Update one Damage
     * const damage = await prisma.damage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DamageUpdateArgs>(args: SelectSubset<T, DamageUpdateArgs<ExtArgs>>): Prisma__DamageClient<$Result.GetResult<Prisma.$DamagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Damages.
     * @param {DamageDeleteManyArgs} args - Arguments to filter Damages to delete.
     * @example
     * // Delete a few Damages
     * const { count } = await prisma.damage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DamageDeleteManyArgs>(args?: SelectSubset<T, DamageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Damages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Damages
     * const damage = await prisma.damage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DamageUpdateManyArgs>(args: SelectSubset<T, DamageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Damages and returns the data updated in the database.
     * @param {DamageUpdateManyAndReturnArgs} args - Arguments to update many Damages.
     * @example
     * // Update many Damages
     * const damage = await prisma.damage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Damages and only return the `id`
     * const damageWithIdOnly = await prisma.damage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DamageUpdateManyAndReturnArgs>(args: SelectSubset<T, DamageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Damage.
     * @param {DamageUpsertArgs} args - Arguments to update or create a Damage.
     * @example
     * // Update or create a Damage
     * const damage = await prisma.damage.upsert({
     *   create: {
     *     // ... data to create a Damage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Damage we want to update
     *   }
     * })
     */
    upsert<T extends DamageUpsertArgs>(args: SelectSubset<T, DamageUpsertArgs<ExtArgs>>): Prisma__DamageClient<$Result.GetResult<Prisma.$DamagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Damages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageCountArgs} args - Arguments to filter Damages to count.
     * @example
     * // Count the number of Damages
     * const count = await prisma.damage.count({
     *   where: {
     *     // ... the filter for the Damages we want to count
     *   }
     * })
    **/
    count<T extends DamageCountArgs>(
      args?: Subset<T, DamageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DamageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Damage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DamageAggregateArgs>(args: Subset<T, DamageAggregateArgs>): Prisma.PrismaPromise<GetDamageAggregateType<T>>

    /**
     * Group by Damage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DamageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DamageGroupByArgs['orderBy'] }
        : { orderBy?: DamageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DamageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDamageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Damage model
   */
  readonly fields: DamageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Damage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DamageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    weapon<T extends Damage$weaponArgs<ExtArgs> = {}>(args?: Subset<T, Damage$weaponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Damage model
   */
  interface DamageFieldRefs {
    readonly id: FieldRef<"Damage", 'String'>
    readonly name: FieldRef<"Damage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Damage findUnique
   */
  export type DamageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Damage
     */
    select?: DamageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Damage
     */
    omit?: DamageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageInclude<ExtArgs> | null
    /**
     * Filter, which Damage to fetch.
     */
    where: DamageWhereUniqueInput
  }

  /**
   * Damage findUniqueOrThrow
   */
  export type DamageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Damage
     */
    select?: DamageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Damage
     */
    omit?: DamageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageInclude<ExtArgs> | null
    /**
     * Filter, which Damage to fetch.
     */
    where: DamageWhereUniqueInput
  }

  /**
   * Damage findFirst
   */
  export type DamageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Damage
     */
    select?: DamageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Damage
     */
    omit?: DamageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageInclude<ExtArgs> | null
    /**
     * Filter, which Damage to fetch.
     */
    where?: DamageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Damages to fetch.
     */
    orderBy?: DamageOrderByWithRelationInput | DamageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Damages.
     */
    cursor?: DamageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Damages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Damages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Damages.
     */
    distinct?: DamageScalarFieldEnum | DamageScalarFieldEnum[]
  }

  /**
   * Damage findFirstOrThrow
   */
  export type DamageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Damage
     */
    select?: DamageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Damage
     */
    omit?: DamageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageInclude<ExtArgs> | null
    /**
     * Filter, which Damage to fetch.
     */
    where?: DamageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Damages to fetch.
     */
    orderBy?: DamageOrderByWithRelationInput | DamageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Damages.
     */
    cursor?: DamageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Damages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Damages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Damages.
     */
    distinct?: DamageScalarFieldEnum | DamageScalarFieldEnum[]
  }

  /**
   * Damage findMany
   */
  export type DamageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Damage
     */
    select?: DamageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Damage
     */
    omit?: DamageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageInclude<ExtArgs> | null
    /**
     * Filter, which Damages to fetch.
     */
    where?: DamageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Damages to fetch.
     */
    orderBy?: DamageOrderByWithRelationInput | DamageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Damages.
     */
    cursor?: DamageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Damages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Damages.
     */
    skip?: number
    distinct?: DamageScalarFieldEnum | DamageScalarFieldEnum[]
  }

  /**
   * Damage create
   */
  export type DamageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Damage
     */
    select?: DamageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Damage
     */
    omit?: DamageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageInclude<ExtArgs> | null
    /**
     * The data needed to create a Damage.
     */
    data: XOR<DamageCreateInput, DamageUncheckedCreateInput>
  }

  /**
   * Damage createMany
   */
  export type DamageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Damages.
     */
    data: DamageCreateManyInput | DamageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Damage createManyAndReturn
   */
  export type DamageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Damage
     */
    select?: DamageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Damage
     */
    omit?: DamageOmit<ExtArgs> | null
    /**
     * The data used to create many Damages.
     */
    data: DamageCreateManyInput | DamageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Damage update
   */
  export type DamageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Damage
     */
    select?: DamageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Damage
     */
    omit?: DamageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageInclude<ExtArgs> | null
    /**
     * The data needed to update a Damage.
     */
    data: XOR<DamageUpdateInput, DamageUncheckedUpdateInput>
    /**
     * Choose, which Damage to update.
     */
    where: DamageWhereUniqueInput
  }

  /**
   * Damage updateMany
   */
  export type DamageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Damages.
     */
    data: XOR<DamageUpdateManyMutationInput, DamageUncheckedUpdateManyInput>
    /**
     * Filter which Damages to update
     */
    where?: DamageWhereInput
    /**
     * Limit how many Damages to update.
     */
    limit?: number
  }

  /**
   * Damage updateManyAndReturn
   */
  export type DamageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Damage
     */
    select?: DamageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Damage
     */
    omit?: DamageOmit<ExtArgs> | null
    /**
     * The data used to update Damages.
     */
    data: XOR<DamageUpdateManyMutationInput, DamageUncheckedUpdateManyInput>
    /**
     * Filter which Damages to update
     */
    where?: DamageWhereInput
    /**
     * Limit how many Damages to update.
     */
    limit?: number
  }

  /**
   * Damage upsert
   */
  export type DamageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Damage
     */
    select?: DamageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Damage
     */
    omit?: DamageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageInclude<ExtArgs> | null
    /**
     * The filter to search for the Damage to update in case it exists.
     */
    where: DamageWhereUniqueInput
    /**
     * In case the Damage found by the `where` argument doesn't exist, create a new Damage with this data.
     */
    create: XOR<DamageCreateInput, DamageUncheckedCreateInput>
    /**
     * In case the Damage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DamageUpdateInput, DamageUncheckedUpdateInput>
  }

  /**
   * Damage delete
   */
  export type DamageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Damage
     */
    select?: DamageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Damage
     */
    omit?: DamageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageInclude<ExtArgs> | null
    /**
     * Filter which Damage to delete.
     */
    where: DamageWhereUniqueInput
  }

  /**
   * Damage deleteMany
   */
  export type DamageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Damages to delete
     */
    where?: DamageWhereInput
    /**
     * Limit how many Damages to delete.
     */
    limit?: number
  }

  /**
   * Damage.weapon
   */
  export type Damage$weaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    where?: WeaponWhereInput
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    cursor?: WeaponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Damage without action
   */
  export type DamageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Damage
     */
    select?: DamageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Damage
     */
    omit?: DamageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageInclude<ExtArgs> | null
  }


  /**
   * Model Weight
   */

  export type AggregateWeight = {
    _count: WeightCountAggregateOutputType | null
    _min: WeightMinAggregateOutputType | null
    _max: WeightMaxAggregateOutputType | null
  }

  export type WeightMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type WeightMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type WeightCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type WeightMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type WeightMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type WeightCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type WeightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weight to aggregate.
     */
    where?: WeightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weights to fetch.
     */
    orderBy?: WeightOrderByWithRelationInput | WeightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Weights
    **/
    _count?: true | WeightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeightMaxAggregateInputType
  }

  export type GetWeightAggregateType<T extends WeightAggregateArgs> = {
        [P in keyof T & keyof AggregateWeight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeight[P]>
      : GetScalarType<T[P], AggregateWeight[P]>
  }




  export type WeightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeightWhereInput
    orderBy?: WeightOrderByWithAggregationInput | WeightOrderByWithAggregationInput[]
    by: WeightScalarFieldEnum[] | WeightScalarFieldEnum
    having?: WeightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeightCountAggregateInputType | true
    _min?: WeightMinAggregateInputType
    _max?: WeightMaxAggregateInputType
  }

  export type WeightGroupByOutputType = {
    id: string
    name: string
    _count: WeightCountAggregateOutputType | null
    _min: WeightMinAggregateOutputType | null
    _max: WeightMaxAggregateOutputType | null
  }

  type GetWeightGroupByPayload<T extends WeightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeightGroupByOutputType[P]>
            : GetScalarType<T[P], WeightGroupByOutputType[P]>
        }
      >
    >


  export type WeightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weapon?: boolean | Weight$weaponArgs<ExtArgs>
    _count?: boolean | WeightCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weight"]>

  export type WeightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["weight"]>

  export type WeightSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["weight"]>

  export type WeightSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type WeightOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["weight"]>
  export type WeightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | Weight$weaponArgs<ExtArgs>
    _count?: boolean | WeightCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WeightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WeightIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WeightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Weight"
    objects: {
      weapon: Prisma.$WeaponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["weight"]>
    composites: {}
  }

  type WeightGetPayload<S extends boolean | null | undefined | WeightDefaultArgs> = $Result.GetResult<Prisma.$WeightPayload, S>

  type WeightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WeightFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WeightCountAggregateInputType | true
    }

  export interface WeightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Weight'], meta: { name: 'Weight' } }
    /**
     * Find zero or one Weight that matches the filter.
     * @param {WeightFindUniqueArgs} args - Arguments to find a Weight
     * @example
     * // Get one Weight
     * const weight = await prisma.weight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeightFindUniqueArgs>(args: SelectSubset<T, WeightFindUniqueArgs<ExtArgs>>): Prisma__WeightClient<$Result.GetResult<Prisma.$WeightPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Weight that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WeightFindUniqueOrThrowArgs} args - Arguments to find a Weight
     * @example
     * // Get one Weight
     * const weight = await prisma.weight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeightFindUniqueOrThrowArgs>(args: SelectSubset<T, WeightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeightClient<$Result.GetResult<Prisma.$WeightPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightFindFirstArgs} args - Arguments to find a Weight
     * @example
     * // Get one Weight
     * const weight = await prisma.weight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeightFindFirstArgs>(args?: SelectSubset<T, WeightFindFirstArgs<ExtArgs>>): Prisma__WeightClient<$Result.GetResult<Prisma.$WeightPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Weight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightFindFirstOrThrowArgs} args - Arguments to find a Weight
     * @example
     * // Get one Weight
     * const weight = await prisma.weight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeightFindFirstOrThrowArgs>(args?: SelectSubset<T, WeightFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeightClient<$Result.GetResult<Prisma.$WeightPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Weights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weights
     * const weights = await prisma.weight.findMany()
     * 
     * // Get first 10 Weights
     * const weights = await prisma.weight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weightWithIdOnly = await prisma.weight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeightFindManyArgs>(args?: SelectSubset<T, WeightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeightPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Weight.
     * @param {WeightCreateArgs} args - Arguments to create a Weight.
     * @example
     * // Create one Weight
     * const Weight = await prisma.weight.create({
     *   data: {
     *     // ... data to create a Weight
     *   }
     * })
     * 
     */
    create<T extends WeightCreateArgs>(args: SelectSubset<T, WeightCreateArgs<ExtArgs>>): Prisma__WeightClient<$Result.GetResult<Prisma.$WeightPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Weights.
     * @param {WeightCreateManyArgs} args - Arguments to create many Weights.
     * @example
     * // Create many Weights
     * const weight = await prisma.weight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeightCreateManyArgs>(args?: SelectSubset<T, WeightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Weights and returns the data saved in the database.
     * @param {WeightCreateManyAndReturnArgs} args - Arguments to create many Weights.
     * @example
     * // Create many Weights
     * const weight = await prisma.weight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Weights and only return the `id`
     * const weightWithIdOnly = await prisma.weight.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WeightCreateManyAndReturnArgs>(args?: SelectSubset<T, WeightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeightPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Weight.
     * @param {WeightDeleteArgs} args - Arguments to delete one Weight.
     * @example
     * // Delete one Weight
     * const Weight = await prisma.weight.delete({
     *   where: {
     *     // ... filter to delete one Weight
     *   }
     * })
     * 
     */
    delete<T extends WeightDeleteArgs>(args: SelectSubset<T, WeightDeleteArgs<ExtArgs>>): Prisma__WeightClient<$Result.GetResult<Prisma.$WeightPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Weight.
     * @param {WeightUpdateArgs} args - Arguments to update one Weight.
     * @example
     * // Update one Weight
     * const weight = await prisma.weight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeightUpdateArgs>(args: SelectSubset<T, WeightUpdateArgs<ExtArgs>>): Prisma__WeightClient<$Result.GetResult<Prisma.$WeightPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Weights.
     * @param {WeightDeleteManyArgs} args - Arguments to filter Weights to delete.
     * @example
     * // Delete a few Weights
     * const { count } = await prisma.weight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeightDeleteManyArgs>(args?: SelectSubset<T, WeightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weights
     * const weight = await prisma.weight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeightUpdateManyArgs>(args: SelectSubset<T, WeightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weights and returns the data updated in the database.
     * @param {WeightUpdateManyAndReturnArgs} args - Arguments to update many Weights.
     * @example
     * // Update many Weights
     * const weight = await prisma.weight.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Weights and only return the `id`
     * const weightWithIdOnly = await prisma.weight.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WeightUpdateManyAndReturnArgs>(args: SelectSubset<T, WeightUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeightPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Weight.
     * @param {WeightUpsertArgs} args - Arguments to update or create a Weight.
     * @example
     * // Update or create a Weight
     * const weight = await prisma.weight.upsert({
     *   create: {
     *     // ... data to create a Weight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weight we want to update
     *   }
     * })
     */
    upsert<T extends WeightUpsertArgs>(args: SelectSubset<T, WeightUpsertArgs<ExtArgs>>): Prisma__WeightClient<$Result.GetResult<Prisma.$WeightPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Weights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightCountArgs} args - Arguments to filter Weights to count.
     * @example
     * // Count the number of Weights
     * const count = await prisma.weight.count({
     *   where: {
     *     // ... the filter for the Weights we want to count
     *   }
     * })
    **/
    count<T extends WeightCountArgs>(
      args?: Subset<T, WeightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeightAggregateArgs>(args: Subset<T, WeightAggregateArgs>): Prisma.PrismaPromise<GetWeightAggregateType<T>>

    /**
     * Group by Weight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeightGroupByArgs['orderBy'] }
        : { orderBy?: WeightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Weight model
   */
  readonly fields: WeightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Weight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    weapon<T extends Weight$weaponArgs<ExtArgs> = {}>(args?: Subset<T, Weight$weaponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Weight model
   */
  interface WeightFieldRefs {
    readonly id: FieldRef<"Weight", 'String'>
    readonly name: FieldRef<"Weight", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Weight findUnique
   */
  export type WeightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weight
     */
    select?: WeightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weight
     */
    omit?: WeightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightInclude<ExtArgs> | null
    /**
     * Filter, which Weight to fetch.
     */
    where: WeightWhereUniqueInput
  }

  /**
   * Weight findUniqueOrThrow
   */
  export type WeightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weight
     */
    select?: WeightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weight
     */
    omit?: WeightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightInclude<ExtArgs> | null
    /**
     * Filter, which Weight to fetch.
     */
    where: WeightWhereUniqueInput
  }

  /**
   * Weight findFirst
   */
  export type WeightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weight
     */
    select?: WeightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weight
     */
    omit?: WeightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightInclude<ExtArgs> | null
    /**
     * Filter, which Weight to fetch.
     */
    where?: WeightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weights to fetch.
     */
    orderBy?: WeightOrderByWithRelationInput | WeightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weights.
     */
    cursor?: WeightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weights.
     */
    distinct?: WeightScalarFieldEnum | WeightScalarFieldEnum[]
  }

  /**
   * Weight findFirstOrThrow
   */
  export type WeightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weight
     */
    select?: WeightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weight
     */
    omit?: WeightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightInclude<ExtArgs> | null
    /**
     * Filter, which Weight to fetch.
     */
    where?: WeightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weights to fetch.
     */
    orderBy?: WeightOrderByWithRelationInput | WeightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Weights.
     */
    cursor?: WeightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Weights.
     */
    distinct?: WeightScalarFieldEnum | WeightScalarFieldEnum[]
  }

  /**
   * Weight findMany
   */
  export type WeightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weight
     */
    select?: WeightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weight
     */
    omit?: WeightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightInclude<ExtArgs> | null
    /**
     * Filter, which Weights to fetch.
     */
    where?: WeightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Weights to fetch.
     */
    orderBy?: WeightOrderByWithRelationInput | WeightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Weights.
     */
    cursor?: WeightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Weights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Weights.
     */
    skip?: number
    distinct?: WeightScalarFieldEnum | WeightScalarFieldEnum[]
  }

  /**
   * Weight create
   */
  export type WeightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weight
     */
    select?: WeightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weight
     */
    omit?: WeightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightInclude<ExtArgs> | null
    /**
     * The data needed to create a Weight.
     */
    data: XOR<WeightCreateInput, WeightUncheckedCreateInput>
  }

  /**
   * Weight createMany
   */
  export type WeightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Weights.
     */
    data: WeightCreateManyInput | WeightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weight createManyAndReturn
   */
  export type WeightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weight
     */
    select?: WeightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weight
     */
    omit?: WeightOmit<ExtArgs> | null
    /**
     * The data used to create many Weights.
     */
    data: WeightCreateManyInput | WeightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Weight update
   */
  export type WeightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weight
     */
    select?: WeightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weight
     */
    omit?: WeightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightInclude<ExtArgs> | null
    /**
     * The data needed to update a Weight.
     */
    data: XOR<WeightUpdateInput, WeightUncheckedUpdateInput>
    /**
     * Choose, which Weight to update.
     */
    where: WeightWhereUniqueInput
  }

  /**
   * Weight updateMany
   */
  export type WeightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Weights.
     */
    data: XOR<WeightUpdateManyMutationInput, WeightUncheckedUpdateManyInput>
    /**
     * Filter which Weights to update
     */
    where?: WeightWhereInput
    /**
     * Limit how many Weights to update.
     */
    limit?: number
  }

  /**
   * Weight updateManyAndReturn
   */
  export type WeightUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weight
     */
    select?: WeightSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Weight
     */
    omit?: WeightOmit<ExtArgs> | null
    /**
     * The data used to update Weights.
     */
    data: XOR<WeightUpdateManyMutationInput, WeightUncheckedUpdateManyInput>
    /**
     * Filter which Weights to update
     */
    where?: WeightWhereInput
    /**
     * Limit how many Weights to update.
     */
    limit?: number
  }

  /**
   * Weight upsert
   */
  export type WeightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weight
     */
    select?: WeightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weight
     */
    omit?: WeightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightInclude<ExtArgs> | null
    /**
     * The filter to search for the Weight to update in case it exists.
     */
    where: WeightWhereUniqueInput
    /**
     * In case the Weight found by the `where` argument doesn't exist, create a new Weight with this data.
     */
    create: XOR<WeightCreateInput, WeightUncheckedCreateInput>
    /**
     * In case the Weight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeightUpdateInput, WeightUncheckedUpdateInput>
  }

  /**
   * Weight delete
   */
  export type WeightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weight
     */
    select?: WeightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weight
     */
    omit?: WeightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightInclude<ExtArgs> | null
    /**
     * Filter which Weight to delete.
     */
    where: WeightWhereUniqueInput
  }

  /**
   * Weight deleteMany
   */
  export type WeightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Weights to delete
     */
    where?: WeightWhereInput
    /**
     * Limit how many Weights to delete.
     */
    limit?: number
  }

  /**
   * Weight.weapon
   */
  export type Weight$weaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    where?: WeaponWhereInput
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    cursor?: WeaponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Weight without action
   */
  export type WeightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weight
     */
    select?: WeightSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weight
     */
    omit?: WeightOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeightInclude<ExtArgs> | null
  }


  /**
   * Model Ammo
   */

  export type AggregateAmmo = {
    _count: AmmoCountAggregateOutputType | null
    _min: AmmoMinAggregateOutputType | null
    _max: AmmoMaxAggregateOutputType | null
  }

  export type AmmoMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type AmmoMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type AmmoCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type AmmoMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type AmmoMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type AmmoCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type AmmoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ammo to aggregate.
     */
    where?: AmmoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ammo to fetch.
     */
    orderBy?: AmmoOrderByWithRelationInput | AmmoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmmoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ammo from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ammo.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ammo
    **/
    _count?: true | AmmoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmmoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmmoMaxAggregateInputType
  }

  export type GetAmmoAggregateType<T extends AmmoAggregateArgs> = {
        [P in keyof T & keyof AggregateAmmo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmmo[P]>
      : GetScalarType<T[P], AggregateAmmo[P]>
  }




  export type AmmoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmmoWhereInput
    orderBy?: AmmoOrderByWithAggregationInput | AmmoOrderByWithAggregationInput[]
    by: AmmoScalarFieldEnum[] | AmmoScalarFieldEnum
    having?: AmmoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmmoCountAggregateInputType | true
    _min?: AmmoMinAggregateInputType
    _max?: AmmoMaxAggregateInputType
  }

  export type AmmoGroupByOutputType = {
    id: string
    name: string
    _count: AmmoCountAggregateOutputType | null
    _min: AmmoMinAggregateOutputType | null
    _max: AmmoMaxAggregateOutputType | null
  }

  type GetAmmoGroupByPayload<T extends AmmoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmmoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmmoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmmoGroupByOutputType[P]>
            : GetScalarType<T[P], AmmoGroupByOutputType[P]>
        }
      >
    >


  export type AmmoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weapon?: boolean | Ammo$weaponArgs<ExtArgs>
    _count?: boolean | AmmoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ammo"]>

  export type AmmoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["ammo"]>

  export type AmmoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["ammo"]>

  export type AmmoSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type AmmoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["ammo"]>
  export type AmmoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | Ammo$weaponArgs<ExtArgs>
    _count?: boolean | AmmoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AmmoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AmmoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AmmoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ammo"
    objects: {
      weapon: Prisma.$WeaponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["ammo"]>
    composites: {}
  }

  type AmmoGetPayload<S extends boolean | null | undefined | AmmoDefaultArgs> = $Result.GetResult<Prisma.$AmmoPayload, S>

  type AmmoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmmoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmmoCountAggregateInputType | true
    }

  export interface AmmoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ammo'], meta: { name: 'Ammo' } }
    /**
     * Find zero or one Ammo that matches the filter.
     * @param {AmmoFindUniqueArgs} args - Arguments to find a Ammo
     * @example
     * // Get one Ammo
     * const ammo = await prisma.ammo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmmoFindUniqueArgs>(args: SelectSubset<T, AmmoFindUniqueArgs<ExtArgs>>): Prisma__AmmoClient<$Result.GetResult<Prisma.$AmmoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ammo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmmoFindUniqueOrThrowArgs} args - Arguments to find a Ammo
     * @example
     * // Get one Ammo
     * const ammo = await prisma.ammo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmmoFindUniqueOrThrowArgs>(args: SelectSubset<T, AmmoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmmoClient<$Result.GetResult<Prisma.$AmmoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ammo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoFindFirstArgs} args - Arguments to find a Ammo
     * @example
     * // Get one Ammo
     * const ammo = await prisma.ammo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmmoFindFirstArgs>(args?: SelectSubset<T, AmmoFindFirstArgs<ExtArgs>>): Prisma__AmmoClient<$Result.GetResult<Prisma.$AmmoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ammo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoFindFirstOrThrowArgs} args - Arguments to find a Ammo
     * @example
     * // Get one Ammo
     * const ammo = await prisma.ammo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmmoFindFirstOrThrowArgs>(args?: SelectSubset<T, AmmoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmmoClient<$Result.GetResult<Prisma.$AmmoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ammo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ammo
     * const ammo = await prisma.ammo.findMany()
     * 
     * // Get first 10 Ammo
     * const ammo = await prisma.ammo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ammoWithIdOnly = await prisma.ammo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmmoFindManyArgs>(args?: SelectSubset<T, AmmoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmmoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ammo.
     * @param {AmmoCreateArgs} args - Arguments to create a Ammo.
     * @example
     * // Create one Ammo
     * const Ammo = await prisma.ammo.create({
     *   data: {
     *     // ... data to create a Ammo
     *   }
     * })
     * 
     */
    create<T extends AmmoCreateArgs>(args: SelectSubset<T, AmmoCreateArgs<ExtArgs>>): Prisma__AmmoClient<$Result.GetResult<Prisma.$AmmoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ammo.
     * @param {AmmoCreateManyArgs} args - Arguments to create many Ammo.
     * @example
     * // Create many Ammo
     * const ammo = await prisma.ammo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmmoCreateManyArgs>(args?: SelectSubset<T, AmmoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ammo and returns the data saved in the database.
     * @param {AmmoCreateManyAndReturnArgs} args - Arguments to create many Ammo.
     * @example
     * // Create many Ammo
     * const ammo = await prisma.ammo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ammo and only return the `id`
     * const ammoWithIdOnly = await prisma.ammo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmmoCreateManyAndReturnArgs>(args?: SelectSubset<T, AmmoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmmoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ammo.
     * @param {AmmoDeleteArgs} args - Arguments to delete one Ammo.
     * @example
     * // Delete one Ammo
     * const Ammo = await prisma.ammo.delete({
     *   where: {
     *     // ... filter to delete one Ammo
     *   }
     * })
     * 
     */
    delete<T extends AmmoDeleteArgs>(args: SelectSubset<T, AmmoDeleteArgs<ExtArgs>>): Prisma__AmmoClient<$Result.GetResult<Prisma.$AmmoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ammo.
     * @param {AmmoUpdateArgs} args - Arguments to update one Ammo.
     * @example
     * // Update one Ammo
     * const ammo = await prisma.ammo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmmoUpdateArgs>(args: SelectSubset<T, AmmoUpdateArgs<ExtArgs>>): Prisma__AmmoClient<$Result.GetResult<Prisma.$AmmoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ammo.
     * @param {AmmoDeleteManyArgs} args - Arguments to filter Ammo to delete.
     * @example
     * // Delete a few Ammo
     * const { count } = await prisma.ammo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmmoDeleteManyArgs>(args?: SelectSubset<T, AmmoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ammo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ammo
     * const ammo = await prisma.ammo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmmoUpdateManyArgs>(args: SelectSubset<T, AmmoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ammo and returns the data updated in the database.
     * @param {AmmoUpdateManyAndReturnArgs} args - Arguments to update many Ammo.
     * @example
     * // Update many Ammo
     * const ammo = await prisma.ammo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ammo and only return the `id`
     * const ammoWithIdOnly = await prisma.ammo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmmoUpdateManyAndReturnArgs>(args: SelectSubset<T, AmmoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmmoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ammo.
     * @param {AmmoUpsertArgs} args - Arguments to update or create a Ammo.
     * @example
     * // Update or create a Ammo
     * const ammo = await prisma.ammo.upsert({
     *   create: {
     *     // ... data to create a Ammo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ammo we want to update
     *   }
     * })
     */
    upsert<T extends AmmoUpsertArgs>(args: SelectSubset<T, AmmoUpsertArgs<ExtArgs>>): Prisma__AmmoClient<$Result.GetResult<Prisma.$AmmoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ammo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoCountArgs} args - Arguments to filter Ammo to count.
     * @example
     * // Count the number of Ammo
     * const count = await prisma.ammo.count({
     *   where: {
     *     // ... the filter for the Ammo we want to count
     *   }
     * })
    **/
    count<T extends AmmoCountArgs>(
      args?: Subset<T, AmmoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmmoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ammo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmmoAggregateArgs>(args: Subset<T, AmmoAggregateArgs>): Prisma.PrismaPromise<GetAmmoAggregateType<T>>

    /**
     * Group by Ammo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmmoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmmoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmmoGroupByArgs['orderBy'] }
        : { orderBy?: AmmoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmmoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmmoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ammo model
   */
  readonly fields: AmmoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ammo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmmoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    weapon<T extends Ammo$weaponArgs<ExtArgs> = {}>(args?: Subset<T, Ammo$weaponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ammo model
   */
  interface AmmoFieldRefs {
    readonly id: FieldRef<"Ammo", 'String'>
    readonly name: FieldRef<"Ammo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ammo findUnique
   */
  export type AmmoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammo
     */
    select?: AmmoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammo
     */
    omit?: AmmoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoInclude<ExtArgs> | null
    /**
     * Filter, which Ammo to fetch.
     */
    where: AmmoWhereUniqueInput
  }

  /**
   * Ammo findUniqueOrThrow
   */
  export type AmmoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammo
     */
    select?: AmmoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammo
     */
    omit?: AmmoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoInclude<ExtArgs> | null
    /**
     * Filter, which Ammo to fetch.
     */
    where: AmmoWhereUniqueInput
  }

  /**
   * Ammo findFirst
   */
  export type AmmoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammo
     */
    select?: AmmoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammo
     */
    omit?: AmmoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoInclude<ExtArgs> | null
    /**
     * Filter, which Ammo to fetch.
     */
    where?: AmmoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ammo to fetch.
     */
    orderBy?: AmmoOrderByWithRelationInput | AmmoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ammo.
     */
    cursor?: AmmoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ammo from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ammo.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ammo.
     */
    distinct?: AmmoScalarFieldEnum | AmmoScalarFieldEnum[]
  }

  /**
   * Ammo findFirstOrThrow
   */
  export type AmmoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammo
     */
    select?: AmmoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammo
     */
    omit?: AmmoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoInclude<ExtArgs> | null
    /**
     * Filter, which Ammo to fetch.
     */
    where?: AmmoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ammo to fetch.
     */
    orderBy?: AmmoOrderByWithRelationInput | AmmoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ammo.
     */
    cursor?: AmmoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ammo from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ammo.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ammo.
     */
    distinct?: AmmoScalarFieldEnum | AmmoScalarFieldEnum[]
  }

  /**
   * Ammo findMany
   */
  export type AmmoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammo
     */
    select?: AmmoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammo
     */
    omit?: AmmoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoInclude<ExtArgs> | null
    /**
     * Filter, which Ammo to fetch.
     */
    where?: AmmoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ammo to fetch.
     */
    orderBy?: AmmoOrderByWithRelationInput | AmmoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ammo.
     */
    cursor?: AmmoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ammo from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ammo.
     */
    skip?: number
    distinct?: AmmoScalarFieldEnum | AmmoScalarFieldEnum[]
  }

  /**
   * Ammo create
   */
  export type AmmoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammo
     */
    select?: AmmoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammo
     */
    omit?: AmmoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoInclude<ExtArgs> | null
    /**
     * The data needed to create a Ammo.
     */
    data: XOR<AmmoCreateInput, AmmoUncheckedCreateInput>
  }

  /**
   * Ammo createMany
   */
  export type AmmoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ammo.
     */
    data: AmmoCreateManyInput | AmmoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ammo createManyAndReturn
   */
  export type AmmoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammo
     */
    select?: AmmoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ammo
     */
    omit?: AmmoOmit<ExtArgs> | null
    /**
     * The data used to create many Ammo.
     */
    data: AmmoCreateManyInput | AmmoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ammo update
   */
  export type AmmoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammo
     */
    select?: AmmoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammo
     */
    omit?: AmmoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoInclude<ExtArgs> | null
    /**
     * The data needed to update a Ammo.
     */
    data: XOR<AmmoUpdateInput, AmmoUncheckedUpdateInput>
    /**
     * Choose, which Ammo to update.
     */
    where: AmmoWhereUniqueInput
  }

  /**
   * Ammo updateMany
   */
  export type AmmoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ammo.
     */
    data: XOR<AmmoUpdateManyMutationInput, AmmoUncheckedUpdateManyInput>
    /**
     * Filter which Ammo to update
     */
    where?: AmmoWhereInput
    /**
     * Limit how many Ammo to update.
     */
    limit?: number
  }

  /**
   * Ammo updateManyAndReturn
   */
  export type AmmoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammo
     */
    select?: AmmoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ammo
     */
    omit?: AmmoOmit<ExtArgs> | null
    /**
     * The data used to update Ammo.
     */
    data: XOR<AmmoUpdateManyMutationInput, AmmoUncheckedUpdateManyInput>
    /**
     * Filter which Ammo to update
     */
    where?: AmmoWhereInput
    /**
     * Limit how many Ammo to update.
     */
    limit?: number
  }

  /**
   * Ammo upsert
   */
  export type AmmoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammo
     */
    select?: AmmoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammo
     */
    omit?: AmmoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoInclude<ExtArgs> | null
    /**
     * The filter to search for the Ammo to update in case it exists.
     */
    where: AmmoWhereUniqueInput
    /**
     * In case the Ammo found by the `where` argument doesn't exist, create a new Ammo with this data.
     */
    create: XOR<AmmoCreateInput, AmmoUncheckedCreateInput>
    /**
     * In case the Ammo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmmoUpdateInput, AmmoUncheckedUpdateInput>
  }

  /**
   * Ammo delete
   */
  export type AmmoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammo
     */
    select?: AmmoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammo
     */
    omit?: AmmoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoInclude<ExtArgs> | null
    /**
     * Filter which Ammo to delete.
     */
    where: AmmoWhereUniqueInput
  }

  /**
   * Ammo deleteMany
   */
  export type AmmoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ammo to delete
     */
    where?: AmmoWhereInput
    /**
     * Limit how many Ammo to delete.
     */
    limit?: number
  }

  /**
   * Ammo.weapon
   */
  export type Ammo$weaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    where?: WeaponWhereInput
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    cursor?: WeaponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Ammo without action
   */
  export type AmmoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ammo
     */
    select?: AmmoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ammo
     */
    omit?: AmmoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmmoInclude<ExtArgs> | null
  }


  /**
   * Model Range
   */

  export type AggregateRange = {
    _count: RangeCountAggregateOutputType | null
    _min: RangeMinAggregateOutputType | null
    _max: RangeMaxAggregateOutputType | null
  }

  export type RangeMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RangeMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type RangeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RangeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RangeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RangeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Range to aggregate.
     */
    where?: RangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranges to fetch.
     */
    orderBy?: RangeOrderByWithRelationInput | RangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ranges
    **/
    _count?: true | RangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RangeMaxAggregateInputType
  }

  export type GetRangeAggregateType<T extends RangeAggregateArgs> = {
        [P in keyof T & keyof AggregateRange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRange[P]>
      : GetScalarType<T[P], AggregateRange[P]>
  }




  export type RangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RangeWhereInput
    orderBy?: RangeOrderByWithAggregationInput | RangeOrderByWithAggregationInput[]
    by: RangeScalarFieldEnum[] | RangeScalarFieldEnum
    having?: RangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RangeCountAggregateInputType | true
    _min?: RangeMinAggregateInputType
    _max?: RangeMaxAggregateInputType
  }

  export type RangeGroupByOutputType = {
    id: string
    name: string
    _count: RangeCountAggregateOutputType | null
    _min: RangeMinAggregateOutputType | null
    _max: RangeMaxAggregateOutputType | null
  }

  type GetRangeGroupByPayload<T extends RangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RangeGroupByOutputType[P]>
            : GetScalarType<T[P], RangeGroupByOutputType[P]>
        }
      >
    >


  export type RangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weapon?: boolean | Range$weaponArgs<ExtArgs>
    _count?: boolean | RangeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["range"]>

  export type RangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["range"]>

  export type RangeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["range"]>

  export type RangeSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RangeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["range"]>
  export type RangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weapon?: boolean | Range$weaponArgs<ExtArgs>
    _count?: boolean | RangeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RangeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Range"
    objects: {
      weapon: Prisma.$WeaponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["range"]>
    composites: {}
  }

  type RangeGetPayload<S extends boolean | null | undefined | RangeDefaultArgs> = $Result.GetResult<Prisma.$RangePayload, S>

  type RangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RangeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RangeCountAggregateInputType | true
    }

  export interface RangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Range'], meta: { name: 'Range' } }
    /**
     * Find zero or one Range that matches the filter.
     * @param {RangeFindUniqueArgs} args - Arguments to find a Range
     * @example
     * // Get one Range
     * const range = await prisma.range.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RangeFindUniqueArgs>(args: SelectSubset<T, RangeFindUniqueArgs<ExtArgs>>): Prisma__RangeClient<$Result.GetResult<Prisma.$RangePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Range that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RangeFindUniqueOrThrowArgs} args - Arguments to find a Range
     * @example
     * // Get one Range
     * const range = await prisma.range.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RangeFindUniqueOrThrowArgs>(args: SelectSubset<T, RangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RangeClient<$Result.GetResult<Prisma.$RangePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Range that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangeFindFirstArgs} args - Arguments to find a Range
     * @example
     * // Get one Range
     * const range = await prisma.range.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RangeFindFirstArgs>(args?: SelectSubset<T, RangeFindFirstArgs<ExtArgs>>): Prisma__RangeClient<$Result.GetResult<Prisma.$RangePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Range that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangeFindFirstOrThrowArgs} args - Arguments to find a Range
     * @example
     * // Get one Range
     * const range = await prisma.range.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RangeFindFirstOrThrowArgs>(args?: SelectSubset<T, RangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RangeClient<$Result.GetResult<Prisma.$RangePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ranges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ranges
     * const ranges = await prisma.range.findMany()
     * 
     * // Get first 10 Ranges
     * const ranges = await prisma.range.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rangeWithIdOnly = await prisma.range.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RangeFindManyArgs>(args?: SelectSubset<T, RangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Range.
     * @param {RangeCreateArgs} args - Arguments to create a Range.
     * @example
     * // Create one Range
     * const Range = await prisma.range.create({
     *   data: {
     *     // ... data to create a Range
     *   }
     * })
     * 
     */
    create<T extends RangeCreateArgs>(args: SelectSubset<T, RangeCreateArgs<ExtArgs>>): Prisma__RangeClient<$Result.GetResult<Prisma.$RangePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ranges.
     * @param {RangeCreateManyArgs} args - Arguments to create many Ranges.
     * @example
     * // Create many Ranges
     * const range = await prisma.range.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RangeCreateManyArgs>(args?: SelectSubset<T, RangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ranges and returns the data saved in the database.
     * @param {RangeCreateManyAndReturnArgs} args - Arguments to create many Ranges.
     * @example
     * // Create many Ranges
     * const range = await prisma.range.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ranges and only return the `id`
     * const rangeWithIdOnly = await prisma.range.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RangeCreateManyAndReturnArgs>(args?: SelectSubset<T, RangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RangePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Range.
     * @param {RangeDeleteArgs} args - Arguments to delete one Range.
     * @example
     * // Delete one Range
     * const Range = await prisma.range.delete({
     *   where: {
     *     // ... filter to delete one Range
     *   }
     * })
     * 
     */
    delete<T extends RangeDeleteArgs>(args: SelectSubset<T, RangeDeleteArgs<ExtArgs>>): Prisma__RangeClient<$Result.GetResult<Prisma.$RangePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Range.
     * @param {RangeUpdateArgs} args - Arguments to update one Range.
     * @example
     * // Update one Range
     * const range = await prisma.range.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RangeUpdateArgs>(args: SelectSubset<T, RangeUpdateArgs<ExtArgs>>): Prisma__RangeClient<$Result.GetResult<Prisma.$RangePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ranges.
     * @param {RangeDeleteManyArgs} args - Arguments to filter Ranges to delete.
     * @example
     * // Delete a few Ranges
     * const { count } = await prisma.range.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RangeDeleteManyArgs>(args?: SelectSubset<T, RangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ranges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ranges
     * const range = await prisma.range.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RangeUpdateManyArgs>(args: SelectSubset<T, RangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ranges and returns the data updated in the database.
     * @param {RangeUpdateManyAndReturnArgs} args - Arguments to update many Ranges.
     * @example
     * // Update many Ranges
     * const range = await prisma.range.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ranges and only return the `id`
     * const rangeWithIdOnly = await prisma.range.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RangeUpdateManyAndReturnArgs>(args: SelectSubset<T, RangeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RangePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Range.
     * @param {RangeUpsertArgs} args - Arguments to update or create a Range.
     * @example
     * // Update or create a Range
     * const range = await prisma.range.upsert({
     *   create: {
     *     // ... data to create a Range
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Range we want to update
     *   }
     * })
     */
    upsert<T extends RangeUpsertArgs>(args: SelectSubset<T, RangeUpsertArgs<ExtArgs>>): Prisma__RangeClient<$Result.GetResult<Prisma.$RangePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ranges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangeCountArgs} args - Arguments to filter Ranges to count.
     * @example
     * // Count the number of Ranges
     * const count = await prisma.range.count({
     *   where: {
     *     // ... the filter for the Ranges we want to count
     *   }
     * })
    **/
    count<T extends RangeCountArgs>(
      args?: Subset<T, RangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Range.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RangeAggregateArgs>(args: Subset<T, RangeAggregateArgs>): Prisma.PrismaPromise<GetRangeAggregateType<T>>

    /**
     * Group by Range.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RangeGroupByArgs['orderBy'] }
        : { orderBy?: RangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Range model
   */
  readonly fields: RangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Range.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    weapon<T extends Range$weaponArgs<ExtArgs> = {}>(args?: Subset<T, Range$weaponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeaponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Range model
   */
  interface RangeFieldRefs {
    readonly id: FieldRef<"Range", 'String'>
    readonly name: FieldRef<"Range", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Range findUnique
   */
  export type RangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Range
     */
    select?: RangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Range
     */
    omit?: RangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangeInclude<ExtArgs> | null
    /**
     * Filter, which Range to fetch.
     */
    where: RangeWhereUniqueInput
  }

  /**
   * Range findUniqueOrThrow
   */
  export type RangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Range
     */
    select?: RangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Range
     */
    omit?: RangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangeInclude<ExtArgs> | null
    /**
     * Filter, which Range to fetch.
     */
    where: RangeWhereUniqueInput
  }

  /**
   * Range findFirst
   */
  export type RangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Range
     */
    select?: RangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Range
     */
    omit?: RangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangeInclude<ExtArgs> | null
    /**
     * Filter, which Range to fetch.
     */
    where?: RangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranges to fetch.
     */
    orderBy?: RangeOrderByWithRelationInput | RangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ranges.
     */
    cursor?: RangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ranges.
     */
    distinct?: RangeScalarFieldEnum | RangeScalarFieldEnum[]
  }

  /**
   * Range findFirstOrThrow
   */
  export type RangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Range
     */
    select?: RangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Range
     */
    omit?: RangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangeInclude<ExtArgs> | null
    /**
     * Filter, which Range to fetch.
     */
    where?: RangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranges to fetch.
     */
    orderBy?: RangeOrderByWithRelationInput | RangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ranges.
     */
    cursor?: RangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ranges.
     */
    distinct?: RangeScalarFieldEnum | RangeScalarFieldEnum[]
  }

  /**
   * Range findMany
   */
  export type RangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Range
     */
    select?: RangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Range
     */
    omit?: RangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangeInclude<ExtArgs> | null
    /**
     * Filter, which Ranges to fetch.
     */
    where?: RangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ranges to fetch.
     */
    orderBy?: RangeOrderByWithRelationInput | RangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ranges.
     */
    cursor?: RangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ranges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ranges.
     */
    skip?: number
    distinct?: RangeScalarFieldEnum | RangeScalarFieldEnum[]
  }

  /**
   * Range create
   */
  export type RangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Range
     */
    select?: RangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Range
     */
    omit?: RangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangeInclude<ExtArgs> | null
    /**
     * The data needed to create a Range.
     */
    data: XOR<RangeCreateInput, RangeUncheckedCreateInput>
  }

  /**
   * Range createMany
   */
  export type RangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ranges.
     */
    data: RangeCreateManyInput | RangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Range createManyAndReturn
   */
  export type RangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Range
     */
    select?: RangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Range
     */
    omit?: RangeOmit<ExtArgs> | null
    /**
     * The data used to create many Ranges.
     */
    data: RangeCreateManyInput | RangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Range update
   */
  export type RangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Range
     */
    select?: RangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Range
     */
    omit?: RangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangeInclude<ExtArgs> | null
    /**
     * The data needed to update a Range.
     */
    data: XOR<RangeUpdateInput, RangeUncheckedUpdateInput>
    /**
     * Choose, which Range to update.
     */
    where: RangeWhereUniqueInput
  }

  /**
   * Range updateMany
   */
  export type RangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ranges.
     */
    data: XOR<RangeUpdateManyMutationInput, RangeUncheckedUpdateManyInput>
    /**
     * Filter which Ranges to update
     */
    where?: RangeWhereInput
    /**
     * Limit how many Ranges to update.
     */
    limit?: number
  }

  /**
   * Range updateManyAndReturn
   */
  export type RangeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Range
     */
    select?: RangeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Range
     */
    omit?: RangeOmit<ExtArgs> | null
    /**
     * The data used to update Ranges.
     */
    data: XOR<RangeUpdateManyMutationInput, RangeUncheckedUpdateManyInput>
    /**
     * Filter which Ranges to update
     */
    where?: RangeWhereInput
    /**
     * Limit how many Ranges to update.
     */
    limit?: number
  }

  /**
   * Range upsert
   */
  export type RangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Range
     */
    select?: RangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Range
     */
    omit?: RangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangeInclude<ExtArgs> | null
    /**
     * The filter to search for the Range to update in case it exists.
     */
    where: RangeWhereUniqueInput
    /**
     * In case the Range found by the `where` argument doesn't exist, create a new Range with this data.
     */
    create: XOR<RangeCreateInput, RangeUncheckedCreateInput>
    /**
     * In case the Range was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RangeUpdateInput, RangeUncheckedUpdateInput>
  }

  /**
   * Range delete
   */
  export type RangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Range
     */
    select?: RangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Range
     */
    omit?: RangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangeInclude<ExtArgs> | null
    /**
     * Filter which Range to delete.
     */
    where: RangeWhereUniqueInput
  }

  /**
   * Range deleteMany
   */
  export type RangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ranges to delete
     */
    where?: RangeWhereInput
    /**
     * Limit how many Ranges to delete.
     */
    limit?: number
  }

  /**
   * Range.weapon
   */
  export type Range$weaponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Weapon
     */
    select?: WeaponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Weapon
     */
    omit?: WeaponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeaponInclude<ExtArgs> | null
    where?: WeaponWhereInput
    orderBy?: WeaponOrderByWithRelationInput | WeaponOrderByWithRelationInput[]
    cursor?: WeaponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WeaponScalarFieldEnum | WeaponScalarFieldEnum[]
  }

  /**
   * Range without action
   */
  export type RangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Range
     */
    select?: RangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Range
     */
    omit?: RangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RangeInclude<ExtArgs> | null
  }


  /**
   * Model Suggestion
   */

  export type AggregateSuggestion = {
    _count: SuggestionCountAggregateOutputType | null
    _min: SuggestionMinAggregateOutputType | null
    _max: SuggestionMaxAggregateOutputType | null
  }

  export type SuggestionMinAggregateOutputType = {
    type: $Enums.SuggestionType | null
    name: string | null
    description: string | null
  }

  export type SuggestionMaxAggregateOutputType = {
    type: $Enums.SuggestionType | null
    name: string | null
    description: string | null
  }

  export type SuggestionCountAggregateOutputType = {
    type: number
    name: number
    description: number
    _all: number
  }


  export type SuggestionMinAggregateInputType = {
    type?: true
    name?: true
    description?: true
  }

  export type SuggestionMaxAggregateInputType = {
    type?: true
    name?: true
    description?: true
  }

  export type SuggestionCountAggregateInputType = {
    type?: true
    name?: true
    description?: true
    _all?: true
  }

  export type SuggestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suggestion to aggregate.
     */
    where?: SuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suggestions to fetch.
     */
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suggestions
    **/
    _count?: true | SuggestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuggestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuggestionMaxAggregateInputType
  }

  export type GetSuggestionAggregateType<T extends SuggestionAggregateArgs> = {
        [P in keyof T & keyof AggregateSuggestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuggestion[P]>
      : GetScalarType<T[P], AggregateSuggestion[P]>
  }




  export type SuggestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuggestionWhereInput
    orderBy?: SuggestionOrderByWithAggregationInput | SuggestionOrderByWithAggregationInput[]
    by: SuggestionScalarFieldEnum[] | SuggestionScalarFieldEnum
    having?: SuggestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuggestionCountAggregateInputType | true
    _min?: SuggestionMinAggregateInputType
    _max?: SuggestionMaxAggregateInputType
  }

  export type SuggestionGroupByOutputType = {
    type: $Enums.SuggestionType
    name: string
    description: string | null
    _count: SuggestionCountAggregateOutputType | null
    _min: SuggestionMinAggregateOutputType | null
    _max: SuggestionMaxAggregateOutputType | null
  }

  type GetSuggestionGroupByPayload<T extends SuggestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuggestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuggestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuggestionGroupByOutputType[P]>
            : GetScalarType<T[P], SuggestionGroupByOutputType[P]>
        }
      >
    >


  export type SuggestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["suggestion"]>

  export type SuggestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["suggestion"]>

  export type SuggestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["suggestion"]>

  export type SuggestionSelectScalar = {
    type?: boolean
    name?: boolean
    description?: boolean
  }

  export type SuggestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"type" | "name" | "description", ExtArgs["result"]["suggestion"]>

  export type $SuggestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Suggestion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      type: $Enums.SuggestionType
      name: string
      description: string | null
    }, ExtArgs["result"]["suggestion"]>
    composites: {}
  }

  type SuggestionGetPayload<S extends boolean | null | undefined | SuggestionDefaultArgs> = $Result.GetResult<Prisma.$SuggestionPayload, S>

  type SuggestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuggestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuggestionCountAggregateInputType | true
    }

  export interface SuggestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Suggestion'], meta: { name: 'Suggestion' } }
    /**
     * Find zero or one Suggestion that matches the filter.
     * @param {SuggestionFindUniqueArgs} args - Arguments to find a Suggestion
     * @example
     * // Get one Suggestion
     * const suggestion = await prisma.suggestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuggestionFindUniqueArgs>(args: SelectSubset<T, SuggestionFindUniqueArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Suggestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuggestionFindUniqueOrThrowArgs} args - Arguments to find a Suggestion
     * @example
     * // Get one Suggestion
     * const suggestion = await prisma.suggestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuggestionFindUniqueOrThrowArgs>(args: SelectSubset<T, SuggestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suggestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionFindFirstArgs} args - Arguments to find a Suggestion
     * @example
     * // Get one Suggestion
     * const suggestion = await prisma.suggestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuggestionFindFirstArgs>(args?: SelectSubset<T, SuggestionFindFirstArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Suggestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionFindFirstOrThrowArgs} args - Arguments to find a Suggestion
     * @example
     * // Get one Suggestion
     * const suggestion = await prisma.suggestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuggestionFindFirstOrThrowArgs>(args?: SelectSubset<T, SuggestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Suggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suggestions
     * const suggestions = await prisma.suggestion.findMany()
     * 
     * // Get first 10 Suggestions
     * const suggestions = await prisma.suggestion.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const suggestionWithNameOnly = await prisma.suggestion.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends SuggestionFindManyArgs>(args?: SelectSubset<T, SuggestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Suggestion.
     * @param {SuggestionCreateArgs} args - Arguments to create a Suggestion.
     * @example
     * // Create one Suggestion
     * const Suggestion = await prisma.suggestion.create({
     *   data: {
     *     // ... data to create a Suggestion
     *   }
     * })
     * 
     */
    create<T extends SuggestionCreateArgs>(args: SelectSubset<T, SuggestionCreateArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Suggestions.
     * @param {SuggestionCreateManyArgs} args - Arguments to create many Suggestions.
     * @example
     * // Create many Suggestions
     * const suggestion = await prisma.suggestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuggestionCreateManyArgs>(args?: SelectSubset<T, SuggestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suggestions and returns the data saved in the database.
     * @param {SuggestionCreateManyAndReturnArgs} args - Arguments to create many Suggestions.
     * @example
     * // Create many Suggestions
     * const suggestion = await prisma.suggestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suggestions and only return the `name`
     * const suggestionWithNameOnly = await prisma.suggestion.createManyAndReturn({
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuggestionCreateManyAndReturnArgs>(args?: SelectSubset<T, SuggestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Suggestion.
     * @param {SuggestionDeleteArgs} args - Arguments to delete one Suggestion.
     * @example
     * // Delete one Suggestion
     * const Suggestion = await prisma.suggestion.delete({
     *   where: {
     *     // ... filter to delete one Suggestion
     *   }
     * })
     * 
     */
    delete<T extends SuggestionDeleteArgs>(args: SelectSubset<T, SuggestionDeleteArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Suggestion.
     * @param {SuggestionUpdateArgs} args - Arguments to update one Suggestion.
     * @example
     * // Update one Suggestion
     * const suggestion = await prisma.suggestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuggestionUpdateArgs>(args: SelectSubset<T, SuggestionUpdateArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Suggestions.
     * @param {SuggestionDeleteManyArgs} args - Arguments to filter Suggestions to delete.
     * @example
     * // Delete a few Suggestions
     * const { count } = await prisma.suggestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuggestionDeleteManyArgs>(args?: SelectSubset<T, SuggestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suggestions
     * const suggestion = await prisma.suggestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuggestionUpdateManyArgs>(args: SelectSubset<T, SuggestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suggestions and returns the data updated in the database.
     * @param {SuggestionUpdateManyAndReturnArgs} args - Arguments to update many Suggestions.
     * @example
     * // Update many Suggestions
     * const suggestion = await prisma.suggestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Suggestions and only return the `name`
     * const suggestionWithNameOnly = await prisma.suggestion.updateManyAndReturn({
     *   select: { name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuggestionUpdateManyAndReturnArgs>(args: SelectSubset<T, SuggestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Suggestion.
     * @param {SuggestionUpsertArgs} args - Arguments to update or create a Suggestion.
     * @example
     * // Update or create a Suggestion
     * const suggestion = await prisma.suggestion.upsert({
     *   create: {
     *     // ... data to create a Suggestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Suggestion we want to update
     *   }
     * })
     */
    upsert<T extends SuggestionUpsertArgs>(args: SelectSubset<T, SuggestionUpsertArgs<ExtArgs>>): Prisma__SuggestionClient<$Result.GetResult<Prisma.$SuggestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Suggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionCountArgs} args - Arguments to filter Suggestions to count.
     * @example
     * // Count the number of Suggestions
     * const count = await prisma.suggestion.count({
     *   where: {
     *     // ... the filter for the Suggestions we want to count
     *   }
     * })
    **/
    count<T extends SuggestionCountArgs>(
      args?: Subset<T, SuggestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuggestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Suggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuggestionAggregateArgs>(args: Subset<T, SuggestionAggregateArgs>): Prisma.PrismaPromise<GetSuggestionAggregateType<T>>

    /**
     * Group by Suggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuggestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuggestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuggestionGroupByArgs['orderBy'] }
        : { orderBy?: SuggestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuggestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuggestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Suggestion model
   */
  readonly fields: SuggestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Suggestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuggestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Suggestion model
   */
  interface SuggestionFieldRefs {
    readonly type: FieldRef<"Suggestion", 'SuggestionType'>
    readonly name: FieldRef<"Suggestion", 'String'>
    readonly description: FieldRef<"Suggestion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Suggestion findUnique
   */
  export type SuggestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Filter, which Suggestion to fetch.
     */
    where: SuggestionWhereUniqueInput
  }

  /**
   * Suggestion findUniqueOrThrow
   */
  export type SuggestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Filter, which Suggestion to fetch.
     */
    where: SuggestionWhereUniqueInput
  }

  /**
   * Suggestion findFirst
   */
  export type SuggestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Filter, which Suggestion to fetch.
     */
    where?: SuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suggestions to fetch.
     */
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suggestions.
     */
    cursor?: SuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suggestions.
     */
    distinct?: SuggestionScalarFieldEnum | SuggestionScalarFieldEnum[]
  }

  /**
   * Suggestion findFirstOrThrow
   */
  export type SuggestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Filter, which Suggestion to fetch.
     */
    where?: SuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suggestions to fetch.
     */
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suggestions.
     */
    cursor?: SuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suggestions.
     */
    distinct?: SuggestionScalarFieldEnum | SuggestionScalarFieldEnum[]
  }

  /**
   * Suggestion findMany
   */
  export type SuggestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Filter, which Suggestions to fetch.
     */
    where?: SuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suggestions to fetch.
     */
    orderBy?: SuggestionOrderByWithRelationInput | SuggestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suggestions.
     */
    cursor?: SuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suggestions.
     */
    skip?: number
    distinct?: SuggestionScalarFieldEnum | SuggestionScalarFieldEnum[]
  }

  /**
   * Suggestion create
   */
  export type SuggestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * The data needed to create a Suggestion.
     */
    data: XOR<SuggestionCreateInput, SuggestionUncheckedCreateInput>
  }

  /**
   * Suggestion createMany
   */
  export type SuggestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suggestions.
     */
    data: SuggestionCreateManyInput | SuggestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Suggestion createManyAndReturn
   */
  export type SuggestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * The data used to create many Suggestions.
     */
    data: SuggestionCreateManyInput | SuggestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Suggestion update
   */
  export type SuggestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * The data needed to update a Suggestion.
     */
    data: XOR<SuggestionUpdateInput, SuggestionUncheckedUpdateInput>
    /**
     * Choose, which Suggestion to update.
     */
    where: SuggestionWhereUniqueInput
  }

  /**
   * Suggestion updateMany
   */
  export type SuggestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suggestions.
     */
    data: XOR<SuggestionUpdateManyMutationInput, SuggestionUncheckedUpdateManyInput>
    /**
     * Filter which Suggestions to update
     */
    where?: SuggestionWhereInput
    /**
     * Limit how many Suggestions to update.
     */
    limit?: number
  }

  /**
   * Suggestion updateManyAndReturn
   */
  export type SuggestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * The data used to update Suggestions.
     */
    data: XOR<SuggestionUpdateManyMutationInput, SuggestionUncheckedUpdateManyInput>
    /**
     * Filter which Suggestions to update
     */
    where?: SuggestionWhereInput
    /**
     * Limit how many Suggestions to update.
     */
    limit?: number
  }

  /**
   * Suggestion upsert
   */
  export type SuggestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * The filter to search for the Suggestion to update in case it exists.
     */
    where: SuggestionWhereUniqueInput
    /**
     * In case the Suggestion found by the `where` argument doesn't exist, create a new Suggestion with this data.
     */
    create: XOR<SuggestionCreateInput, SuggestionUncheckedCreateInput>
    /**
     * In case the Suggestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuggestionUpdateInput, SuggestionUncheckedUpdateInput>
  }

  /**
   * Suggestion delete
   */
  export type SuggestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
    /**
     * Filter which Suggestion to delete.
     */
    where: SuggestionWhereUniqueInput
  }

  /**
   * Suggestion deleteMany
   */
  export type SuggestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suggestions to delete
     */
    where?: SuggestionWhereInput
    /**
     * Limit how many Suggestions to delete.
     */
    limit?: number
  }

  /**
   * Suggestion without action
   */
  export type SuggestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suggestion
     */
    select?: SuggestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Suggestion
     */
    omit?: SuggestionOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ScenarioScalarFieldEnum: {
    id: 'id',
    name: 'name',
    universe: 'universe',
    description: 'description',
    userId: 'userId'
  };

  export type ScenarioScalarFieldEnum = (typeof ScenarioScalarFieldEnum)[keyof typeof ScenarioScalarFieldEnum]


  export const CharacterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    pj: 'pj',
    age: 'age',
    image: 'image',
    origin: 'origin',
    role: 'role',
    injury: 'injury',
    extra: 'extra',
    fortuneId: 'fortuneId',
    alignmentId: 'alignmentId',
    tempermentId: 'tempermentId'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const CharacterSkillScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CharacterSkillScalarFieldEnum = (typeof CharacterSkillScalarFieldEnum)[keyof typeof CharacterSkillScalarFieldEnum]


  export const FortuneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type FortuneScalarFieldEnum = (typeof FortuneScalarFieldEnum)[keyof typeof FortuneScalarFieldEnum]


  export const AlignmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type AlignmentScalarFieldEnum = (typeof AlignmentScalarFieldEnum)[keyof typeof AlignmentScalarFieldEnum]


  export const TempermentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type TempermentScalarFieldEnum = (typeof TempermentScalarFieldEnum)[keyof typeof TempermentScalarFieldEnum]


  export const StrengthScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type StrengthScalarFieldEnum = (typeof StrengthScalarFieldEnum)[keyof typeof StrengthScalarFieldEnum]


  export const WeaknessScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type WeaknessScalarFieldEnum = (typeof WeaknessScalarFieldEnum)[keyof typeof WeaknessScalarFieldEnum]


  export const WeaponScalarFieldEnum: {
    id: 'id',
    name: 'name',
    melee: 'melee',
    description: 'description',
    userId: 'userId',
    damageId: 'damageId',
    weightId: 'weightId',
    rangeId: 'rangeId',
    ammoId: 'ammoId'
  };

  export type WeaponScalarFieldEnum = (typeof WeaponScalarFieldEnum)[keyof typeof WeaponScalarFieldEnum]


  export const WeaponSkillScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type WeaponSkillScalarFieldEnum = (typeof WeaponSkillScalarFieldEnum)[keyof typeof WeaponSkillScalarFieldEnum]


  export const DamageScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DamageScalarFieldEnum = (typeof DamageScalarFieldEnum)[keyof typeof DamageScalarFieldEnum]


  export const WeightScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type WeightScalarFieldEnum = (typeof WeightScalarFieldEnum)[keyof typeof WeightScalarFieldEnum]


  export const AmmoScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type AmmoScalarFieldEnum = (typeof AmmoScalarFieldEnum)[keyof typeof AmmoScalarFieldEnum]


  export const RangeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RangeScalarFieldEnum = (typeof RangeScalarFieldEnum)[keyof typeof RangeScalarFieldEnum]


  export const SuggestionScalarFieldEnum: {
    type: 'type',
    name: 'name',
    description: 'description'
  };

  export type SuggestionScalarFieldEnum = (typeof SuggestionScalarFieldEnum)[keyof typeof SuggestionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SuggestionType'
   */
  export type EnumSuggestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SuggestionType'>
    


  /**
   * Reference to a field of type 'SuggestionType[]'
   */
  export type ListEnumSuggestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SuggestionType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    Scenario?: ScenarioListRelationFilter
    Weapon?: WeaponListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    Scenario?: ScenarioOrderByRelationAggregateInput
    Weapon?: WeaponOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    Scenario?: ScenarioListRelationFilter
    Weapon?: WeaponListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
  }

  export type ScenarioWhereInput = {
    AND?: ScenarioWhereInput | ScenarioWhereInput[]
    OR?: ScenarioWhereInput[]
    NOT?: ScenarioWhereInput | ScenarioWhereInput[]
    id?: StringFilter<"Scenario"> | string
    name?: StringFilter<"Scenario"> | string
    universe?: StringFilter<"Scenario"> | string
    description?: StringNullableFilter<"Scenario"> | string | null
    userId?: StringFilter<"Scenario"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    character?: CharacterListRelationFilter
  }

  export type ScenarioOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    universe?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    character?: CharacterOrderByRelationAggregateInput
  }

  export type ScenarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScenarioWhereInput | ScenarioWhereInput[]
    OR?: ScenarioWhereInput[]
    NOT?: ScenarioWhereInput | ScenarioWhereInput[]
    name?: StringFilter<"Scenario"> | string
    universe?: StringFilter<"Scenario"> | string
    description?: StringNullableFilter<"Scenario"> | string | null
    userId?: StringFilter<"Scenario"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    character?: CharacterListRelationFilter
  }, "id">

  export type ScenarioOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    universe?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: ScenarioCountOrderByAggregateInput
    _max?: ScenarioMaxOrderByAggregateInput
    _min?: ScenarioMinOrderByAggregateInput
  }

  export type ScenarioScalarWhereWithAggregatesInput = {
    AND?: ScenarioScalarWhereWithAggregatesInput | ScenarioScalarWhereWithAggregatesInput[]
    OR?: ScenarioScalarWhereWithAggregatesInput[]
    NOT?: ScenarioScalarWhereWithAggregatesInput | ScenarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Scenario"> | string
    name?: StringWithAggregatesFilter<"Scenario"> | string
    universe?: StringWithAggregatesFilter<"Scenario"> | string
    description?: StringNullableWithAggregatesFilter<"Scenario"> | string | null
    userId?: StringWithAggregatesFilter<"Scenario"> | string
  }

  export type CharacterWhereInput = {
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    id?: StringFilter<"Character"> | string
    name?: StringFilter<"Character"> | string
    pj?: BoolFilter<"Character"> | boolean
    age?: IntNullableFilter<"Character"> | number | null
    image?: StringNullableFilter<"Character"> | string | null
    origin?: StringNullableFilter<"Character"> | string | null
    role?: StringNullableFilter<"Character"> | string | null
    injury?: StringNullableFilter<"Character"> | string | null
    extra?: StringNullableFilter<"Character"> | string | null
    fortuneId?: StringNullableFilter<"Character"> | string | null
    alignmentId?: StringNullableFilter<"Character"> | string | null
    tempermentId?: StringNullableFilter<"Character"> | string | null
    weapon?: WeaponListRelationFilter
    skillSet?: CharacterSkillListRelationFilter
    scenario?: ScenarioListRelationFilter
    strength?: StrengthListRelationFilter
    weakness?: WeaknessListRelationFilter
    fortune?: XOR<FortuneNullableScalarRelationFilter, FortuneWhereInput> | null
    alignment?: XOR<AlignmentNullableScalarRelationFilter, AlignmentWhereInput> | null
    temperment?: XOR<TempermentNullableScalarRelationFilter, TempermentWhereInput> | null
  }

  export type CharacterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    pj?: SortOrder
    age?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    injury?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    fortuneId?: SortOrderInput | SortOrder
    alignmentId?: SortOrderInput | SortOrder
    tempermentId?: SortOrderInput | SortOrder
    weapon?: WeaponOrderByRelationAggregateInput
    skillSet?: CharacterSkillOrderByRelationAggregateInput
    scenario?: ScenarioOrderByRelationAggregateInput
    strength?: StrengthOrderByRelationAggregateInput
    weakness?: WeaknessOrderByRelationAggregateInput
    fortune?: FortuneOrderByWithRelationInput
    alignment?: AlignmentOrderByWithRelationInput
    temperment?: TempermentOrderByWithRelationInput
  }

  export type CharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    name?: StringFilter<"Character"> | string
    pj?: BoolFilter<"Character"> | boolean
    age?: IntNullableFilter<"Character"> | number | null
    image?: StringNullableFilter<"Character"> | string | null
    origin?: StringNullableFilter<"Character"> | string | null
    role?: StringNullableFilter<"Character"> | string | null
    injury?: StringNullableFilter<"Character"> | string | null
    extra?: StringNullableFilter<"Character"> | string | null
    fortuneId?: StringNullableFilter<"Character"> | string | null
    alignmentId?: StringNullableFilter<"Character"> | string | null
    tempermentId?: StringNullableFilter<"Character"> | string | null
    weapon?: WeaponListRelationFilter
    skillSet?: CharacterSkillListRelationFilter
    scenario?: ScenarioListRelationFilter
    strength?: StrengthListRelationFilter
    weakness?: WeaknessListRelationFilter
    fortune?: XOR<FortuneNullableScalarRelationFilter, FortuneWhereInput> | null
    alignment?: XOR<AlignmentNullableScalarRelationFilter, AlignmentWhereInput> | null
    temperment?: XOR<TempermentNullableScalarRelationFilter, TempermentWhereInput> | null
  }, "id">

  export type CharacterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    pj?: SortOrder
    age?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    injury?: SortOrderInput | SortOrder
    extra?: SortOrderInput | SortOrder
    fortuneId?: SortOrderInput | SortOrder
    alignmentId?: SortOrderInput | SortOrder
    tempermentId?: SortOrderInput | SortOrder
    _count?: CharacterCountOrderByAggregateInput
    _avg?: CharacterAvgOrderByAggregateInput
    _max?: CharacterMaxOrderByAggregateInput
    _min?: CharacterMinOrderByAggregateInput
    _sum?: CharacterSumOrderByAggregateInput
  }

  export type CharacterScalarWhereWithAggregatesInput = {
    AND?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    OR?: CharacterScalarWhereWithAggregatesInput[]
    NOT?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Character"> | string
    name?: StringWithAggregatesFilter<"Character"> | string
    pj?: BoolWithAggregatesFilter<"Character"> | boolean
    age?: IntNullableWithAggregatesFilter<"Character"> | number | null
    image?: StringNullableWithAggregatesFilter<"Character"> | string | null
    origin?: StringNullableWithAggregatesFilter<"Character"> | string | null
    role?: StringNullableWithAggregatesFilter<"Character"> | string | null
    injury?: StringNullableWithAggregatesFilter<"Character"> | string | null
    extra?: StringNullableWithAggregatesFilter<"Character"> | string | null
    fortuneId?: StringNullableWithAggregatesFilter<"Character"> | string | null
    alignmentId?: StringNullableWithAggregatesFilter<"Character"> | string | null
    tempermentId?: StringNullableWithAggregatesFilter<"Character"> | string | null
  }

  export type CharacterSkillWhereInput = {
    AND?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    OR?: CharacterSkillWhereInput[]
    NOT?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    id?: StringFilter<"CharacterSkill"> | string
    name?: StringFilter<"CharacterSkill"> | string
    character?: CharacterListRelationFilter
  }

  export type CharacterSkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    character?: CharacterOrderByRelationAggregateInput
  }

  export type CharacterSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    OR?: CharacterSkillWhereInput[]
    NOT?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    character?: CharacterListRelationFilter
  }, "id" | "name">

  export type CharacterSkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CharacterSkillCountOrderByAggregateInput
    _max?: CharacterSkillMaxOrderByAggregateInput
    _min?: CharacterSkillMinOrderByAggregateInput
  }

  export type CharacterSkillScalarWhereWithAggregatesInput = {
    AND?: CharacterSkillScalarWhereWithAggregatesInput | CharacterSkillScalarWhereWithAggregatesInput[]
    OR?: CharacterSkillScalarWhereWithAggregatesInput[]
    NOT?: CharacterSkillScalarWhereWithAggregatesInput | CharacterSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterSkill"> | string
    name?: StringWithAggregatesFilter<"CharacterSkill"> | string
  }

  export type FortuneWhereInput = {
    AND?: FortuneWhereInput | FortuneWhereInput[]
    OR?: FortuneWhereInput[]
    NOT?: FortuneWhereInput | FortuneWhereInput[]
    id?: StringFilter<"Fortune"> | string
    name?: StringFilter<"Fortune"> | string
    description?: StringNullableFilter<"Fortune"> | string | null
    character?: CharacterListRelationFilter
  }

  export type FortuneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    character?: CharacterOrderByRelationAggregateInput
  }

  export type FortuneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: FortuneWhereInput | FortuneWhereInput[]
    OR?: FortuneWhereInput[]
    NOT?: FortuneWhereInput | FortuneWhereInput[]
    description?: StringNullableFilter<"Fortune"> | string | null
    character?: CharacterListRelationFilter
  }, "id" | "name">

  export type FortuneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: FortuneCountOrderByAggregateInput
    _max?: FortuneMaxOrderByAggregateInput
    _min?: FortuneMinOrderByAggregateInput
  }

  export type FortuneScalarWhereWithAggregatesInput = {
    AND?: FortuneScalarWhereWithAggregatesInput | FortuneScalarWhereWithAggregatesInput[]
    OR?: FortuneScalarWhereWithAggregatesInput[]
    NOT?: FortuneScalarWhereWithAggregatesInput | FortuneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fortune"> | string
    name?: StringWithAggregatesFilter<"Fortune"> | string
    description?: StringNullableWithAggregatesFilter<"Fortune"> | string | null
  }

  export type AlignmentWhereInput = {
    AND?: AlignmentWhereInput | AlignmentWhereInput[]
    OR?: AlignmentWhereInput[]
    NOT?: AlignmentWhereInput | AlignmentWhereInput[]
    id?: StringFilter<"Alignment"> | string
    name?: StringFilter<"Alignment"> | string
    description?: StringNullableFilter<"Alignment"> | string | null
    character?: CharacterListRelationFilter
  }

  export type AlignmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    character?: CharacterOrderByRelationAggregateInput
  }

  export type AlignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AlignmentWhereInput | AlignmentWhereInput[]
    OR?: AlignmentWhereInput[]
    NOT?: AlignmentWhereInput | AlignmentWhereInput[]
    description?: StringNullableFilter<"Alignment"> | string | null
    character?: CharacterListRelationFilter
  }, "id" | "name">

  export type AlignmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: AlignmentCountOrderByAggregateInput
    _max?: AlignmentMaxOrderByAggregateInput
    _min?: AlignmentMinOrderByAggregateInput
  }

  export type AlignmentScalarWhereWithAggregatesInput = {
    AND?: AlignmentScalarWhereWithAggregatesInput | AlignmentScalarWhereWithAggregatesInput[]
    OR?: AlignmentScalarWhereWithAggregatesInput[]
    NOT?: AlignmentScalarWhereWithAggregatesInput | AlignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alignment"> | string
    name?: StringWithAggregatesFilter<"Alignment"> | string
    description?: StringNullableWithAggregatesFilter<"Alignment"> | string | null
  }

  export type TempermentWhereInput = {
    AND?: TempermentWhereInput | TempermentWhereInput[]
    OR?: TempermentWhereInput[]
    NOT?: TempermentWhereInput | TempermentWhereInput[]
    id?: StringFilter<"Temperment"> | string
    name?: StringFilter<"Temperment"> | string
    description?: StringNullableFilter<"Temperment"> | string | null
    character?: CharacterListRelationFilter
  }

  export type TempermentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    character?: CharacterOrderByRelationAggregateInput
  }

  export type TempermentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TempermentWhereInput | TempermentWhereInput[]
    OR?: TempermentWhereInput[]
    NOT?: TempermentWhereInput | TempermentWhereInput[]
    description?: StringNullableFilter<"Temperment"> | string | null
    character?: CharacterListRelationFilter
  }, "id" | "name">

  export type TempermentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: TempermentCountOrderByAggregateInput
    _max?: TempermentMaxOrderByAggregateInput
    _min?: TempermentMinOrderByAggregateInput
  }

  export type TempermentScalarWhereWithAggregatesInput = {
    AND?: TempermentScalarWhereWithAggregatesInput | TempermentScalarWhereWithAggregatesInput[]
    OR?: TempermentScalarWhereWithAggregatesInput[]
    NOT?: TempermentScalarWhereWithAggregatesInput | TempermentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Temperment"> | string
    name?: StringWithAggregatesFilter<"Temperment"> | string
    description?: StringNullableWithAggregatesFilter<"Temperment"> | string | null
  }

  export type StrengthWhereInput = {
    AND?: StrengthWhereInput | StrengthWhereInput[]
    OR?: StrengthWhereInput[]
    NOT?: StrengthWhereInput | StrengthWhereInput[]
    id?: StringFilter<"Strength"> | string
    name?: StringFilter<"Strength"> | string
    character?: CharacterListRelationFilter
  }

  export type StrengthOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    character?: CharacterOrderByRelationAggregateInput
  }

  export type StrengthWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: StrengthWhereInput | StrengthWhereInput[]
    OR?: StrengthWhereInput[]
    NOT?: StrengthWhereInput | StrengthWhereInput[]
    character?: CharacterListRelationFilter
  }, "id" | "name">

  export type StrengthOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: StrengthCountOrderByAggregateInput
    _max?: StrengthMaxOrderByAggregateInput
    _min?: StrengthMinOrderByAggregateInput
  }

  export type StrengthScalarWhereWithAggregatesInput = {
    AND?: StrengthScalarWhereWithAggregatesInput | StrengthScalarWhereWithAggregatesInput[]
    OR?: StrengthScalarWhereWithAggregatesInput[]
    NOT?: StrengthScalarWhereWithAggregatesInput | StrengthScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Strength"> | string
    name?: StringWithAggregatesFilter<"Strength"> | string
  }

  export type WeaknessWhereInput = {
    AND?: WeaknessWhereInput | WeaknessWhereInput[]
    OR?: WeaknessWhereInput[]
    NOT?: WeaknessWhereInput | WeaknessWhereInput[]
    id?: StringFilter<"Weakness"> | string
    name?: StringFilter<"Weakness"> | string
    character?: CharacterListRelationFilter
  }

  export type WeaknessOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    character?: CharacterOrderByRelationAggregateInput
  }

  export type WeaknessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: WeaknessWhereInput | WeaknessWhereInput[]
    OR?: WeaknessWhereInput[]
    NOT?: WeaknessWhereInput | WeaknessWhereInput[]
    character?: CharacterListRelationFilter
  }, "id" | "name">

  export type WeaknessOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: WeaknessCountOrderByAggregateInput
    _max?: WeaknessMaxOrderByAggregateInput
    _min?: WeaknessMinOrderByAggregateInput
  }

  export type WeaknessScalarWhereWithAggregatesInput = {
    AND?: WeaknessScalarWhereWithAggregatesInput | WeaknessScalarWhereWithAggregatesInput[]
    OR?: WeaknessScalarWhereWithAggregatesInput[]
    NOT?: WeaknessScalarWhereWithAggregatesInput | WeaknessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Weakness"> | string
    name?: StringWithAggregatesFilter<"Weakness"> | string
  }

  export type WeaponWhereInput = {
    AND?: WeaponWhereInput | WeaponWhereInput[]
    OR?: WeaponWhereInput[]
    NOT?: WeaponWhereInput | WeaponWhereInput[]
    id?: StringFilter<"Weapon"> | string
    name?: StringFilter<"Weapon"> | string
    melee?: BoolFilter<"Weapon"> | boolean
    description?: StringNullableFilter<"Weapon"> | string | null
    userId?: StringFilter<"Weapon"> | string
    damageId?: StringFilter<"Weapon"> | string
    weightId?: StringFilter<"Weapon"> | string
    rangeId?: StringFilter<"Weapon"> | string
    ammoId?: StringNullableFilter<"Weapon"> | string | null
    character?: CharacterListRelationFilter
    weaponSkill?: WeaponSkillListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    damage?: XOR<DamageScalarRelationFilter, DamageWhereInput>
    weight?: XOR<WeightScalarRelationFilter, WeightWhereInput>
    range?: XOR<RangeScalarRelationFilter, RangeWhereInput>
    ammo?: XOR<AmmoNullableScalarRelationFilter, AmmoWhereInput> | null
  }

  export type WeaponOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    melee?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    damageId?: SortOrder
    weightId?: SortOrder
    rangeId?: SortOrder
    ammoId?: SortOrderInput | SortOrder
    character?: CharacterOrderByRelationAggregateInput
    weaponSkill?: WeaponSkillOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    damage?: DamageOrderByWithRelationInput
    weight?: WeightOrderByWithRelationInput
    range?: RangeOrderByWithRelationInput
    ammo?: AmmoOrderByWithRelationInput
  }

  export type WeaponWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WeaponWhereInput | WeaponWhereInput[]
    OR?: WeaponWhereInput[]
    NOT?: WeaponWhereInput | WeaponWhereInput[]
    name?: StringFilter<"Weapon"> | string
    melee?: BoolFilter<"Weapon"> | boolean
    description?: StringNullableFilter<"Weapon"> | string | null
    userId?: StringFilter<"Weapon"> | string
    damageId?: StringFilter<"Weapon"> | string
    weightId?: StringFilter<"Weapon"> | string
    rangeId?: StringFilter<"Weapon"> | string
    ammoId?: StringNullableFilter<"Weapon"> | string | null
    character?: CharacterListRelationFilter
    weaponSkill?: WeaponSkillListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    damage?: XOR<DamageScalarRelationFilter, DamageWhereInput>
    weight?: XOR<WeightScalarRelationFilter, WeightWhereInput>
    range?: XOR<RangeScalarRelationFilter, RangeWhereInput>
    ammo?: XOR<AmmoNullableScalarRelationFilter, AmmoWhereInput> | null
  }, "id">

  export type WeaponOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    melee?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    damageId?: SortOrder
    weightId?: SortOrder
    rangeId?: SortOrder
    ammoId?: SortOrderInput | SortOrder
    _count?: WeaponCountOrderByAggregateInput
    _max?: WeaponMaxOrderByAggregateInput
    _min?: WeaponMinOrderByAggregateInput
  }

  export type WeaponScalarWhereWithAggregatesInput = {
    AND?: WeaponScalarWhereWithAggregatesInput | WeaponScalarWhereWithAggregatesInput[]
    OR?: WeaponScalarWhereWithAggregatesInput[]
    NOT?: WeaponScalarWhereWithAggregatesInput | WeaponScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Weapon"> | string
    name?: StringWithAggregatesFilter<"Weapon"> | string
    melee?: BoolWithAggregatesFilter<"Weapon"> | boolean
    description?: StringNullableWithAggregatesFilter<"Weapon"> | string | null
    userId?: StringWithAggregatesFilter<"Weapon"> | string
    damageId?: StringWithAggregatesFilter<"Weapon"> | string
    weightId?: StringWithAggregatesFilter<"Weapon"> | string
    rangeId?: StringWithAggregatesFilter<"Weapon"> | string
    ammoId?: StringNullableWithAggregatesFilter<"Weapon"> | string | null
  }

  export type WeaponSkillWhereInput = {
    AND?: WeaponSkillWhereInput | WeaponSkillWhereInput[]
    OR?: WeaponSkillWhereInput[]
    NOT?: WeaponSkillWhereInput | WeaponSkillWhereInput[]
    id?: StringFilter<"WeaponSkill"> | string
    name?: StringFilter<"WeaponSkill"> | string
    weapon?: WeaponListRelationFilter
  }

  export type WeaponSkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weapon?: WeaponOrderByRelationAggregateInput
  }

  export type WeaponSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: WeaponSkillWhereInput | WeaponSkillWhereInput[]
    OR?: WeaponSkillWhereInput[]
    NOT?: WeaponSkillWhereInput | WeaponSkillWhereInput[]
    weapon?: WeaponListRelationFilter
  }, "id" | "name">

  export type WeaponSkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: WeaponSkillCountOrderByAggregateInput
    _max?: WeaponSkillMaxOrderByAggregateInput
    _min?: WeaponSkillMinOrderByAggregateInput
  }

  export type WeaponSkillScalarWhereWithAggregatesInput = {
    AND?: WeaponSkillScalarWhereWithAggregatesInput | WeaponSkillScalarWhereWithAggregatesInput[]
    OR?: WeaponSkillScalarWhereWithAggregatesInput[]
    NOT?: WeaponSkillScalarWhereWithAggregatesInput | WeaponSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeaponSkill"> | string
    name?: StringWithAggregatesFilter<"WeaponSkill"> | string
  }

  export type DamageWhereInput = {
    AND?: DamageWhereInput | DamageWhereInput[]
    OR?: DamageWhereInput[]
    NOT?: DamageWhereInput | DamageWhereInput[]
    id?: StringFilter<"Damage"> | string
    name?: StringFilter<"Damage"> | string
    weapon?: WeaponListRelationFilter
  }

  export type DamageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weapon?: WeaponOrderByRelationAggregateInput
  }

  export type DamageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DamageWhereInput | DamageWhereInput[]
    OR?: DamageWhereInput[]
    NOT?: DamageWhereInput | DamageWhereInput[]
    weapon?: WeaponListRelationFilter
  }, "id" | "name">

  export type DamageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DamageCountOrderByAggregateInput
    _max?: DamageMaxOrderByAggregateInput
    _min?: DamageMinOrderByAggregateInput
  }

  export type DamageScalarWhereWithAggregatesInput = {
    AND?: DamageScalarWhereWithAggregatesInput | DamageScalarWhereWithAggregatesInput[]
    OR?: DamageScalarWhereWithAggregatesInput[]
    NOT?: DamageScalarWhereWithAggregatesInput | DamageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Damage"> | string
    name?: StringWithAggregatesFilter<"Damage"> | string
  }

  export type WeightWhereInput = {
    AND?: WeightWhereInput | WeightWhereInput[]
    OR?: WeightWhereInput[]
    NOT?: WeightWhereInput | WeightWhereInput[]
    id?: StringFilter<"Weight"> | string
    name?: StringFilter<"Weight"> | string
    weapon?: WeaponListRelationFilter
  }

  export type WeightOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weapon?: WeaponOrderByRelationAggregateInput
  }

  export type WeightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: WeightWhereInput | WeightWhereInput[]
    OR?: WeightWhereInput[]
    NOT?: WeightWhereInput | WeightWhereInput[]
    weapon?: WeaponListRelationFilter
  }, "id" | "name">

  export type WeightOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: WeightCountOrderByAggregateInput
    _max?: WeightMaxOrderByAggregateInput
    _min?: WeightMinOrderByAggregateInput
  }

  export type WeightScalarWhereWithAggregatesInput = {
    AND?: WeightScalarWhereWithAggregatesInput | WeightScalarWhereWithAggregatesInput[]
    OR?: WeightScalarWhereWithAggregatesInput[]
    NOT?: WeightScalarWhereWithAggregatesInput | WeightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Weight"> | string
    name?: StringWithAggregatesFilter<"Weight"> | string
  }

  export type AmmoWhereInput = {
    AND?: AmmoWhereInput | AmmoWhereInput[]
    OR?: AmmoWhereInput[]
    NOT?: AmmoWhereInput | AmmoWhereInput[]
    id?: StringFilter<"Ammo"> | string
    name?: StringFilter<"Ammo"> | string
    weapon?: WeaponListRelationFilter
  }

  export type AmmoOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weapon?: WeaponOrderByRelationAggregateInput
  }

  export type AmmoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AmmoWhereInput | AmmoWhereInput[]
    OR?: AmmoWhereInput[]
    NOT?: AmmoWhereInput | AmmoWhereInput[]
    weapon?: WeaponListRelationFilter
  }, "id" | "name">

  export type AmmoOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: AmmoCountOrderByAggregateInput
    _max?: AmmoMaxOrderByAggregateInput
    _min?: AmmoMinOrderByAggregateInput
  }

  export type AmmoScalarWhereWithAggregatesInput = {
    AND?: AmmoScalarWhereWithAggregatesInput | AmmoScalarWhereWithAggregatesInput[]
    OR?: AmmoScalarWhereWithAggregatesInput[]
    NOT?: AmmoScalarWhereWithAggregatesInput | AmmoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ammo"> | string
    name?: StringWithAggregatesFilter<"Ammo"> | string
  }

  export type RangeWhereInput = {
    AND?: RangeWhereInput | RangeWhereInput[]
    OR?: RangeWhereInput[]
    NOT?: RangeWhereInput | RangeWhereInput[]
    id?: StringFilter<"Range"> | string
    name?: StringFilter<"Range"> | string
    weapon?: WeaponListRelationFilter
  }

  export type RangeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weapon?: WeaponOrderByRelationAggregateInput
  }

  export type RangeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RangeWhereInput | RangeWhereInput[]
    OR?: RangeWhereInput[]
    NOT?: RangeWhereInput | RangeWhereInput[]
    weapon?: WeaponListRelationFilter
  }, "id" | "name">

  export type RangeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RangeCountOrderByAggregateInput
    _max?: RangeMaxOrderByAggregateInput
    _min?: RangeMinOrderByAggregateInput
  }

  export type RangeScalarWhereWithAggregatesInput = {
    AND?: RangeScalarWhereWithAggregatesInput | RangeScalarWhereWithAggregatesInput[]
    OR?: RangeScalarWhereWithAggregatesInput[]
    NOT?: RangeScalarWhereWithAggregatesInput | RangeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Range"> | string
    name?: StringWithAggregatesFilter<"Range"> | string
  }

  export type SuggestionWhereInput = {
    AND?: SuggestionWhereInput | SuggestionWhereInput[]
    OR?: SuggestionWhereInput[]
    NOT?: SuggestionWhereInput | SuggestionWhereInput[]
    type?: EnumSuggestionTypeFilter<"Suggestion"> | $Enums.SuggestionType
    name?: StringFilter<"Suggestion"> | string
    description?: StringNullableFilter<"Suggestion"> | string | null
  }

  export type SuggestionOrderByWithRelationInput = {
    type?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type SuggestionWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: SuggestionWhereInput | SuggestionWhereInput[]
    OR?: SuggestionWhereInput[]
    NOT?: SuggestionWhereInput | SuggestionWhereInput[]
    type?: EnumSuggestionTypeFilter<"Suggestion"> | $Enums.SuggestionType
    description?: StringNullableFilter<"Suggestion"> | string | null
  }, "name">

  export type SuggestionOrderByWithAggregationInput = {
    type?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: SuggestionCountOrderByAggregateInput
    _max?: SuggestionMaxOrderByAggregateInput
    _min?: SuggestionMinOrderByAggregateInput
  }

  export type SuggestionScalarWhereWithAggregatesInput = {
    AND?: SuggestionScalarWhereWithAggregatesInput | SuggestionScalarWhereWithAggregatesInput[]
    OR?: SuggestionScalarWhereWithAggregatesInput[]
    NOT?: SuggestionScalarWhereWithAggregatesInput | SuggestionScalarWhereWithAggregatesInput[]
    type?: EnumSuggestionTypeWithAggregatesFilter<"Suggestion"> | $Enums.SuggestionType
    name?: StringWithAggregatesFilter<"Suggestion"> | string
    description?: StringNullableWithAggregatesFilter<"Suggestion"> | string | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Scenario?: ScenarioCreateNestedManyWithoutUserInput
    Weapon?: WeaponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Scenario?: ScenarioUncheckedCreateNestedManyWithoutUserInput
    Weapon?: WeaponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Scenario?: ScenarioUpdateManyWithoutUserNestedInput
    Weapon?: WeaponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Scenario?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
    Weapon?: WeaponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.Role
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type ScenarioCreateInput = {
    id?: string
    name: string
    universe: string
    description?: string | null
    user: UserCreateNestedOneWithoutScenarioInput
    character?: CharacterCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioUncheckedCreateInput = {
    id?: string
    name: string
    universe: string
    description?: string | null
    userId: string
    character?: CharacterUncheckedCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    universe?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutScenarioNestedInput
    character?: CharacterUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    universe?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    character?: CharacterUncheckedUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioCreateManyInput = {
    id?: string
    name: string
    universe: string
    description?: string | null
    userId: string
  }

  export type ScenarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    universe?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScenarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    universe?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CharacterCreateInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    weapon?: WeaponCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioCreateNestedManyWithoutCharacterInput
    strength?: StrengthCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessCreateNestedManyWithoutCharacterInput
    fortune?: FortuneCreateNestedOneWithoutCharacterInput
    alignment?: AlignmentCreateNestedOneWithoutCharacterInput
    temperment?: TempermentCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    fortuneId?: string | null
    alignmentId?: string | null
    tempermentId?: string | null
    weapon?: WeaponUncheckedCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioUncheckedCreateNestedManyWithoutCharacterInput
    strength?: StrengthUncheckedCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUpdateManyWithoutCharacterNestedInput
    fortune?: FortuneUpdateOneWithoutCharacterNestedInput
    alignment?: AlignmentUpdateOneWithoutCharacterNestedInput
    temperment?: TempermentUpdateOneWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUncheckedUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUncheckedUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUncheckedUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterCreateManyInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    fortuneId?: string | null
    alignmentId?: string | null
    tempermentId?: string | null
  }

  export type CharacterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterSkillCreateInput = {
    id?: string
    name: string
    character?: CharacterCreateNestedManyWithoutSkillSetInput
  }

  export type CharacterSkillUncheckedCreateInput = {
    id?: string
    name: string
    character?: CharacterUncheckedCreateNestedManyWithoutSkillSetInput
  }

  export type CharacterSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    character?: CharacterUpdateManyWithoutSkillSetNestedInput
  }

  export type CharacterSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    character?: CharacterUncheckedUpdateManyWithoutSkillSetNestedInput
  }

  export type CharacterSkillCreateManyInput = {
    id?: string
    name: string
  }

  export type CharacterSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CharacterSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FortuneCreateInput = {
    id?: string
    name: string
    description?: string | null
    character?: CharacterCreateNestedManyWithoutFortuneInput
  }

  export type FortuneUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    character?: CharacterUncheckedCreateNestedManyWithoutFortuneInput
  }

  export type FortuneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutFortuneNestedInput
  }

  export type FortuneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUncheckedUpdateManyWithoutFortuneNestedInput
  }

  export type FortuneCreateManyInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type FortuneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FortuneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlignmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    character?: CharacterCreateNestedManyWithoutAlignmentInput
  }

  export type AlignmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    character?: CharacterUncheckedCreateNestedManyWithoutAlignmentInput
  }

  export type AlignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutAlignmentNestedInput
  }

  export type AlignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUncheckedUpdateManyWithoutAlignmentNestedInput
  }

  export type AlignmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type AlignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TempermentCreateInput = {
    id?: string
    name: string
    description?: string | null
    character?: CharacterCreateNestedManyWithoutTempermentInput
  }

  export type TempermentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    character?: CharacterUncheckedCreateNestedManyWithoutTempermentInput
  }

  export type TempermentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutTempermentNestedInput
  }

  export type TempermentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUncheckedUpdateManyWithoutTempermentNestedInput
  }

  export type TempermentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type TempermentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TempermentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StrengthCreateInput = {
    id?: string
    name: string
    character?: CharacterCreateNestedManyWithoutStrengthInput
  }

  export type StrengthUncheckedCreateInput = {
    id?: string
    name: string
    character?: CharacterUncheckedCreateNestedManyWithoutStrengthInput
  }

  export type StrengthUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    character?: CharacterUpdateManyWithoutStrengthNestedInput
  }

  export type StrengthUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    character?: CharacterUncheckedUpdateManyWithoutStrengthNestedInput
  }

  export type StrengthCreateManyInput = {
    id?: string
    name: string
  }

  export type StrengthUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StrengthUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeaknessCreateInput = {
    id?: string
    name: string
    character?: CharacterCreateNestedManyWithoutWeaknessInput
  }

  export type WeaknessUncheckedCreateInput = {
    id?: string
    name: string
    character?: CharacterUncheckedCreateNestedManyWithoutWeaknessInput
  }

  export type WeaknessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    character?: CharacterUpdateManyWithoutWeaknessNestedInput
  }

  export type WeaknessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    character?: CharacterUncheckedUpdateManyWithoutWeaknessNestedInput
  }

  export type WeaknessCreateManyInput = {
    id?: string
    name: string
  }

  export type WeaknessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeaknessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeaponCreateInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    character?: CharacterCreateNestedManyWithoutWeaponInput
    weaponSkill?: WeaponSkillCreateNestedManyWithoutWeaponInput
    user: UserCreateNestedOneWithoutWeaponInput
    damage: DamageCreateNestedOneWithoutWeaponInput
    weight: WeightCreateNestedOneWithoutWeaponInput
    range: RangeCreateNestedOneWithoutWeaponInput
    ammo?: AmmoCreateNestedOneWithoutWeaponInput
  }

  export type WeaponUncheckedCreateInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    userId: string
    damageId: string
    weightId: string
    rangeId: string
    ammoId?: string | null
    character?: CharacterUncheckedCreateNestedManyWithoutWeaponInput
    weaponSkill?: WeaponSkillUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type WeaponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutWeaponNestedInput
    weaponSkill?: WeaponSkillUpdateManyWithoutWeaponNestedInput
    user?: UserUpdateOneRequiredWithoutWeaponNestedInput
    damage?: DamageUpdateOneRequiredWithoutWeaponNestedInput
    weight?: WeightUpdateOneRequiredWithoutWeaponNestedInput
    range?: RangeUpdateOneRequiredWithoutWeaponNestedInput
    ammo?: AmmoUpdateOneWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    damageId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUncheckedUpdateManyWithoutWeaponNestedInput
    weaponSkill?: WeaponSkillUncheckedUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponCreateManyInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    userId: string
    damageId: string
    weightId: string
    rangeId: string
    ammoId?: string | null
  }

  export type WeaponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeaponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    damageId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeaponSkillCreateInput = {
    id?: string
    name: string
    weapon?: WeaponCreateNestedManyWithoutWeaponSkillInput
  }

  export type WeaponSkillUncheckedCreateInput = {
    id?: string
    name: string
    weapon?: WeaponUncheckedCreateNestedManyWithoutWeaponSkillInput
  }

  export type WeaponSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weapon?: WeaponUpdateManyWithoutWeaponSkillNestedInput
  }

  export type WeaponSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weapon?: WeaponUncheckedUpdateManyWithoutWeaponSkillNestedInput
  }

  export type WeaponSkillCreateManyInput = {
    id?: string
    name: string
  }

  export type WeaponSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeaponSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DamageCreateInput = {
    id?: string
    name: string
    weapon?: WeaponCreateNestedManyWithoutDamageInput
  }

  export type DamageUncheckedCreateInput = {
    id?: string
    name: string
    weapon?: WeaponUncheckedCreateNestedManyWithoutDamageInput
  }

  export type DamageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weapon?: WeaponUpdateManyWithoutDamageNestedInput
  }

  export type DamageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weapon?: WeaponUncheckedUpdateManyWithoutDamageNestedInput
  }

  export type DamageCreateManyInput = {
    id?: string
    name: string
  }

  export type DamageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DamageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeightCreateInput = {
    id?: string
    name: string
    weapon?: WeaponCreateNestedManyWithoutWeightInput
  }

  export type WeightUncheckedCreateInput = {
    id?: string
    name: string
    weapon?: WeaponUncheckedCreateNestedManyWithoutWeightInput
  }

  export type WeightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weapon?: WeaponUpdateManyWithoutWeightNestedInput
  }

  export type WeightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weapon?: WeaponUncheckedUpdateManyWithoutWeightNestedInput
  }

  export type WeightCreateManyInput = {
    id?: string
    name: string
  }

  export type WeightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AmmoCreateInput = {
    id?: string
    name: string
    weapon?: WeaponCreateNestedManyWithoutAmmoInput
  }

  export type AmmoUncheckedCreateInput = {
    id?: string
    name: string
    weapon?: WeaponUncheckedCreateNestedManyWithoutAmmoInput
  }

  export type AmmoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weapon?: WeaponUpdateManyWithoutAmmoNestedInput
  }

  export type AmmoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weapon?: WeaponUncheckedUpdateManyWithoutAmmoNestedInput
  }

  export type AmmoCreateManyInput = {
    id?: string
    name: string
  }

  export type AmmoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AmmoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RangeCreateInput = {
    id?: string
    name: string
    weapon?: WeaponCreateNestedManyWithoutRangeInput
  }

  export type RangeUncheckedCreateInput = {
    id?: string
    name: string
    weapon?: WeaponUncheckedCreateNestedManyWithoutRangeInput
  }

  export type RangeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weapon?: WeaponUpdateManyWithoutRangeNestedInput
  }

  export type RangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weapon?: WeaponUncheckedUpdateManyWithoutRangeNestedInput
  }

  export type RangeCreateManyInput = {
    id?: string
    name: string
  }

  export type RangeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SuggestionCreateInput = {
    type: $Enums.SuggestionType
    name: string
    description?: string | null
  }

  export type SuggestionUncheckedCreateInput = {
    type: $Enums.SuggestionType
    name: string
    description?: string | null
  }

  export type SuggestionUpdateInput = {
    type?: EnumSuggestionTypeFieldUpdateOperationsInput | $Enums.SuggestionType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuggestionUncheckedUpdateInput = {
    type?: EnumSuggestionTypeFieldUpdateOperationsInput | $Enums.SuggestionType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuggestionCreateManyInput = {
    type: $Enums.SuggestionType
    name: string
    description?: string | null
  }

  export type SuggestionUpdateManyMutationInput = {
    type?: EnumSuggestionTypeFieldUpdateOperationsInput | $Enums.SuggestionType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SuggestionUncheckedUpdateManyInput = {
    type?: EnumSuggestionTypeFieldUpdateOperationsInput | $Enums.SuggestionType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ScenarioListRelationFilter = {
    every?: ScenarioWhereInput
    some?: ScenarioWhereInput
    none?: ScenarioWhereInput
  }

  export type WeaponListRelationFilter = {
    every?: WeaponWhereInput
    some?: WeaponWhereInput
    none?: WeaponWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScenarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeaponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type CharacterListRelationFilter = {
    every?: CharacterWhereInput
    some?: CharacterWhereInput
    none?: CharacterWhereInput
  }

  export type CharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScenarioCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    universe?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type ScenarioMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    universe?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type ScenarioMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    universe?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CharacterSkillListRelationFilter = {
    every?: CharacterSkillWhereInput
    some?: CharacterSkillWhereInput
    none?: CharacterSkillWhereInput
  }

  export type StrengthListRelationFilter = {
    every?: StrengthWhereInput
    some?: StrengthWhereInput
    none?: StrengthWhereInput
  }

  export type WeaknessListRelationFilter = {
    every?: WeaknessWhereInput
    some?: WeaknessWhereInput
    none?: WeaknessWhereInput
  }

  export type FortuneNullableScalarRelationFilter = {
    is?: FortuneWhereInput | null
    isNot?: FortuneWhereInput | null
  }

  export type AlignmentNullableScalarRelationFilter = {
    is?: AlignmentWhereInput | null
    isNot?: AlignmentWhereInput | null
  }

  export type TempermentNullableScalarRelationFilter = {
    is?: TempermentWhereInput | null
    isNot?: TempermentWhereInput | null
  }

  export type CharacterSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StrengthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeaknessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pj?: SortOrder
    age?: SortOrder
    image?: SortOrder
    origin?: SortOrder
    role?: SortOrder
    injury?: SortOrder
    extra?: SortOrder
    fortuneId?: SortOrder
    alignmentId?: SortOrder
    tempermentId?: SortOrder
  }

  export type CharacterAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type CharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pj?: SortOrder
    age?: SortOrder
    image?: SortOrder
    origin?: SortOrder
    role?: SortOrder
    injury?: SortOrder
    extra?: SortOrder
    fortuneId?: SortOrder
    alignmentId?: SortOrder
    tempermentId?: SortOrder
  }

  export type CharacterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pj?: SortOrder
    age?: SortOrder
    image?: SortOrder
    origin?: SortOrder
    role?: SortOrder
    injury?: SortOrder
    extra?: SortOrder
    fortuneId?: SortOrder
    alignmentId?: SortOrder
    tempermentId?: SortOrder
  }

  export type CharacterSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CharacterSkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CharacterSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CharacterSkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FortuneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type FortuneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type FortuneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type AlignmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type AlignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type AlignmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type TempermentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type TempermentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type TempermentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type StrengthCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StrengthMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StrengthMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WeaknessCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WeaknessMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WeaknessMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WeaponSkillListRelationFilter = {
    every?: WeaponSkillWhereInput
    some?: WeaponSkillWhereInput
    none?: WeaponSkillWhereInput
  }

  export type DamageScalarRelationFilter = {
    is?: DamageWhereInput
    isNot?: DamageWhereInput
  }

  export type WeightScalarRelationFilter = {
    is?: WeightWhereInput
    isNot?: WeightWhereInput
  }

  export type RangeScalarRelationFilter = {
    is?: RangeWhereInput
    isNot?: RangeWhereInput
  }

  export type AmmoNullableScalarRelationFilter = {
    is?: AmmoWhereInput | null
    isNot?: AmmoWhereInput | null
  }

  export type WeaponSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WeaponCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    melee?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    damageId?: SortOrder
    weightId?: SortOrder
    rangeId?: SortOrder
    ammoId?: SortOrder
  }

  export type WeaponMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    melee?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    damageId?: SortOrder
    weightId?: SortOrder
    rangeId?: SortOrder
    ammoId?: SortOrder
  }

  export type WeaponMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    melee?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    damageId?: SortOrder
    weightId?: SortOrder
    rangeId?: SortOrder
    ammoId?: SortOrder
  }

  export type WeaponSkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WeaponSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WeaponSkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DamageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DamageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DamageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WeightCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WeightMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WeightMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AmmoCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AmmoMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AmmoMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RangeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RangeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RangeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EnumSuggestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SuggestionType | EnumSuggestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SuggestionType[] | ListEnumSuggestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SuggestionType[] | ListEnumSuggestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSuggestionTypeFilter<$PrismaModel> | $Enums.SuggestionType
  }

  export type SuggestionCountOrderByAggregateInput = {
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type SuggestionMaxOrderByAggregateInput = {
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type SuggestionMinOrderByAggregateInput = {
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type EnumSuggestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SuggestionType | EnumSuggestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SuggestionType[] | ListEnumSuggestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SuggestionType[] | ListEnumSuggestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSuggestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SuggestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSuggestionTypeFilter<$PrismaModel>
    _max?: NestedEnumSuggestionTypeFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ScenarioCreateNestedManyWithoutUserInput = {
    create?: XOR<ScenarioCreateWithoutUserInput, ScenarioUncheckedCreateWithoutUserInput> | ScenarioCreateWithoutUserInput[] | ScenarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutUserInput | ScenarioCreateOrConnectWithoutUserInput[]
    createMany?: ScenarioCreateManyUserInputEnvelope
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type WeaponCreateNestedManyWithoutUserInput = {
    create?: XOR<WeaponCreateWithoutUserInput, WeaponUncheckedCreateWithoutUserInput> | WeaponCreateWithoutUserInput[] | WeaponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutUserInput | WeaponCreateOrConnectWithoutUserInput[]
    createMany?: WeaponCreateManyUserInputEnvelope
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ScenarioUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ScenarioCreateWithoutUserInput, ScenarioUncheckedCreateWithoutUserInput> | ScenarioCreateWithoutUserInput[] | ScenarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutUserInput | ScenarioCreateOrConnectWithoutUserInput[]
    createMany?: ScenarioCreateManyUserInputEnvelope
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type WeaponUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WeaponCreateWithoutUserInput, WeaponUncheckedCreateWithoutUserInput> | WeaponCreateWithoutUserInput[] | WeaponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutUserInput | WeaponCreateOrConnectWithoutUserInput[]
    createMany?: WeaponCreateManyUserInputEnvelope
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ScenarioUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScenarioCreateWithoutUserInput, ScenarioUncheckedCreateWithoutUserInput> | ScenarioCreateWithoutUserInput[] | ScenarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutUserInput | ScenarioCreateOrConnectWithoutUserInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutUserInput | ScenarioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScenarioCreateManyUserInputEnvelope
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutUserInput | ScenarioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutUserInput | ScenarioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type WeaponUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeaponCreateWithoutUserInput, WeaponUncheckedCreateWithoutUserInput> | WeaponCreateWithoutUserInput[] | WeaponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutUserInput | WeaponCreateOrConnectWithoutUserInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutUserInput | WeaponUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeaponCreateManyUserInputEnvelope
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutUserInput | WeaponUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutUserInput | WeaponUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ScenarioUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScenarioCreateWithoutUserInput, ScenarioUncheckedCreateWithoutUserInput> | ScenarioCreateWithoutUserInput[] | ScenarioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutUserInput | ScenarioCreateOrConnectWithoutUserInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutUserInput | ScenarioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScenarioCreateManyUserInputEnvelope
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutUserInput | ScenarioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutUserInput | ScenarioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type WeaponUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WeaponCreateWithoutUserInput, WeaponUncheckedCreateWithoutUserInput> | WeaponCreateWithoutUserInput[] | WeaponUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutUserInput | WeaponCreateOrConnectWithoutUserInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutUserInput | WeaponUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WeaponCreateManyUserInputEnvelope
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutUserInput | WeaponUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutUserInput | WeaponUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutScenarioInput = {
    create?: XOR<UserCreateWithoutScenarioInput, UserUncheckedCreateWithoutScenarioInput>
    connectOrCreate?: UserCreateOrConnectWithoutScenarioInput
    connect?: UserWhereUniqueInput
  }

  export type CharacterCreateNestedManyWithoutScenarioInput = {
    create?: XOR<CharacterCreateWithoutScenarioInput, CharacterUncheckedCreateWithoutScenarioInput> | CharacterCreateWithoutScenarioInput[] | CharacterUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutScenarioInput | CharacterCreateOrConnectWithoutScenarioInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutScenarioInput = {
    create?: XOR<CharacterCreateWithoutScenarioInput, CharacterUncheckedCreateWithoutScenarioInput> | CharacterCreateWithoutScenarioInput[] | CharacterUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutScenarioInput | CharacterCreateOrConnectWithoutScenarioInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutScenarioNestedInput = {
    create?: XOR<UserCreateWithoutScenarioInput, UserUncheckedCreateWithoutScenarioInput>
    connectOrCreate?: UserCreateOrConnectWithoutScenarioInput
    upsert?: UserUpsertWithoutScenarioInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScenarioInput, UserUpdateWithoutScenarioInput>, UserUncheckedUpdateWithoutScenarioInput>
  }

  export type CharacterUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<CharacterCreateWithoutScenarioInput, CharacterUncheckedCreateWithoutScenarioInput> | CharacterCreateWithoutScenarioInput[] | CharacterUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutScenarioInput | CharacterCreateOrConnectWithoutScenarioInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutScenarioInput | CharacterUpsertWithWhereUniqueWithoutScenarioInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutScenarioInput | CharacterUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutScenarioInput | CharacterUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<CharacterCreateWithoutScenarioInput, CharacterUncheckedCreateWithoutScenarioInput> | CharacterCreateWithoutScenarioInput[] | CharacterUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutScenarioInput | CharacterCreateOrConnectWithoutScenarioInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutScenarioInput | CharacterUpsertWithWhereUniqueWithoutScenarioInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutScenarioInput | CharacterUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutScenarioInput | CharacterUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type WeaponCreateNestedManyWithoutCharacterInput = {
    create?: XOR<WeaponCreateWithoutCharacterInput, WeaponUncheckedCreateWithoutCharacterInput> | WeaponCreateWithoutCharacterInput[] | WeaponUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutCharacterInput | WeaponCreateOrConnectWithoutCharacterInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type CharacterSkillCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput> | CharacterSkillCreateWithoutCharacterInput[] | CharacterSkillUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutCharacterInput | CharacterSkillCreateOrConnectWithoutCharacterInput[]
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
  }

  export type ScenarioCreateNestedManyWithoutCharacterInput = {
    create?: XOR<ScenarioCreateWithoutCharacterInput, ScenarioUncheckedCreateWithoutCharacterInput> | ScenarioCreateWithoutCharacterInput[] | ScenarioUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutCharacterInput | ScenarioCreateOrConnectWithoutCharacterInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type StrengthCreateNestedManyWithoutCharacterInput = {
    create?: XOR<StrengthCreateWithoutCharacterInput, StrengthUncheckedCreateWithoutCharacterInput> | StrengthCreateWithoutCharacterInput[] | StrengthUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: StrengthCreateOrConnectWithoutCharacterInput | StrengthCreateOrConnectWithoutCharacterInput[]
    connect?: StrengthWhereUniqueInput | StrengthWhereUniqueInput[]
  }

  export type WeaknessCreateNestedManyWithoutCharacterInput = {
    create?: XOR<WeaknessCreateWithoutCharacterInput, WeaknessUncheckedCreateWithoutCharacterInput> | WeaknessCreateWithoutCharacterInput[] | WeaknessUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: WeaknessCreateOrConnectWithoutCharacterInput | WeaknessCreateOrConnectWithoutCharacterInput[]
    connect?: WeaknessWhereUniqueInput | WeaknessWhereUniqueInput[]
  }

  export type FortuneCreateNestedOneWithoutCharacterInput = {
    create?: XOR<FortuneCreateWithoutCharacterInput, FortuneUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: FortuneCreateOrConnectWithoutCharacterInput
    connect?: FortuneWhereUniqueInput
  }

  export type AlignmentCreateNestedOneWithoutCharacterInput = {
    create?: XOR<AlignmentCreateWithoutCharacterInput, AlignmentUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: AlignmentCreateOrConnectWithoutCharacterInput
    connect?: AlignmentWhereUniqueInput
  }

  export type TempermentCreateNestedOneWithoutCharacterInput = {
    create?: XOR<TempermentCreateWithoutCharacterInput, TempermentUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: TempermentCreateOrConnectWithoutCharacterInput
    connect?: TempermentWhereUniqueInput
  }

  export type WeaponUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<WeaponCreateWithoutCharacterInput, WeaponUncheckedCreateWithoutCharacterInput> | WeaponCreateWithoutCharacterInput[] | WeaponUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutCharacterInput | WeaponCreateOrConnectWithoutCharacterInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput> | CharacterSkillCreateWithoutCharacterInput[] | CharacterSkillUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutCharacterInput | CharacterSkillCreateOrConnectWithoutCharacterInput[]
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
  }

  export type ScenarioUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<ScenarioCreateWithoutCharacterInput, ScenarioUncheckedCreateWithoutCharacterInput> | ScenarioCreateWithoutCharacterInput[] | ScenarioUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutCharacterInput | ScenarioCreateOrConnectWithoutCharacterInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type StrengthUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<StrengthCreateWithoutCharacterInput, StrengthUncheckedCreateWithoutCharacterInput> | StrengthCreateWithoutCharacterInput[] | StrengthUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: StrengthCreateOrConnectWithoutCharacterInput | StrengthCreateOrConnectWithoutCharacterInput[]
    connect?: StrengthWhereUniqueInput | StrengthWhereUniqueInput[]
  }

  export type WeaknessUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<WeaknessCreateWithoutCharacterInput, WeaknessUncheckedCreateWithoutCharacterInput> | WeaknessCreateWithoutCharacterInput[] | WeaknessUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: WeaknessCreateOrConnectWithoutCharacterInput | WeaknessCreateOrConnectWithoutCharacterInput[]
    connect?: WeaknessWhereUniqueInput | WeaknessWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type WeaponUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<WeaponCreateWithoutCharacterInput, WeaponUncheckedCreateWithoutCharacterInput> | WeaponCreateWithoutCharacterInput[] | WeaponUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutCharacterInput | WeaponCreateOrConnectWithoutCharacterInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutCharacterInput | WeaponUpsertWithWhereUniqueWithoutCharacterInput[]
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutCharacterInput | WeaponUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutCharacterInput | WeaponUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type CharacterSkillUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput> | CharacterSkillCreateWithoutCharacterInput[] | CharacterSkillUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutCharacterInput | CharacterSkillCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput | CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput[]
    set?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    disconnect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    delete?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    update?: CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput | CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterSkillUpdateManyWithWhereWithoutCharacterInput | CharacterSkillUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
  }

  export type ScenarioUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<ScenarioCreateWithoutCharacterInput, ScenarioUncheckedCreateWithoutCharacterInput> | ScenarioCreateWithoutCharacterInput[] | ScenarioUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutCharacterInput | ScenarioCreateOrConnectWithoutCharacterInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutCharacterInput | ScenarioUpsertWithWhereUniqueWithoutCharacterInput[]
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutCharacterInput | ScenarioUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutCharacterInput | ScenarioUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type StrengthUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<StrengthCreateWithoutCharacterInput, StrengthUncheckedCreateWithoutCharacterInput> | StrengthCreateWithoutCharacterInput[] | StrengthUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: StrengthCreateOrConnectWithoutCharacterInput | StrengthCreateOrConnectWithoutCharacterInput[]
    upsert?: StrengthUpsertWithWhereUniqueWithoutCharacterInput | StrengthUpsertWithWhereUniqueWithoutCharacterInput[]
    set?: StrengthWhereUniqueInput | StrengthWhereUniqueInput[]
    disconnect?: StrengthWhereUniqueInput | StrengthWhereUniqueInput[]
    delete?: StrengthWhereUniqueInput | StrengthWhereUniqueInput[]
    connect?: StrengthWhereUniqueInput | StrengthWhereUniqueInput[]
    update?: StrengthUpdateWithWhereUniqueWithoutCharacterInput | StrengthUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: StrengthUpdateManyWithWhereWithoutCharacterInput | StrengthUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: StrengthScalarWhereInput | StrengthScalarWhereInput[]
  }

  export type WeaknessUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<WeaknessCreateWithoutCharacterInput, WeaknessUncheckedCreateWithoutCharacterInput> | WeaknessCreateWithoutCharacterInput[] | WeaknessUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: WeaknessCreateOrConnectWithoutCharacterInput | WeaknessCreateOrConnectWithoutCharacterInput[]
    upsert?: WeaknessUpsertWithWhereUniqueWithoutCharacterInput | WeaknessUpsertWithWhereUniqueWithoutCharacterInput[]
    set?: WeaknessWhereUniqueInput | WeaknessWhereUniqueInput[]
    disconnect?: WeaknessWhereUniqueInput | WeaknessWhereUniqueInput[]
    delete?: WeaknessWhereUniqueInput | WeaknessWhereUniqueInput[]
    connect?: WeaknessWhereUniqueInput | WeaknessWhereUniqueInput[]
    update?: WeaknessUpdateWithWhereUniqueWithoutCharacterInput | WeaknessUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: WeaknessUpdateManyWithWhereWithoutCharacterInput | WeaknessUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: WeaknessScalarWhereInput | WeaknessScalarWhereInput[]
  }

  export type FortuneUpdateOneWithoutCharacterNestedInput = {
    create?: XOR<FortuneCreateWithoutCharacterInput, FortuneUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: FortuneCreateOrConnectWithoutCharacterInput
    upsert?: FortuneUpsertWithoutCharacterInput
    disconnect?: FortuneWhereInput | boolean
    delete?: FortuneWhereInput | boolean
    connect?: FortuneWhereUniqueInput
    update?: XOR<XOR<FortuneUpdateToOneWithWhereWithoutCharacterInput, FortuneUpdateWithoutCharacterInput>, FortuneUncheckedUpdateWithoutCharacterInput>
  }

  export type AlignmentUpdateOneWithoutCharacterNestedInput = {
    create?: XOR<AlignmentCreateWithoutCharacterInput, AlignmentUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: AlignmentCreateOrConnectWithoutCharacterInput
    upsert?: AlignmentUpsertWithoutCharacterInput
    disconnect?: AlignmentWhereInput | boolean
    delete?: AlignmentWhereInput | boolean
    connect?: AlignmentWhereUniqueInput
    update?: XOR<XOR<AlignmentUpdateToOneWithWhereWithoutCharacterInput, AlignmentUpdateWithoutCharacterInput>, AlignmentUncheckedUpdateWithoutCharacterInput>
  }

  export type TempermentUpdateOneWithoutCharacterNestedInput = {
    create?: XOR<TempermentCreateWithoutCharacterInput, TempermentUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: TempermentCreateOrConnectWithoutCharacterInput
    upsert?: TempermentUpsertWithoutCharacterInput
    disconnect?: TempermentWhereInput | boolean
    delete?: TempermentWhereInput | boolean
    connect?: TempermentWhereUniqueInput
    update?: XOR<XOR<TempermentUpdateToOneWithWhereWithoutCharacterInput, TempermentUpdateWithoutCharacterInput>, TempermentUncheckedUpdateWithoutCharacterInput>
  }

  export type WeaponUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<WeaponCreateWithoutCharacterInput, WeaponUncheckedCreateWithoutCharacterInput> | WeaponCreateWithoutCharacterInput[] | WeaponUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutCharacterInput | WeaponCreateOrConnectWithoutCharacterInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutCharacterInput | WeaponUpsertWithWhereUniqueWithoutCharacterInput[]
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutCharacterInput | WeaponUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutCharacterInput | WeaponUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput> | CharacterSkillCreateWithoutCharacterInput[] | CharacterSkillUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutCharacterInput | CharacterSkillCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput | CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput[]
    set?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    disconnect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    delete?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    update?: CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput | CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterSkillUpdateManyWithWhereWithoutCharacterInput | CharacterSkillUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
  }

  export type ScenarioUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<ScenarioCreateWithoutCharacterInput, ScenarioUncheckedCreateWithoutCharacterInput> | ScenarioCreateWithoutCharacterInput[] | ScenarioUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutCharacterInput | ScenarioCreateOrConnectWithoutCharacterInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutCharacterInput | ScenarioUpsertWithWhereUniqueWithoutCharacterInput[]
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutCharacterInput | ScenarioUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutCharacterInput | ScenarioUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type StrengthUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<StrengthCreateWithoutCharacterInput, StrengthUncheckedCreateWithoutCharacterInput> | StrengthCreateWithoutCharacterInput[] | StrengthUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: StrengthCreateOrConnectWithoutCharacterInput | StrengthCreateOrConnectWithoutCharacterInput[]
    upsert?: StrengthUpsertWithWhereUniqueWithoutCharacterInput | StrengthUpsertWithWhereUniqueWithoutCharacterInput[]
    set?: StrengthWhereUniqueInput | StrengthWhereUniqueInput[]
    disconnect?: StrengthWhereUniqueInput | StrengthWhereUniqueInput[]
    delete?: StrengthWhereUniqueInput | StrengthWhereUniqueInput[]
    connect?: StrengthWhereUniqueInput | StrengthWhereUniqueInput[]
    update?: StrengthUpdateWithWhereUniqueWithoutCharacterInput | StrengthUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: StrengthUpdateManyWithWhereWithoutCharacterInput | StrengthUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: StrengthScalarWhereInput | StrengthScalarWhereInput[]
  }

  export type WeaknessUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<WeaknessCreateWithoutCharacterInput, WeaknessUncheckedCreateWithoutCharacterInput> | WeaknessCreateWithoutCharacterInput[] | WeaknessUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: WeaknessCreateOrConnectWithoutCharacterInput | WeaknessCreateOrConnectWithoutCharacterInput[]
    upsert?: WeaknessUpsertWithWhereUniqueWithoutCharacterInput | WeaknessUpsertWithWhereUniqueWithoutCharacterInput[]
    set?: WeaknessWhereUniqueInput | WeaknessWhereUniqueInput[]
    disconnect?: WeaknessWhereUniqueInput | WeaknessWhereUniqueInput[]
    delete?: WeaknessWhereUniqueInput | WeaknessWhereUniqueInput[]
    connect?: WeaknessWhereUniqueInput | WeaknessWhereUniqueInput[]
    update?: WeaknessUpdateWithWhereUniqueWithoutCharacterInput | WeaknessUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: WeaknessUpdateManyWithWhereWithoutCharacterInput | WeaknessUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: WeaknessScalarWhereInput | WeaknessScalarWhereInput[]
  }

  export type CharacterCreateNestedManyWithoutSkillSetInput = {
    create?: XOR<CharacterCreateWithoutSkillSetInput, CharacterUncheckedCreateWithoutSkillSetInput> | CharacterCreateWithoutSkillSetInput[] | CharacterUncheckedCreateWithoutSkillSetInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutSkillSetInput | CharacterCreateOrConnectWithoutSkillSetInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutSkillSetInput = {
    create?: XOR<CharacterCreateWithoutSkillSetInput, CharacterUncheckedCreateWithoutSkillSetInput> | CharacterCreateWithoutSkillSetInput[] | CharacterUncheckedCreateWithoutSkillSetInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutSkillSetInput | CharacterCreateOrConnectWithoutSkillSetInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUpdateManyWithoutSkillSetNestedInput = {
    create?: XOR<CharacterCreateWithoutSkillSetInput, CharacterUncheckedCreateWithoutSkillSetInput> | CharacterCreateWithoutSkillSetInput[] | CharacterUncheckedCreateWithoutSkillSetInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutSkillSetInput | CharacterCreateOrConnectWithoutSkillSetInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutSkillSetInput | CharacterUpsertWithWhereUniqueWithoutSkillSetInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutSkillSetInput | CharacterUpdateWithWhereUniqueWithoutSkillSetInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutSkillSetInput | CharacterUpdateManyWithWhereWithoutSkillSetInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutSkillSetNestedInput = {
    create?: XOR<CharacterCreateWithoutSkillSetInput, CharacterUncheckedCreateWithoutSkillSetInput> | CharacterCreateWithoutSkillSetInput[] | CharacterUncheckedCreateWithoutSkillSetInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutSkillSetInput | CharacterCreateOrConnectWithoutSkillSetInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutSkillSetInput | CharacterUpsertWithWhereUniqueWithoutSkillSetInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutSkillSetInput | CharacterUpdateWithWhereUniqueWithoutSkillSetInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutSkillSetInput | CharacterUpdateManyWithWhereWithoutSkillSetInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterCreateNestedManyWithoutFortuneInput = {
    create?: XOR<CharacterCreateWithoutFortuneInput, CharacterUncheckedCreateWithoutFortuneInput> | CharacterCreateWithoutFortuneInput[] | CharacterUncheckedCreateWithoutFortuneInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutFortuneInput | CharacterCreateOrConnectWithoutFortuneInput[]
    createMany?: CharacterCreateManyFortuneInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutFortuneInput = {
    create?: XOR<CharacterCreateWithoutFortuneInput, CharacterUncheckedCreateWithoutFortuneInput> | CharacterCreateWithoutFortuneInput[] | CharacterUncheckedCreateWithoutFortuneInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutFortuneInput | CharacterCreateOrConnectWithoutFortuneInput[]
    createMany?: CharacterCreateManyFortuneInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUpdateManyWithoutFortuneNestedInput = {
    create?: XOR<CharacterCreateWithoutFortuneInput, CharacterUncheckedCreateWithoutFortuneInput> | CharacterCreateWithoutFortuneInput[] | CharacterUncheckedCreateWithoutFortuneInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutFortuneInput | CharacterCreateOrConnectWithoutFortuneInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutFortuneInput | CharacterUpsertWithWhereUniqueWithoutFortuneInput[]
    createMany?: CharacterCreateManyFortuneInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutFortuneInput | CharacterUpdateWithWhereUniqueWithoutFortuneInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutFortuneInput | CharacterUpdateManyWithWhereWithoutFortuneInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutFortuneNestedInput = {
    create?: XOR<CharacterCreateWithoutFortuneInput, CharacterUncheckedCreateWithoutFortuneInput> | CharacterCreateWithoutFortuneInput[] | CharacterUncheckedCreateWithoutFortuneInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutFortuneInput | CharacterCreateOrConnectWithoutFortuneInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutFortuneInput | CharacterUpsertWithWhereUniqueWithoutFortuneInput[]
    createMany?: CharacterCreateManyFortuneInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutFortuneInput | CharacterUpdateWithWhereUniqueWithoutFortuneInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutFortuneInput | CharacterUpdateManyWithWhereWithoutFortuneInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterCreateNestedManyWithoutAlignmentInput = {
    create?: XOR<CharacterCreateWithoutAlignmentInput, CharacterUncheckedCreateWithoutAlignmentInput> | CharacterCreateWithoutAlignmentInput[] | CharacterUncheckedCreateWithoutAlignmentInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAlignmentInput | CharacterCreateOrConnectWithoutAlignmentInput[]
    createMany?: CharacterCreateManyAlignmentInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutAlignmentInput = {
    create?: XOR<CharacterCreateWithoutAlignmentInput, CharacterUncheckedCreateWithoutAlignmentInput> | CharacterCreateWithoutAlignmentInput[] | CharacterUncheckedCreateWithoutAlignmentInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAlignmentInput | CharacterCreateOrConnectWithoutAlignmentInput[]
    createMany?: CharacterCreateManyAlignmentInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUpdateManyWithoutAlignmentNestedInput = {
    create?: XOR<CharacterCreateWithoutAlignmentInput, CharacterUncheckedCreateWithoutAlignmentInput> | CharacterCreateWithoutAlignmentInput[] | CharacterUncheckedCreateWithoutAlignmentInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAlignmentInput | CharacterCreateOrConnectWithoutAlignmentInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutAlignmentInput | CharacterUpsertWithWhereUniqueWithoutAlignmentInput[]
    createMany?: CharacterCreateManyAlignmentInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutAlignmentInput | CharacterUpdateWithWhereUniqueWithoutAlignmentInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutAlignmentInput | CharacterUpdateManyWithWhereWithoutAlignmentInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutAlignmentNestedInput = {
    create?: XOR<CharacterCreateWithoutAlignmentInput, CharacterUncheckedCreateWithoutAlignmentInput> | CharacterCreateWithoutAlignmentInput[] | CharacterUncheckedCreateWithoutAlignmentInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAlignmentInput | CharacterCreateOrConnectWithoutAlignmentInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutAlignmentInput | CharacterUpsertWithWhereUniqueWithoutAlignmentInput[]
    createMany?: CharacterCreateManyAlignmentInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutAlignmentInput | CharacterUpdateWithWhereUniqueWithoutAlignmentInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutAlignmentInput | CharacterUpdateManyWithWhereWithoutAlignmentInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterCreateNestedManyWithoutTempermentInput = {
    create?: XOR<CharacterCreateWithoutTempermentInput, CharacterUncheckedCreateWithoutTempermentInput> | CharacterCreateWithoutTempermentInput[] | CharacterUncheckedCreateWithoutTempermentInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutTempermentInput | CharacterCreateOrConnectWithoutTempermentInput[]
    createMany?: CharacterCreateManyTempermentInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutTempermentInput = {
    create?: XOR<CharacterCreateWithoutTempermentInput, CharacterUncheckedCreateWithoutTempermentInput> | CharacterCreateWithoutTempermentInput[] | CharacterUncheckedCreateWithoutTempermentInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutTempermentInput | CharacterCreateOrConnectWithoutTempermentInput[]
    createMany?: CharacterCreateManyTempermentInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUpdateManyWithoutTempermentNestedInput = {
    create?: XOR<CharacterCreateWithoutTempermentInput, CharacterUncheckedCreateWithoutTempermentInput> | CharacterCreateWithoutTempermentInput[] | CharacterUncheckedCreateWithoutTempermentInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutTempermentInput | CharacterCreateOrConnectWithoutTempermentInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutTempermentInput | CharacterUpsertWithWhereUniqueWithoutTempermentInput[]
    createMany?: CharacterCreateManyTempermentInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutTempermentInput | CharacterUpdateWithWhereUniqueWithoutTempermentInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutTempermentInput | CharacterUpdateManyWithWhereWithoutTempermentInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutTempermentNestedInput = {
    create?: XOR<CharacterCreateWithoutTempermentInput, CharacterUncheckedCreateWithoutTempermentInput> | CharacterCreateWithoutTempermentInput[] | CharacterUncheckedCreateWithoutTempermentInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutTempermentInput | CharacterCreateOrConnectWithoutTempermentInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutTempermentInput | CharacterUpsertWithWhereUniqueWithoutTempermentInput[]
    createMany?: CharacterCreateManyTempermentInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutTempermentInput | CharacterUpdateWithWhereUniqueWithoutTempermentInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutTempermentInput | CharacterUpdateManyWithWhereWithoutTempermentInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterCreateNestedManyWithoutStrengthInput = {
    create?: XOR<CharacterCreateWithoutStrengthInput, CharacterUncheckedCreateWithoutStrengthInput> | CharacterCreateWithoutStrengthInput[] | CharacterUncheckedCreateWithoutStrengthInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutStrengthInput | CharacterCreateOrConnectWithoutStrengthInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutStrengthInput = {
    create?: XOR<CharacterCreateWithoutStrengthInput, CharacterUncheckedCreateWithoutStrengthInput> | CharacterCreateWithoutStrengthInput[] | CharacterUncheckedCreateWithoutStrengthInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutStrengthInput | CharacterCreateOrConnectWithoutStrengthInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUpdateManyWithoutStrengthNestedInput = {
    create?: XOR<CharacterCreateWithoutStrengthInput, CharacterUncheckedCreateWithoutStrengthInput> | CharacterCreateWithoutStrengthInput[] | CharacterUncheckedCreateWithoutStrengthInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutStrengthInput | CharacterCreateOrConnectWithoutStrengthInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutStrengthInput | CharacterUpsertWithWhereUniqueWithoutStrengthInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutStrengthInput | CharacterUpdateWithWhereUniqueWithoutStrengthInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutStrengthInput | CharacterUpdateManyWithWhereWithoutStrengthInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutStrengthNestedInput = {
    create?: XOR<CharacterCreateWithoutStrengthInput, CharacterUncheckedCreateWithoutStrengthInput> | CharacterCreateWithoutStrengthInput[] | CharacterUncheckedCreateWithoutStrengthInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutStrengthInput | CharacterCreateOrConnectWithoutStrengthInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutStrengthInput | CharacterUpsertWithWhereUniqueWithoutStrengthInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutStrengthInput | CharacterUpdateWithWhereUniqueWithoutStrengthInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutStrengthInput | CharacterUpdateManyWithWhereWithoutStrengthInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterCreateNestedManyWithoutWeaknessInput = {
    create?: XOR<CharacterCreateWithoutWeaknessInput, CharacterUncheckedCreateWithoutWeaknessInput> | CharacterCreateWithoutWeaknessInput[] | CharacterUncheckedCreateWithoutWeaknessInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutWeaknessInput | CharacterCreateOrConnectWithoutWeaknessInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutWeaknessInput = {
    create?: XOR<CharacterCreateWithoutWeaknessInput, CharacterUncheckedCreateWithoutWeaknessInput> | CharacterCreateWithoutWeaknessInput[] | CharacterUncheckedCreateWithoutWeaknessInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutWeaknessInput | CharacterCreateOrConnectWithoutWeaknessInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUpdateManyWithoutWeaknessNestedInput = {
    create?: XOR<CharacterCreateWithoutWeaknessInput, CharacterUncheckedCreateWithoutWeaknessInput> | CharacterCreateWithoutWeaknessInput[] | CharacterUncheckedCreateWithoutWeaknessInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutWeaknessInput | CharacterCreateOrConnectWithoutWeaknessInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutWeaknessInput | CharacterUpsertWithWhereUniqueWithoutWeaknessInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutWeaknessInput | CharacterUpdateWithWhereUniqueWithoutWeaknessInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutWeaknessInput | CharacterUpdateManyWithWhereWithoutWeaknessInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutWeaknessNestedInput = {
    create?: XOR<CharacterCreateWithoutWeaknessInput, CharacterUncheckedCreateWithoutWeaknessInput> | CharacterCreateWithoutWeaknessInput[] | CharacterUncheckedCreateWithoutWeaknessInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutWeaknessInput | CharacterCreateOrConnectWithoutWeaknessInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutWeaknessInput | CharacterUpsertWithWhereUniqueWithoutWeaknessInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutWeaknessInput | CharacterUpdateWithWhereUniqueWithoutWeaknessInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutWeaknessInput | CharacterUpdateManyWithWhereWithoutWeaknessInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type CharacterCreateNestedManyWithoutWeaponInput = {
    create?: XOR<CharacterCreateWithoutWeaponInput, CharacterUncheckedCreateWithoutWeaponInput> | CharacterCreateWithoutWeaponInput[] | CharacterUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutWeaponInput | CharacterCreateOrConnectWithoutWeaponInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type WeaponSkillCreateNestedManyWithoutWeaponInput = {
    create?: XOR<WeaponSkillCreateWithoutWeaponInput, WeaponSkillUncheckedCreateWithoutWeaponInput> | WeaponSkillCreateWithoutWeaponInput[] | WeaponSkillUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: WeaponSkillCreateOrConnectWithoutWeaponInput | WeaponSkillCreateOrConnectWithoutWeaponInput[]
    connect?: WeaponSkillWhereUniqueInput | WeaponSkillWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutWeaponInput = {
    create?: XOR<UserCreateWithoutWeaponInput, UserUncheckedCreateWithoutWeaponInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeaponInput
    connect?: UserWhereUniqueInput
  }

  export type DamageCreateNestedOneWithoutWeaponInput = {
    create?: XOR<DamageCreateWithoutWeaponInput, DamageUncheckedCreateWithoutWeaponInput>
    connectOrCreate?: DamageCreateOrConnectWithoutWeaponInput
    connect?: DamageWhereUniqueInput
  }

  export type WeightCreateNestedOneWithoutWeaponInput = {
    create?: XOR<WeightCreateWithoutWeaponInput, WeightUncheckedCreateWithoutWeaponInput>
    connectOrCreate?: WeightCreateOrConnectWithoutWeaponInput
    connect?: WeightWhereUniqueInput
  }

  export type RangeCreateNestedOneWithoutWeaponInput = {
    create?: XOR<RangeCreateWithoutWeaponInput, RangeUncheckedCreateWithoutWeaponInput>
    connectOrCreate?: RangeCreateOrConnectWithoutWeaponInput
    connect?: RangeWhereUniqueInput
  }

  export type AmmoCreateNestedOneWithoutWeaponInput = {
    create?: XOR<AmmoCreateWithoutWeaponInput, AmmoUncheckedCreateWithoutWeaponInput>
    connectOrCreate?: AmmoCreateOrConnectWithoutWeaponInput
    connect?: AmmoWhereUniqueInput
  }

  export type CharacterUncheckedCreateNestedManyWithoutWeaponInput = {
    create?: XOR<CharacterCreateWithoutWeaponInput, CharacterUncheckedCreateWithoutWeaponInput> | CharacterCreateWithoutWeaponInput[] | CharacterUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutWeaponInput | CharacterCreateOrConnectWithoutWeaponInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type WeaponSkillUncheckedCreateNestedManyWithoutWeaponInput = {
    create?: XOR<WeaponSkillCreateWithoutWeaponInput, WeaponSkillUncheckedCreateWithoutWeaponInput> | WeaponSkillCreateWithoutWeaponInput[] | WeaponSkillUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: WeaponSkillCreateOrConnectWithoutWeaponInput | WeaponSkillCreateOrConnectWithoutWeaponInput[]
    connect?: WeaponSkillWhereUniqueInput | WeaponSkillWhereUniqueInput[]
  }

  export type CharacterUpdateManyWithoutWeaponNestedInput = {
    create?: XOR<CharacterCreateWithoutWeaponInput, CharacterUncheckedCreateWithoutWeaponInput> | CharacterCreateWithoutWeaponInput[] | CharacterUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutWeaponInput | CharacterCreateOrConnectWithoutWeaponInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutWeaponInput | CharacterUpsertWithWhereUniqueWithoutWeaponInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutWeaponInput | CharacterUpdateWithWhereUniqueWithoutWeaponInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutWeaponInput | CharacterUpdateManyWithWhereWithoutWeaponInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type WeaponSkillUpdateManyWithoutWeaponNestedInput = {
    create?: XOR<WeaponSkillCreateWithoutWeaponInput, WeaponSkillUncheckedCreateWithoutWeaponInput> | WeaponSkillCreateWithoutWeaponInput[] | WeaponSkillUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: WeaponSkillCreateOrConnectWithoutWeaponInput | WeaponSkillCreateOrConnectWithoutWeaponInput[]
    upsert?: WeaponSkillUpsertWithWhereUniqueWithoutWeaponInput | WeaponSkillUpsertWithWhereUniqueWithoutWeaponInput[]
    set?: WeaponSkillWhereUniqueInput | WeaponSkillWhereUniqueInput[]
    disconnect?: WeaponSkillWhereUniqueInput | WeaponSkillWhereUniqueInput[]
    delete?: WeaponSkillWhereUniqueInput | WeaponSkillWhereUniqueInput[]
    connect?: WeaponSkillWhereUniqueInput | WeaponSkillWhereUniqueInput[]
    update?: WeaponSkillUpdateWithWhereUniqueWithoutWeaponInput | WeaponSkillUpdateWithWhereUniqueWithoutWeaponInput[]
    updateMany?: WeaponSkillUpdateManyWithWhereWithoutWeaponInput | WeaponSkillUpdateManyWithWhereWithoutWeaponInput[]
    deleteMany?: WeaponSkillScalarWhereInput | WeaponSkillScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutWeaponNestedInput = {
    create?: XOR<UserCreateWithoutWeaponInput, UserUncheckedCreateWithoutWeaponInput>
    connectOrCreate?: UserCreateOrConnectWithoutWeaponInput
    upsert?: UserUpsertWithoutWeaponInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWeaponInput, UserUpdateWithoutWeaponInput>, UserUncheckedUpdateWithoutWeaponInput>
  }

  export type DamageUpdateOneRequiredWithoutWeaponNestedInput = {
    create?: XOR<DamageCreateWithoutWeaponInput, DamageUncheckedCreateWithoutWeaponInput>
    connectOrCreate?: DamageCreateOrConnectWithoutWeaponInput
    upsert?: DamageUpsertWithoutWeaponInput
    connect?: DamageWhereUniqueInput
    update?: XOR<XOR<DamageUpdateToOneWithWhereWithoutWeaponInput, DamageUpdateWithoutWeaponInput>, DamageUncheckedUpdateWithoutWeaponInput>
  }

  export type WeightUpdateOneRequiredWithoutWeaponNestedInput = {
    create?: XOR<WeightCreateWithoutWeaponInput, WeightUncheckedCreateWithoutWeaponInput>
    connectOrCreate?: WeightCreateOrConnectWithoutWeaponInput
    upsert?: WeightUpsertWithoutWeaponInput
    connect?: WeightWhereUniqueInput
    update?: XOR<XOR<WeightUpdateToOneWithWhereWithoutWeaponInput, WeightUpdateWithoutWeaponInput>, WeightUncheckedUpdateWithoutWeaponInput>
  }

  export type RangeUpdateOneRequiredWithoutWeaponNestedInput = {
    create?: XOR<RangeCreateWithoutWeaponInput, RangeUncheckedCreateWithoutWeaponInput>
    connectOrCreate?: RangeCreateOrConnectWithoutWeaponInput
    upsert?: RangeUpsertWithoutWeaponInput
    connect?: RangeWhereUniqueInput
    update?: XOR<XOR<RangeUpdateToOneWithWhereWithoutWeaponInput, RangeUpdateWithoutWeaponInput>, RangeUncheckedUpdateWithoutWeaponInput>
  }

  export type AmmoUpdateOneWithoutWeaponNestedInput = {
    create?: XOR<AmmoCreateWithoutWeaponInput, AmmoUncheckedCreateWithoutWeaponInput>
    connectOrCreate?: AmmoCreateOrConnectWithoutWeaponInput
    upsert?: AmmoUpsertWithoutWeaponInput
    disconnect?: AmmoWhereInput | boolean
    delete?: AmmoWhereInput | boolean
    connect?: AmmoWhereUniqueInput
    update?: XOR<XOR<AmmoUpdateToOneWithWhereWithoutWeaponInput, AmmoUpdateWithoutWeaponInput>, AmmoUncheckedUpdateWithoutWeaponInput>
  }

  export type CharacterUncheckedUpdateManyWithoutWeaponNestedInput = {
    create?: XOR<CharacterCreateWithoutWeaponInput, CharacterUncheckedCreateWithoutWeaponInput> | CharacterCreateWithoutWeaponInput[] | CharacterUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutWeaponInput | CharacterCreateOrConnectWithoutWeaponInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutWeaponInput | CharacterUpsertWithWhereUniqueWithoutWeaponInput[]
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutWeaponInput | CharacterUpdateWithWhereUniqueWithoutWeaponInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutWeaponInput | CharacterUpdateManyWithWhereWithoutWeaponInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type WeaponSkillUncheckedUpdateManyWithoutWeaponNestedInput = {
    create?: XOR<WeaponSkillCreateWithoutWeaponInput, WeaponSkillUncheckedCreateWithoutWeaponInput> | WeaponSkillCreateWithoutWeaponInput[] | WeaponSkillUncheckedCreateWithoutWeaponInput[]
    connectOrCreate?: WeaponSkillCreateOrConnectWithoutWeaponInput | WeaponSkillCreateOrConnectWithoutWeaponInput[]
    upsert?: WeaponSkillUpsertWithWhereUniqueWithoutWeaponInput | WeaponSkillUpsertWithWhereUniqueWithoutWeaponInput[]
    set?: WeaponSkillWhereUniqueInput | WeaponSkillWhereUniqueInput[]
    disconnect?: WeaponSkillWhereUniqueInput | WeaponSkillWhereUniqueInput[]
    delete?: WeaponSkillWhereUniqueInput | WeaponSkillWhereUniqueInput[]
    connect?: WeaponSkillWhereUniqueInput | WeaponSkillWhereUniqueInput[]
    update?: WeaponSkillUpdateWithWhereUniqueWithoutWeaponInput | WeaponSkillUpdateWithWhereUniqueWithoutWeaponInput[]
    updateMany?: WeaponSkillUpdateManyWithWhereWithoutWeaponInput | WeaponSkillUpdateManyWithWhereWithoutWeaponInput[]
    deleteMany?: WeaponSkillScalarWhereInput | WeaponSkillScalarWhereInput[]
  }

  export type WeaponCreateNestedManyWithoutWeaponSkillInput = {
    create?: XOR<WeaponCreateWithoutWeaponSkillInput, WeaponUncheckedCreateWithoutWeaponSkillInput> | WeaponCreateWithoutWeaponSkillInput[] | WeaponUncheckedCreateWithoutWeaponSkillInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutWeaponSkillInput | WeaponCreateOrConnectWithoutWeaponSkillInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type WeaponUncheckedCreateNestedManyWithoutWeaponSkillInput = {
    create?: XOR<WeaponCreateWithoutWeaponSkillInput, WeaponUncheckedCreateWithoutWeaponSkillInput> | WeaponCreateWithoutWeaponSkillInput[] | WeaponUncheckedCreateWithoutWeaponSkillInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutWeaponSkillInput | WeaponCreateOrConnectWithoutWeaponSkillInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type WeaponUpdateManyWithoutWeaponSkillNestedInput = {
    create?: XOR<WeaponCreateWithoutWeaponSkillInput, WeaponUncheckedCreateWithoutWeaponSkillInput> | WeaponCreateWithoutWeaponSkillInput[] | WeaponUncheckedCreateWithoutWeaponSkillInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutWeaponSkillInput | WeaponCreateOrConnectWithoutWeaponSkillInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutWeaponSkillInput | WeaponUpsertWithWhereUniqueWithoutWeaponSkillInput[]
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutWeaponSkillInput | WeaponUpdateWithWhereUniqueWithoutWeaponSkillInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutWeaponSkillInput | WeaponUpdateManyWithWhereWithoutWeaponSkillInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type WeaponUncheckedUpdateManyWithoutWeaponSkillNestedInput = {
    create?: XOR<WeaponCreateWithoutWeaponSkillInput, WeaponUncheckedCreateWithoutWeaponSkillInput> | WeaponCreateWithoutWeaponSkillInput[] | WeaponUncheckedCreateWithoutWeaponSkillInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutWeaponSkillInput | WeaponCreateOrConnectWithoutWeaponSkillInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutWeaponSkillInput | WeaponUpsertWithWhereUniqueWithoutWeaponSkillInput[]
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutWeaponSkillInput | WeaponUpdateWithWhereUniqueWithoutWeaponSkillInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutWeaponSkillInput | WeaponUpdateManyWithWhereWithoutWeaponSkillInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type WeaponCreateNestedManyWithoutDamageInput = {
    create?: XOR<WeaponCreateWithoutDamageInput, WeaponUncheckedCreateWithoutDamageInput> | WeaponCreateWithoutDamageInput[] | WeaponUncheckedCreateWithoutDamageInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutDamageInput | WeaponCreateOrConnectWithoutDamageInput[]
    createMany?: WeaponCreateManyDamageInputEnvelope
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type WeaponUncheckedCreateNestedManyWithoutDamageInput = {
    create?: XOR<WeaponCreateWithoutDamageInput, WeaponUncheckedCreateWithoutDamageInput> | WeaponCreateWithoutDamageInput[] | WeaponUncheckedCreateWithoutDamageInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutDamageInput | WeaponCreateOrConnectWithoutDamageInput[]
    createMany?: WeaponCreateManyDamageInputEnvelope
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type WeaponUpdateManyWithoutDamageNestedInput = {
    create?: XOR<WeaponCreateWithoutDamageInput, WeaponUncheckedCreateWithoutDamageInput> | WeaponCreateWithoutDamageInput[] | WeaponUncheckedCreateWithoutDamageInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutDamageInput | WeaponCreateOrConnectWithoutDamageInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutDamageInput | WeaponUpsertWithWhereUniqueWithoutDamageInput[]
    createMany?: WeaponCreateManyDamageInputEnvelope
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutDamageInput | WeaponUpdateWithWhereUniqueWithoutDamageInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutDamageInput | WeaponUpdateManyWithWhereWithoutDamageInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type WeaponUncheckedUpdateManyWithoutDamageNestedInput = {
    create?: XOR<WeaponCreateWithoutDamageInput, WeaponUncheckedCreateWithoutDamageInput> | WeaponCreateWithoutDamageInput[] | WeaponUncheckedCreateWithoutDamageInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutDamageInput | WeaponCreateOrConnectWithoutDamageInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutDamageInput | WeaponUpsertWithWhereUniqueWithoutDamageInput[]
    createMany?: WeaponCreateManyDamageInputEnvelope
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutDamageInput | WeaponUpdateWithWhereUniqueWithoutDamageInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutDamageInput | WeaponUpdateManyWithWhereWithoutDamageInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type WeaponCreateNestedManyWithoutWeightInput = {
    create?: XOR<WeaponCreateWithoutWeightInput, WeaponUncheckedCreateWithoutWeightInput> | WeaponCreateWithoutWeightInput[] | WeaponUncheckedCreateWithoutWeightInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutWeightInput | WeaponCreateOrConnectWithoutWeightInput[]
    createMany?: WeaponCreateManyWeightInputEnvelope
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type WeaponUncheckedCreateNestedManyWithoutWeightInput = {
    create?: XOR<WeaponCreateWithoutWeightInput, WeaponUncheckedCreateWithoutWeightInput> | WeaponCreateWithoutWeightInput[] | WeaponUncheckedCreateWithoutWeightInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutWeightInput | WeaponCreateOrConnectWithoutWeightInput[]
    createMany?: WeaponCreateManyWeightInputEnvelope
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type WeaponUpdateManyWithoutWeightNestedInput = {
    create?: XOR<WeaponCreateWithoutWeightInput, WeaponUncheckedCreateWithoutWeightInput> | WeaponCreateWithoutWeightInput[] | WeaponUncheckedCreateWithoutWeightInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutWeightInput | WeaponCreateOrConnectWithoutWeightInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutWeightInput | WeaponUpsertWithWhereUniqueWithoutWeightInput[]
    createMany?: WeaponCreateManyWeightInputEnvelope
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutWeightInput | WeaponUpdateWithWhereUniqueWithoutWeightInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutWeightInput | WeaponUpdateManyWithWhereWithoutWeightInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type WeaponUncheckedUpdateManyWithoutWeightNestedInput = {
    create?: XOR<WeaponCreateWithoutWeightInput, WeaponUncheckedCreateWithoutWeightInput> | WeaponCreateWithoutWeightInput[] | WeaponUncheckedCreateWithoutWeightInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutWeightInput | WeaponCreateOrConnectWithoutWeightInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutWeightInput | WeaponUpsertWithWhereUniqueWithoutWeightInput[]
    createMany?: WeaponCreateManyWeightInputEnvelope
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutWeightInput | WeaponUpdateWithWhereUniqueWithoutWeightInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutWeightInput | WeaponUpdateManyWithWhereWithoutWeightInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type WeaponCreateNestedManyWithoutAmmoInput = {
    create?: XOR<WeaponCreateWithoutAmmoInput, WeaponUncheckedCreateWithoutAmmoInput> | WeaponCreateWithoutAmmoInput[] | WeaponUncheckedCreateWithoutAmmoInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutAmmoInput | WeaponCreateOrConnectWithoutAmmoInput[]
    createMany?: WeaponCreateManyAmmoInputEnvelope
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type WeaponUncheckedCreateNestedManyWithoutAmmoInput = {
    create?: XOR<WeaponCreateWithoutAmmoInput, WeaponUncheckedCreateWithoutAmmoInput> | WeaponCreateWithoutAmmoInput[] | WeaponUncheckedCreateWithoutAmmoInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutAmmoInput | WeaponCreateOrConnectWithoutAmmoInput[]
    createMany?: WeaponCreateManyAmmoInputEnvelope
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type WeaponUpdateManyWithoutAmmoNestedInput = {
    create?: XOR<WeaponCreateWithoutAmmoInput, WeaponUncheckedCreateWithoutAmmoInput> | WeaponCreateWithoutAmmoInput[] | WeaponUncheckedCreateWithoutAmmoInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutAmmoInput | WeaponCreateOrConnectWithoutAmmoInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutAmmoInput | WeaponUpsertWithWhereUniqueWithoutAmmoInput[]
    createMany?: WeaponCreateManyAmmoInputEnvelope
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutAmmoInput | WeaponUpdateWithWhereUniqueWithoutAmmoInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutAmmoInput | WeaponUpdateManyWithWhereWithoutAmmoInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type WeaponUncheckedUpdateManyWithoutAmmoNestedInput = {
    create?: XOR<WeaponCreateWithoutAmmoInput, WeaponUncheckedCreateWithoutAmmoInput> | WeaponCreateWithoutAmmoInput[] | WeaponUncheckedCreateWithoutAmmoInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutAmmoInput | WeaponCreateOrConnectWithoutAmmoInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutAmmoInput | WeaponUpsertWithWhereUniqueWithoutAmmoInput[]
    createMany?: WeaponCreateManyAmmoInputEnvelope
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutAmmoInput | WeaponUpdateWithWhereUniqueWithoutAmmoInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutAmmoInput | WeaponUpdateManyWithWhereWithoutAmmoInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type WeaponCreateNestedManyWithoutRangeInput = {
    create?: XOR<WeaponCreateWithoutRangeInput, WeaponUncheckedCreateWithoutRangeInput> | WeaponCreateWithoutRangeInput[] | WeaponUncheckedCreateWithoutRangeInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutRangeInput | WeaponCreateOrConnectWithoutRangeInput[]
    createMany?: WeaponCreateManyRangeInputEnvelope
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type WeaponUncheckedCreateNestedManyWithoutRangeInput = {
    create?: XOR<WeaponCreateWithoutRangeInput, WeaponUncheckedCreateWithoutRangeInput> | WeaponCreateWithoutRangeInput[] | WeaponUncheckedCreateWithoutRangeInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutRangeInput | WeaponCreateOrConnectWithoutRangeInput[]
    createMany?: WeaponCreateManyRangeInputEnvelope
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
  }

  export type WeaponUpdateManyWithoutRangeNestedInput = {
    create?: XOR<WeaponCreateWithoutRangeInput, WeaponUncheckedCreateWithoutRangeInput> | WeaponCreateWithoutRangeInput[] | WeaponUncheckedCreateWithoutRangeInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutRangeInput | WeaponCreateOrConnectWithoutRangeInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutRangeInput | WeaponUpsertWithWhereUniqueWithoutRangeInput[]
    createMany?: WeaponCreateManyRangeInputEnvelope
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutRangeInput | WeaponUpdateWithWhereUniqueWithoutRangeInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutRangeInput | WeaponUpdateManyWithWhereWithoutRangeInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type WeaponUncheckedUpdateManyWithoutRangeNestedInput = {
    create?: XOR<WeaponCreateWithoutRangeInput, WeaponUncheckedCreateWithoutRangeInput> | WeaponCreateWithoutRangeInput[] | WeaponUncheckedCreateWithoutRangeInput[]
    connectOrCreate?: WeaponCreateOrConnectWithoutRangeInput | WeaponCreateOrConnectWithoutRangeInput[]
    upsert?: WeaponUpsertWithWhereUniqueWithoutRangeInput | WeaponUpsertWithWhereUniqueWithoutRangeInput[]
    createMany?: WeaponCreateManyRangeInputEnvelope
    set?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    disconnect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    delete?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    connect?: WeaponWhereUniqueInput | WeaponWhereUniqueInput[]
    update?: WeaponUpdateWithWhereUniqueWithoutRangeInput | WeaponUpdateWithWhereUniqueWithoutRangeInput[]
    updateMany?: WeaponUpdateManyWithWhereWithoutRangeInput | WeaponUpdateManyWithWhereWithoutRangeInput[]
    deleteMany?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
  }

  export type EnumSuggestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SuggestionType
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSuggestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SuggestionType | EnumSuggestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SuggestionType[] | ListEnumSuggestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SuggestionType[] | ListEnumSuggestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSuggestionTypeFilter<$PrismaModel> | $Enums.SuggestionType
  }

  export type NestedEnumSuggestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SuggestionType | EnumSuggestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SuggestionType[] | ListEnumSuggestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SuggestionType[] | ListEnumSuggestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSuggestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SuggestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSuggestionTypeFilter<$PrismaModel>
    _max?: NestedEnumSuggestionTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.Role
    sessions?: SessionCreateNestedManyWithoutUserInput
    Scenario?: ScenarioCreateNestedManyWithoutUserInput
    Weapon?: WeaponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.Role
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Scenario?: ScenarioUncheckedCreateNestedManyWithoutUserInput
    Weapon?: WeaponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Scenario?: ScenarioUpdateManyWithoutUserNestedInput
    Weapon?: WeaponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Scenario?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
    Weapon?: WeaponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountCreateNestedManyWithoutUserInput
    Scenario?: ScenarioCreateNestedManyWithoutUserInput
    Weapon?: WeaponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    Scenario?: ScenarioUncheckedCreateNestedManyWithoutUserInput
    Weapon?: WeaponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUpdateManyWithoutUserNestedInput
    Scenario?: ScenarioUpdateManyWithoutUserNestedInput
    Weapon?: WeaponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    Scenario?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
    Weapon?: WeaponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ScenarioCreateWithoutUserInput = {
    id?: string
    name: string
    universe: string
    description?: string | null
    character?: CharacterCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    universe: string
    description?: string | null
    character?: CharacterUncheckedCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioCreateOrConnectWithoutUserInput = {
    where: ScenarioWhereUniqueInput
    create: XOR<ScenarioCreateWithoutUserInput, ScenarioUncheckedCreateWithoutUserInput>
  }

  export type ScenarioCreateManyUserInputEnvelope = {
    data: ScenarioCreateManyUserInput | ScenarioCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WeaponCreateWithoutUserInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    character?: CharacterCreateNestedManyWithoutWeaponInput
    weaponSkill?: WeaponSkillCreateNestedManyWithoutWeaponInput
    damage: DamageCreateNestedOneWithoutWeaponInput
    weight: WeightCreateNestedOneWithoutWeaponInput
    range: RangeCreateNestedOneWithoutWeaponInput
    ammo?: AmmoCreateNestedOneWithoutWeaponInput
  }

  export type WeaponUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    damageId: string
    weightId: string
    rangeId: string
    ammoId?: string | null
    character?: CharacterUncheckedCreateNestedManyWithoutWeaponInput
    weaponSkill?: WeaponSkillUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type WeaponCreateOrConnectWithoutUserInput = {
    where: WeaponWhereUniqueInput
    create: XOR<WeaponCreateWithoutUserInput, WeaponUncheckedCreateWithoutUserInput>
  }

  export type WeaponCreateManyUserInputEnvelope = {
    data: WeaponCreateManyUserInput | WeaponCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type ScenarioUpsertWithWhereUniqueWithoutUserInput = {
    where: ScenarioWhereUniqueInput
    update: XOR<ScenarioUpdateWithoutUserInput, ScenarioUncheckedUpdateWithoutUserInput>
    create: XOR<ScenarioCreateWithoutUserInput, ScenarioUncheckedCreateWithoutUserInput>
  }

  export type ScenarioUpdateWithWhereUniqueWithoutUserInput = {
    where: ScenarioWhereUniqueInput
    data: XOR<ScenarioUpdateWithoutUserInput, ScenarioUncheckedUpdateWithoutUserInput>
  }

  export type ScenarioUpdateManyWithWhereWithoutUserInput = {
    where: ScenarioScalarWhereInput
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyWithoutUserInput>
  }

  export type ScenarioScalarWhereInput = {
    AND?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
    OR?: ScenarioScalarWhereInput[]
    NOT?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
    id?: StringFilter<"Scenario"> | string
    name?: StringFilter<"Scenario"> | string
    universe?: StringFilter<"Scenario"> | string
    description?: StringNullableFilter<"Scenario"> | string | null
    userId?: StringFilter<"Scenario"> | string
  }

  export type WeaponUpsertWithWhereUniqueWithoutUserInput = {
    where: WeaponWhereUniqueInput
    update: XOR<WeaponUpdateWithoutUserInput, WeaponUncheckedUpdateWithoutUserInput>
    create: XOR<WeaponCreateWithoutUserInput, WeaponUncheckedCreateWithoutUserInput>
  }

  export type WeaponUpdateWithWhereUniqueWithoutUserInput = {
    where: WeaponWhereUniqueInput
    data: XOR<WeaponUpdateWithoutUserInput, WeaponUncheckedUpdateWithoutUserInput>
  }

  export type WeaponUpdateManyWithWhereWithoutUserInput = {
    where: WeaponScalarWhereInput
    data: XOR<WeaponUpdateManyMutationInput, WeaponUncheckedUpdateManyWithoutUserInput>
  }

  export type WeaponScalarWhereInput = {
    AND?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
    OR?: WeaponScalarWhereInput[]
    NOT?: WeaponScalarWhereInput | WeaponScalarWhereInput[]
    id?: StringFilter<"Weapon"> | string
    name?: StringFilter<"Weapon"> | string
    melee?: BoolFilter<"Weapon"> | boolean
    description?: StringNullableFilter<"Weapon"> | string | null
    userId?: StringFilter<"Weapon"> | string
    damageId?: StringFilter<"Weapon"> | string
    weightId?: StringFilter<"Weapon"> | string
    rangeId?: StringFilter<"Weapon"> | string
    ammoId?: StringNullableFilter<"Weapon"> | string | null
  }

  export type UserCreateWithoutScenarioInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Weapon?: WeaponCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutScenarioInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Weapon?: WeaponUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutScenarioInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScenarioInput, UserUncheckedCreateWithoutScenarioInput>
  }

  export type CharacterCreateWithoutScenarioInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    weapon?: WeaponCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillCreateNestedManyWithoutCharacterInput
    strength?: StrengthCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessCreateNestedManyWithoutCharacterInput
    fortune?: FortuneCreateNestedOneWithoutCharacterInput
    alignment?: AlignmentCreateNestedOneWithoutCharacterInput
    temperment?: TempermentCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutScenarioInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    fortuneId?: string | null
    alignmentId?: string | null
    tempermentId?: string | null
    weapon?: WeaponUncheckedCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    strength?: StrengthUncheckedCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutScenarioInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutScenarioInput, CharacterUncheckedCreateWithoutScenarioInput>
  }

  export type UserUpsertWithoutScenarioInput = {
    update: XOR<UserUpdateWithoutScenarioInput, UserUncheckedUpdateWithoutScenarioInput>
    create: XOR<UserCreateWithoutScenarioInput, UserUncheckedCreateWithoutScenarioInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScenarioInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScenarioInput, UserUncheckedUpdateWithoutScenarioInput>
  }

  export type UserUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Weapon?: WeaponUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Weapon?: WeaponUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CharacterUpsertWithWhereUniqueWithoutScenarioInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutScenarioInput, CharacterUncheckedUpdateWithoutScenarioInput>
    create: XOR<CharacterCreateWithoutScenarioInput, CharacterUncheckedCreateWithoutScenarioInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutScenarioInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutScenarioInput, CharacterUncheckedUpdateWithoutScenarioInput>
  }

  export type CharacterUpdateManyWithWhereWithoutScenarioInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutScenarioInput>
  }

  export type CharacterScalarWhereInput = {
    AND?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    OR?: CharacterScalarWhereInput[]
    NOT?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    id?: StringFilter<"Character"> | string
    name?: StringFilter<"Character"> | string
    pj?: BoolFilter<"Character"> | boolean
    age?: IntNullableFilter<"Character"> | number | null
    image?: StringNullableFilter<"Character"> | string | null
    origin?: StringNullableFilter<"Character"> | string | null
    role?: StringNullableFilter<"Character"> | string | null
    injury?: StringNullableFilter<"Character"> | string | null
    extra?: StringNullableFilter<"Character"> | string | null
    fortuneId?: StringNullableFilter<"Character"> | string | null
    alignmentId?: StringNullableFilter<"Character"> | string | null
    tempermentId?: StringNullableFilter<"Character"> | string | null
  }

  export type WeaponCreateWithoutCharacterInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    weaponSkill?: WeaponSkillCreateNestedManyWithoutWeaponInput
    user: UserCreateNestedOneWithoutWeaponInput
    damage: DamageCreateNestedOneWithoutWeaponInput
    weight: WeightCreateNestedOneWithoutWeaponInput
    range: RangeCreateNestedOneWithoutWeaponInput
    ammo?: AmmoCreateNestedOneWithoutWeaponInput
  }

  export type WeaponUncheckedCreateWithoutCharacterInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    userId: string
    damageId: string
    weightId: string
    rangeId: string
    ammoId?: string | null
    weaponSkill?: WeaponSkillUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type WeaponCreateOrConnectWithoutCharacterInput = {
    where: WeaponWhereUniqueInput
    create: XOR<WeaponCreateWithoutCharacterInput, WeaponUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterSkillCreateWithoutCharacterInput = {
    id?: string
    name: string
  }

  export type CharacterSkillUncheckedCreateWithoutCharacterInput = {
    id?: string
    name: string
  }

  export type CharacterSkillCreateOrConnectWithoutCharacterInput = {
    where: CharacterSkillWhereUniqueInput
    create: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput>
  }

  export type ScenarioCreateWithoutCharacterInput = {
    id?: string
    name: string
    universe: string
    description?: string | null
    user: UserCreateNestedOneWithoutScenarioInput
  }

  export type ScenarioUncheckedCreateWithoutCharacterInput = {
    id?: string
    name: string
    universe: string
    description?: string | null
    userId: string
  }

  export type ScenarioCreateOrConnectWithoutCharacterInput = {
    where: ScenarioWhereUniqueInput
    create: XOR<ScenarioCreateWithoutCharacterInput, ScenarioUncheckedCreateWithoutCharacterInput>
  }

  export type StrengthCreateWithoutCharacterInput = {
    id?: string
    name: string
  }

  export type StrengthUncheckedCreateWithoutCharacterInput = {
    id?: string
    name: string
  }

  export type StrengthCreateOrConnectWithoutCharacterInput = {
    where: StrengthWhereUniqueInput
    create: XOR<StrengthCreateWithoutCharacterInput, StrengthUncheckedCreateWithoutCharacterInput>
  }

  export type WeaknessCreateWithoutCharacterInput = {
    id?: string
    name: string
  }

  export type WeaknessUncheckedCreateWithoutCharacterInput = {
    id?: string
    name: string
  }

  export type WeaknessCreateOrConnectWithoutCharacterInput = {
    where: WeaknessWhereUniqueInput
    create: XOR<WeaknessCreateWithoutCharacterInput, WeaknessUncheckedCreateWithoutCharacterInput>
  }

  export type FortuneCreateWithoutCharacterInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type FortuneUncheckedCreateWithoutCharacterInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type FortuneCreateOrConnectWithoutCharacterInput = {
    where: FortuneWhereUniqueInput
    create: XOR<FortuneCreateWithoutCharacterInput, FortuneUncheckedCreateWithoutCharacterInput>
  }

  export type AlignmentCreateWithoutCharacterInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type AlignmentUncheckedCreateWithoutCharacterInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type AlignmentCreateOrConnectWithoutCharacterInput = {
    where: AlignmentWhereUniqueInput
    create: XOR<AlignmentCreateWithoutCharacterInput, AlignmentUncheckedCreateWithoutCharacterInput>
  }

  export type TempermentCreateWithoutCharacterInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type TempermentUncheckedCreateWithoutCharacterInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type TempermentCreateOrConnectWithoutCharacterInput = {
    where: TempermentWhereUniqueInput
    create: XOR<TempermentCreateWithoutCharacterInput, TempermentUncheckedCreateWithoutCharacterInput>
  }

  export type WeaponUpsertWithWhereUniqueWithoutCharacterInput = {
    where: WeaponWhereUniqueInput
    update: XOR<WeaponUpdateWithoutCharacterInput, WeaponUncheckedUpdateWithoutCharacterInput>
    create: XOR<WeaponCreateWithoutCharacterInput, WeaponUncheckedCreateWithoutCharacterInput>
  }

  export type WeaponUpdateWithWhereUniqueWithoutCharacterInput = {
    where: WeaponWhereUniqueInput
    data: XOR<WeaponUpdateWithoutCharacterInput, WeaponUncheckedUpdateWithoutCharacterInput>
  }

  export type WeaponUpdateManyWithWhereWithoutCharacterInput = {
    where: WeaponScalarWhereInput
    data: XOR<WeaponUpdateManyMutationInput, WeaponUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterSkillWhereUniqueInput
    update: XOR<CharacterSkillUpdateWithoutCharacterInput, CharacterSkillUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterSkillWhereUniqueInput
    data: XOR<CharacterSkillUpdateWithoutCharacterInput, CharacterSkillUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterSkillUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterSkillScalarWhereInput
    data: XOR<CharacterSkillUpdateManyMutationInput, CharacterSkillUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterSkillScalarWhereInput = {
    AND?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
    OR?: CharacterSkillScalarWhereInput[]
    NOT?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
    id?: StringFilter<"CharacterSkill"> | string
    name?: StringFilter<"CharacterSkill"> | string
  }

  export type ScenarioUpsertWithWhereUniqueWithoutCharacterInput = {
    where: ScenarioWhereUniqueInput
    update: XOR<ScenarioUpdateWithoutCharacterInput, ScenarioUncheckedUpdateWithoutCharacterInput>
    create: XOR<ScenarioCreateWithoutCharacterInput, ScenarioUncheckedCreateWithoutCharacterInput>
  }

  export type ScenarioUpdateWithWhereUniqueWithoutCharacterInput = {
    where: ScenarioWhereUniqueInput
    data: XOR<ScenarioUpdateWithoutCharacterInput, ScenarioUncheckedUpdateWithoutCharacterInput>
  }

  export type ScenarioUpdateManyWithWhereWithoutCharacterInput = {
    where: ScenarioScalarWhereInput
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyWithoutCharacterInput>
  }

  export type StrengthUpsertWithWhereUniqueWithoutCharacterInput = {
    where: StrengthWhereUniqueInput
    update: XOR<StrengthUpdateWithoutCharacterInput, StrengthUncheckedUpdateWithoutCharacterInput>
    create: XOR<StrengthCreateWithoutCharacterInput, StrengthUncheckedCreateWithoutCharacterInput>
  }

  export type StrengthUpdateWithWhereUniqueWithoutCharacterInput = {
    where: StrengthWhereUniqueInput
    data: XOR<StrengthUpdateWithoutCharacterInput, StrengthUncheckedUpdateWithoutCharacterInput>
  }

  export type StrengthUpdateManyWithWhereWithoutCharacterInput = {
    where: StrengthScalarWhereInput
    data: XOR<StrengthUpdateManyMutationInput, StrengthUncheckedUpdateManyWithoutCharacterInput>
  }

  export type StrengthScalarWhereInput = {
    AND?: StrengthScalarWhereInput | StrengthScalarWhereInput[]
    OR?: StrengthScalarWhereInput[]
    NOT?: StrengthScalarWhereInput | StrengthScalarWhereInput[]
    id?: StringFilter<"Strength"> | string
    name?: StringFilter<"Strength"> | string
  }

  export type WeaknessUpsertWithWhereUniqueWithoutCharacterInput = {
    where: WeaknessWhereUniqueInput
    update: XOR<WeaknessUpdateWithoutCharacterInput, WeaknessUncheckedUpdateWithoutCharacterInput>
    create: XOR<WeaknessCreateWithoutCharacterInput, WeaknessUncheckedCreateWithoutCharacterInput>
  }

  export type WeaknessUpdateWithWhereUniqueWithoutCharacterInput = {
    where: WeaknessWhereUniqueInput
    data: XOR<WeaknessUpdateWithoutCharacterInput, WeaknessUncheckedUpdateWithoutCharacterInput>
  }

  export type WeaknessUpdateManyWithWhereWithoutCharacterInput = {
    where: WeaknessScalarWhereInput
    data: XOR<WeaknessUpdateManyMutationInput, WeaknessUncheckedUpdateManyWithoutCharacterInput>
  }

  export type WeaknessScalarWhereInput = {
    AND?: WeaknessScalarWhereInput | WeaknessScalarWhereInput[]
    OR?: WeaknessScalarWhereInput[]
    NOT?: WeaknessScalarWhereInput | WeaknessScalarWhereInput[]
    id?: StringFilter<"Weakness"> | string
    name?: StringFilter<"Weakness"> | string
  }

  export type FortuneUpsertWithoutCharacterInput = {
    update: XOR<FortuneUpdateWithoutCharacterInput, FortuneUncheckedUpdateWithoutCharacterInput>
    create: XOR<FortuneCreateWithoutCharacterInput, FortuneUncheckedCreateWithoutCharacterInput>
    where?: FortuneWhereInput
  }

  export type FortuneUpdateToOneWithWhereWithoutCharacterInput = {
    where?: FortuneWhereInput
    data: XOR<FortuneUpdateWithoutCharacterInput, FortuneUncheckedUpdateWithoutCharacterInput>
  }

  export type FortuneUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FortuneUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlignmentUpsertWithoutCharacterInput = {
    update: XOR<AlignmentUpdateWithoutCharacterInput, AlignmentUncheckedUpdateWithoutCharacterInput>
    create: XOR<AlignmentCreateWithoutCharacterInput, AlignmentUncheckedCreateWithoutCharacterInput>
    where?: AlignmentWhereInput
  }

  export type AlignmentUpdateToOneWithWhereWithoutCharacterInput = {
    where?: AlignmentWhereInput
    data: XOR<AlignmentUpdateWithoutCharacterInput, AlignmentUncheckedUpdateWithoutCharacterInput>
  }

  export type AlignmentUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlignmentUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TempermentUpsertWithoutCharacterInput = {
    update: XOR<TempermentUpdateWithoutCharacterInput, TempermentUncheckedUpdateWithoutCharacterInput>
    create: XOR<TempermentCreateWithoutCharacterInput, TempermentUncheckedCreateWithoutCharacterInput>
    where?: TempermentWhereInput
  }

  export type TempermentUpdateToOneWithWhereWithoutCharacterInput = {
    where?: TempermentWhereInput
    data: XOR<TempermentUpdateWithoutCharacterInput, TempermentUncheckedUpdateWithoutCharacterInput>
  }

  export type TempermentUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TempermentUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterCreateWithoutSkillSetInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    weapon?: WeaponCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioCreateNestedManyWithoutCharacterInput
    strength?: StrengthCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessCreateNestedManyWithoutCharacterInput
    fortune?: FortuneCreateNestedOneWithoutCharacterInput
    alignment?: AlignmentCreateNestedOneWithoutCharacterInput
    temperment?: TempermentCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutSkillSetInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    fortuneId?: string | null
    alignmentId?: string | null
    tempermentId?: string | null
    weapon?: WeaponUncheckedCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioUncheckedCreateNestedManyWithoutCharacterInput
    strength?: StrengthUncheckedCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutSkillSetInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutSkillSetInput, CharacterUncheckedCreateWithoutSkillSetInput>
  }

  export type CharacterUpsertWithWhereUniqueWithoutSkillSetInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutSkillSetInput, CharacterUncheckedUpdateWithoutSkillSetInput>
    create: XOR<CharacterCreateWithoutSkillSetInput, CharacterUncheckedCreateWithoutSkillSetInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutSkillSetInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutSkillSetInput, CharacterUncheckedUpdateWithoutSkillSetInput>
  }

  export type CharacterUpdateManyWithWhereWithoutSkillSetInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutSkillSetInput>
  }

  export type CharacterCreateWithoutFortuneInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    weapon?: WeaponCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioCreateNestedManyWithoutCharacterInput
    strength?: StrengthCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessCreateNestedManyWithoutCharacterInput
    alignment?: AlignmentCreateNestedOneWithoutCharacterInput
    temperment?: TempermentCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutFortuneInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    alignmentId?: string | null
    tempermentId?: string | null
    weapon?: WeaponUncheckedCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioUncheckedCreateNestedManyWithoutCharacterInput
    strength?: StrengthUncheckedCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutFortuneInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutFortuneInput, CharacterUncheckedCreateWithoutFortuneInput>
  }

  export type CharacterCreateManyFortuneInputEnvelope = {
    data: CharacterCreateManyFortuneInput | CharacterCreateManyFortuneInput[]
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithWhereUniqueWithoutFortuneInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutFortuneInput, CharacterUncheckedUpdateWithoutFortuneInput>
    create: XOR<CharacterCreateWithoutFortuneInput, CharacterUncheckedCreateWithoutFortuneInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutFortuneInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutFortuneInput, CharacterUncheckedUpdateWithoutFortuneInput>
  }

  export type CharacterUpdateManyWithWhereWithoutFortuneInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutFortuneInput>
  }

  export type CharacterCreateWithoutAlignmentInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    weapon?: WeaponCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioCreateNestedManyWithoutCharacterInput
    strength?: StrengthCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessCreateNestedManyWithoutCharacterInput
    fortune?: FortuneCreateNestedOneWithoutCharacterInput
    temperment?: TempermentCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutAlignmentInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    fortuneId?: string | null
    tempermentId?: string | null
    weapon?: WeaponUncheckedCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioUncheckedCreateNestedManyWithoutCharacterInput
    strength?: StrengthUncheckedCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutAlignmentInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutAlignmentInput, CharacterUncheckedCreateWithoutAlignmentInput>
  }

  export type CharacterCreateManyAlignmentInputEnvelope = {
    data: CharacterCreateManyAlignmentInput | CharacterCreateManyAlignmentInput[]
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithWhereUniqueWithoutAlignmentInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutAlignmentInput, CharacterUncheckedUpdateWithoutAlignmentInput>
    create: XOR<CharacterCreateWithoutAlignmentInput, CharacterUncheckedCreateWithoutAlignmentInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutAlignmentInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutAlignmentInput, CharacterUncheckedUpdateWithoutAlignmentInput>
  }

  export type CharacterUpdateManyWithWhereWithoutAlignmentInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutAlignmentInput>
  }

  export type CharacterCreateWithoutTempermentInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    weapon?: WeaponCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioCreateNestedManyWithoutCharacterInput
    strength?: StrengthCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessCreateNestedManyWithoutCharacterInput
    fortune?: FortuneCreateNestedOneWithoutCharacterInput
    alignment?: AlignmentCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutTempermentInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    fortuneId?: string | null
    alignmentId?: string | null
    weapon?: WeaponUncheckedCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioUncheckedCreateNestedManyWithoutCharacterInput
    strength?: StrengthUncheckedCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutTempermentInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutTempermentInput, CharacterUncheckedCreateWithoutTempermentInput>
  }

  export type CharacterCreateManyTempermentInputEnvelope = {
    data: CharacterCreateManyTempermentInput | CharacterCreateManyTempermentInput[]
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithWhereUniqueWithoutTempermentInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutTempermentInput, CharacterUncheckedUpdateWithoutTempermentInput>
    create: XOR<CharacterCreateWithoutTempermentInput, CharacterUncheckedCreateWithoutTempermentInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutTempermentInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutTempermentInput, CharacterUncheckedUpdateWithoutTempermentInput>
  }

  export type CharacterUpdateManyWithWhereWithoutTempermentInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutTempermentInput>
  }

  export type CharacterCreateWithoutStrengthInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    weapon?: WeaponCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessCreateNestedManyWithoutCharacterInput
    fortune?: FortuneCreateNestedOneWithoutCharacterInput
    alignment?: AlignmentCreateNestedOneWithoutCharacterInput
    temperment?: TempermentCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutStrengthInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    fortuneId?: string | null
    alignmentId?: string | null
    tempermentId?: string | null
    weapon?: WeaponUncheckedCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioUncheckedCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutStrengthInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutStrengthInput, CharacterUncheckedCreateWithoutStrengthInput>
  }

  export type CharacterUpsertWithWhereUniqueWithoutStrengthInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutStrengthInput, CharacterUncheckedUpdateWithoutStrengthInput>
    create: XOR<CharacterCreateWithoutStrengthInput, CharacterUncheckedCreateWithoutStrengthInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutStrengthInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutStrengthInput, CharacterUncheckedUpdateWithoutStrengthInput>
  }

  export type CharacterUpdateManyWithWhereWithoutStrengthInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutStrengthInput>
  }

  export type CharacterCreateWithoutWeaknessInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    weapon?: WeaponCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioCreateNestedManyWithoutCharacterInput
    strength?: StrengthCreateNestedManyWithoutCharacterInput
    fortune?: FortuneCreateNestedOneWithoutCharacterInput
    alignment?: AlignmentCreateNestedOneWithoutCharacterInput
    temperment?: TempermentCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutWeaknessInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    fortuneId?: string | null
    alignmentId?: string | null
    tempermentId?: string | null
    weapon?: WeaponUncheckedCreateNestedManyWithoutCharacterInput
    skillSet?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioUncheckedCreateNestedManyWithoutCharacterInput
    strength?: StrengthUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutWeaknessInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutWeaknessInput, CharacterUncheckedCreateWithoutWeaknessInput>
  }

  export type CharacterUpsertWithWhereUniqueWithoutWeaknessInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutWeaknessInput, CharacterUncheckedUpdateWithoutWeaknessInput>
    create: XOR<CharacterCreateWithoutWeaknessInput, CharacterUncheckedCreateWithoutWeaknessInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutWeaknessInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutWeaknessInput, CharacterUncheckedUpdateWithoutWeaknessInput>
  }

  export type CharacterUpdateManyWithWhereWithoutWeaknessInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutWeaknessInput>
  }

  export type CharacterCreateWithoutWeaponInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    skillSet?: CharacterSkillCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioCreateNestedManyWithoutCharacterInput
    strength?: StrengthCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessCreateNestedManyWithoutCharacterInput
    fortune?: FortuneCreateNestedOneWithoutCharacterInput
    alignment?: AlignmentCreateNestedOneWithoutCharacterInput
    temperment?: TempermentCreateNestedOneWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutWeaponInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    fortuneId?: string | null
    alignmentId?: string | null
    tempermentId?: string | null
    skillSet?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    scenario?: ScenarioUncheckedCreateNestedManyWithoutCharacterInput
    strength?: StrengthUncheckedCreateNestedManyWithoutCharacterInput
    weakness?: WeaknessUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutWeaponInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutWeaponInput, CharacterUncheckedCreateWithoutWeaponInput>
  }

  export type WeaponSkillCreateWithoutWeaponInput = {
    id?: string
    name: string
  }

  export type WeaponSkillUncheckedCreateWithoutWeaponInput = {
    id?: string
    name: string
  }

  export type WeaponSkillCreateOrConnectWithoutWeaponInput = {
    where: WeaponSkillWhereUniqueInput
    create: XOR<WeaponSkillCreateWithoutWeaponInput, WeaponSkillUncheckedCreateWithoutWeaponInput>
  }

  export type UserCreateWithoutWeaponInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Scenario?: ScenarioCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWeaponInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    role?: $Enums.Role
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Scenario?: ScenarioUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWeaponInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWeaponInput, UserUncheckedCreateWithoutWeaponInput>
  }

  export type DamageCreateWithoutWeaponInput = {
    id?: string
    name: string
  }

  export type DamageUncheckedCreateWithoutWeaponInput = {
    id?: string
    name: string
  }

  export type DamageCreateOrConnectWithoutWeaponInput = {
    where: DamageWhereUniqueInput
    create: XOR<DamageCreateWithoutWeaponInput, DamageUncheckedCreateWithoutWeaponInput>
  }

  export type WeightCreateWithoutWeaponInput = {
    id?: string
    name: string
  }

  export type WeightUncheckedCreateWithoutWeaponInput = {
    id?: string
    name: string
  }

  export type WeightCreateOrConnectWithoutWeaponInput = {
    where: WeightWhereUniqueInput
    create: XOR<WeightCreateWithoutWeaponInput, WeightUncheckedCreateWithoutWeaponInput>
  }

  export type RangeCreateWithoutWeaponInput = {
    id?: string
    name: string
  }

  export type RangeUncheckedCreateWithoutWeaponInput = {
    id?: string
    name: string
  }

  export type RangeCreateOrConnectWithoutWeaponInput = {
    where: RangeWhereUniqueInput
    create: XOR<RangeCreateWithoutWeaponInput, RangeUncheckedCreateWithoutWeaponInput>
  }

  export type AmmoCreateWithoutWeaponInput = {
    id?: string
    name: string
  }

  export type AmmoUncheckedCreateWithoutWeaponInput = {
    id?: string
    name: string
  }

  export type AmmoCreateOrConnectWithoutWeaponInput = {
    where: AmmoWhereUniqueInput
    create: XOR<AmmoCreateWithoutWeaponInput, AmmoUncheckedCreateWithoutWeaponInput>
  }

  export type CharacterUpsertWithWhereUniqueWithoutWeaponInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutWeaponInput, CharacterUncheckedUpdateWithoutWeaponInput>
    create: XOR<CharacterCreateWithoutWeaponInput, CharacterUncheckedCreateWithoutWeaponInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutWeaponInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutWeaponInput, CharacterUncheckedUpdateWithoutWeaponInput>
  }

  export type CharacterUpdateManyWithWhereWithoutWeaponInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutWeaponInput>
  }

  export type WeaponSkillUpsertWithWhereUniqueWithoutWeaponInput = {
    where: WeaponSkillWhereUniqueInput
    update: XOR<WeaponSkillUpdateWithoutWeaponInput, WeaponSkillUncheckedUpdateWithoutWeaponInput>
    create: XOR<WeaponSkillCreateWithoutWeaponInput, WeaponSkillUncheckedCreateWithoutWeaponInput>
  }

  export type WeaponSkillUpdateWithWhereUniqueWithoutWeaponInput = {
    where: WeaponSkillWhereUniqueInput
    data: XOR<WeaponSkillUpdateWithoutWeaponInput, WeaponSkillUncheckedUpdateWithoutWeaponInput>
  }

  export type WeaponSkillUpdateManyWithWhereWithoutWeaponInput = {
    where: WeaponSkillScalarWhereInput
    data: XOR<WeaponSkillUpdateManyMutationInput, WeaponSkillUncheckedUpdateManyWithoutWeaponInput>
  }

  export type WeaponSkillScalarWhereInput = {
    AND?: WeaponSkillScalarWhereInput | WeaponSkillScalarWhereInput[]
    OR?: WeaponSkillScalarWhereInput[]
    NOT?: WeaponSkillScalarWhereInput | WeaponSkillScalarWhereInput[]
    id?: StringFilter<"WeaponSkill"> | string
    name?: StringFilter<"WeaponSkill"> | string
  }

  export type UserUpsertWithoutWeaponInput = {
    update: XOR<UserUpdateWithoutWeaponInput, UserUncheckedUpdateWithoutWeaponInput>
    create: XOR<UserCreateWithoutWeaponInput, UserUncheckedCreateWithoutWeaponInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWeaponInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWeaponInput, UserUncheckedUpdateWithoutWeaponInput>
  }

  export type UserUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Scenario?: ScenarioUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Scenario?: ScenarioUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DamageUpsertWithoutWeaponInput = {
    update: XOR<DamageUpdateWithoutWeaponInput, DamageUncheckedUpdateWithoutWeaponInput>
    create: XOR<DamageCreateWithoutWeaponInput, DamageUncheckedCreateWithoutWeaponInput>
    where?: DamageWhereInput
  }

  export type DamageUpdateToOneWithWhereWithoutWeaponInput = {
    where?: DamageWhereInput
    data: XOR<DamageUpdateWithoutWeaponInput, DamageUncheckedUpdateWithoutWeaponInput>
  }

  export type DamageUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DamageUncheckedUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeightUpsertWithoutWeaponInput = {
    update: XOR<WeightUpdateWithoutWeaponInput, WeightUncheckedUpdateWithoutWeaponInput>
    create: XOR<WeightCreateWithoutWeaponInput, WeightUncheckedCreateWithoutWeaponInput>
    where?: WeightWhereInput
  }

  export type WeightUpdateToOneWithWhereWithoutWeaponInput = {
    where?: WeightWhereInput
    data: XOR<WeightUpdateWithoutWeaponInput, WeightUncheckedUpdateWithoutWeaponInput>
  }

  export type WeightUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeightUncheckedUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RangeUpsertWithoutWeaponInput = {
    update: XOR<RangeUpdateWithoutWeaponInput, RangeUncheckedUpdateWithoutWeaponInput>
    create: XOR<RangeCreateWithoutWeaponInput, RangeUncheckedCreateWithoutWeaponInput>
    where?: RangeWhereInput
  }

  export type RangeUpdateToOneWithWhereWithoutWeaponInput = {
    where?: RangeWhereInput
    data: XOR<RangeUpdateWithoutWeaponInput, RangeUncheckedUpdateWithoutWeaponInput>
  }

  export type RangeUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RangeUncheckedUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AmmoUpsertWithoutWeaponInput = {
    update: XOR<AmmoUpdateWithoutWeaponInput, AmmoUncheckedUpdateWithoutWeaponInput>
    create: XOR<AmmoCreateWithoutWeaponInput, AmmoUncheckedCreateWithoutWeaponInput>
    where?: AmmoWhereInput
  }

  export type AmmoUpdateToOneWithWhereWithoutWeaponInput = {
    where?: AmmoWhereInput
    data: XOR<AmmoUpdateWithoutWeaponInput, AmmoUncheckedUpdateWithoutWeaponInput>
  }

  export type AmmoUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AmmoUncheckedUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeaponCreateWithoutWeaponSkillInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    character?: CharacterCreateNestedManyWithoutWeaponInput
    user: UserCreateNestedOneWithoutWeaponInput
    damage: DamageCreateNestedOneWithoutWeaponInput
    weight: WeightCreateNestedOneWithoutWeaponInput
    range: RangeCreateNestedOneWithoutWeaponInput
    ammo?: AmmoCreateNestedOneWithoutWeaponInput
  }

  export type WeaponUncheckedCreateWithoutWeaponSkillInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    userId: string
    damageId: string
    weightId: string
    rangeId: string
    ammoId?: string | null
    character?: CharacterUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type WeaponCreateOrConnectWithoutWeaponSkillInput = {
    where: WeaponWhereUniqueInput
    create: XOR<WeaponCreateWithoutWeaponSkillInput, WeaponUncheckedCreateWithoutWeaponSkillInput>
  }

  export type WeaponUpsertWithWhereUniqueWithoutWeaponSkillInput = {
    where: WeaponWhereUniqueInput
    update: XOR<WeaponUpdateWithoutWeaponSkillInput, WeaponUncheckedUpdateWithoutWeaponSkillInput>
    create: XOR<WeaponCreateWithoutWeaponSkillInput, WeaponUncheckedCreateWithoutWeaponSkillInput>
  }

  export type WeaponUpdateWithWhereUniqueWithoutWeaponSkillInput = {
    where: WeaponWhereUniqueInput
    data: XOR<WeaponUpdateWithoutWeaponSkillInput, WeaponUncheckedUpdateWithoutWeaponSkillInput>
  }

  export type WeaponUpdateManyWithWhereWithoutWeaponSkillInput = {
    where: WeaponScalarWhereInput
    data: XOR<WeaponUpdateManyMutationInput, WeaponUncheckedUpdateManyWithoutWeaponSkillInput>
  }

  export type WeaponCreateWithoutDamageInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    character?: CharacterCreateNestedManyWithoutWeaponInput
    weaponSkill?: WeaponSkillCreateNestedManyWithoutWeaponInput
    user: UserCreateNestedOneWithoutWeaponInput
    weight: WeightCreateNestedOneWithoutWeaponInput
    range: RangeCreateNestedOneWithoutWeaponInput
    ammo?: AmmoCreateNestedOneWithoutWeaponInput
  }

  export type WeaponUncheckedCreateWithoutDamageInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    userId: string
    weightId: string
    rangeId: string
    ammoId?: string | null
    character?: CharacterUncheckedCreateNestedManyWithoutWeaponInput
    weaponSkill?: WeaponSkillUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type WeaponCreateOrConnectWithoutDamageInput = {
    where: WeaponWhereUniqueInput
    create: XOR<WeaponCreateWithoutDamageInput, WeaponUncheckedCreateWithoutDamageInput>
  }

  export type WeaponCreateManyDamageInputEnvelope = {
    data: WeaponCreateManyDamageInput | WeaponCreateManyDamageInput[]
    skipDuplicates?: boolean
  }

  export type WeaponUpsertWithWhereUniqueWithoutDamageInput = {
    where: WeaponWhereUniqueInput
    update: XOR<WeaponUpdateWithoutDamageInput, WeaponUncheckedUpdateWithoutDamageInput>
    create: XOR<WeaponCreateWithoutDamageInput, WeaponUncheckedCreateWithoutDamageInput>
  }

  export type WeaponUpdateWithWhereUniqueWithoutDamageInput = {
    where: WeaponWhereUniqueInput
    data: XOR<WeaponUpdateWithoutDamageInput, WeaponUncheckedUpdateWithoutDamageInput>
  }

  export type WeaponUpdateManyWithWhereWithoutDamageInput = {
    where: WeaponScalarWhereInput
    data: XOR<WeaponUpdateManyMutationInput, WeaponUncheckedUpdateManyWithoutDamageInput>
  }

  export type WeaponCreateWithoutWeightInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    character?: CharacterCreateNestedManyWithoutWeaponInput
    weaponSkill?: WeaponSkillCreateNestedManyWithoutWeaponInput
    user: UserCreateNestedOneWithoutWeaponInput
    damage: DamageCreateNestedOneWithoutWeaponInput
    range: RangeCreateNestedOneWithoutWeaponInput
    ammo?: AmmoCreateNestedOneWithoutWeaponInput
  }

  export type WeaponUncheckedCreateWithoutWeightInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    userId: string
    damageId: string
    rangeId: string
    ammoId?: string | null
    character?: CharacterUncheckedCreateNestedManyWithoutWeaponInput
    weaponSkill?: WeaponSkillUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type WeaponCreateOrConnectWithoutWeightInput = {
    where: WeaponWhereUniqueInput
    create: XOR<WeaponCreateWithoutWeightInput, WeaponUncheckedCreateWithoutWeightInput>
  }

  export type WeaponCreateManyWeightInputEnvelope = {
    data: WeaponCreateManyWeightInput | WeaponCreateManyWeightInput[]
    skipDuplicates?: boolean
  }

  export type WeaponUpsertWithWhereUniqueWithoutWeightInput = {
    where: WeaponWhereUniqueInput
    update: XOR<WeaponUpdateWithoutWeightInput, WeaponUncheckedUpdateWithoutWeightInput>
    create: XOR<WeaponCreateWithoutWeightInput, WeaponUncheckedCreateWithoutWeightInput>
  }

  export type WeaponUpdateWithWhereUniqueWithoutWeightInput = {
    where: WeaponWhereUniqueInput
    data: XOR<WeaponUpdateWithoutWeightInput, WeaponUncheckedUpdateWithoutWeightInput>
  }

  export type WeaponUpdateManyWithWhereWithoutWeightInput = {
    where: WeaponScalarWhereInput
    data: XOR<WeaponUpdateManyMutationInput, WeaponUncheckedUpdateManyWithoutWeightInput>
  }

  export type WeaponCreateWithoutAmmoInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    character?: CharacterCreateNestedManyWithoutWeaponInput
    weaponSkill?: WeaponSkillCreateNestedManyWithoutWeaponInput
    user: UserCreateNestedOneWithoutWeaponInput
    damage: DamageCreateNestedOneWithoutWeaponInput
    weight: WeightCreateNestedOneWithoutWeaponInput
    range: RangeCreateNestedOneWithoutWeaponInput
  }

  export type WeaponUncheckedCreateWithoutAmmoInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    userId: string
    damageId: string
    weightId: string
    rangeId: string
    character?: CharacterUncheckedCreateNestedManyWithoutWeaponInput
    weaponSkill?: WeaponSkillUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type WeaponCreateOrConnectWithoutAmmoInput = {
    where: WeaponWhereUniqueInput
    create: XOR<WeaponCreateWithoutAmmoInput, WeaponUncheckedCreateWithoutAmmoInput>
  }

  export type WeaponCreateManyAmmoInputEnvelope = {
    data: WeaponCreateManyAmmoInput | WeaponCreateManyAmmoInput[]
    skipDuplicates?: boolean
  }

  export type WeaponUpsertWithWhereUniqueWithoutAmmoInput = {
    where: WeaponWhereUniqueInput
    update: XOR<WeaponUpdateWithoutAmmoInput, WeaponUncheckedUpdateWithoutAmmoInput>
    create: XOR<WeaponCreateWithoutAmmoInput, WeaponUncheckedCreateWithoutAmmoInput>
  }

  export type WeaponUpdateWithWhereUniqueWithoutAmmoInput = {
    where: WeaponWhereUniqueInput
    data: XOR<WeaponUpdateWithoutAmmoInput, WeaponUncheckedUpdateWithoutAmmoInput>
  }

  export type WeaponUpdateManyWithWhereWithoutAmmoInput = {
    where: WeaponScalarWhereInput
    data: XOR<WeaponUpdateManyMutationInput, WeaponUncheckedUpdateManyWithoutAmmoInput>
  }

  export type WeaponCreateWithoutRangeInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    character?: CharacterCreateNestedManyWithoutWeaponInput
    weaponSkill?: WeaponSkillCreateNestedManyWithoutWeaponInput
    user: UserCreateNestedOneWithoutWeaponInput
    damage: DamageCreateNestedOneWithoutWeaponInput
    weight: WeightCreateNestedOneWithoutWeaponInput
    ammo?: AmmoCreateNestedOneWithoutWeaponInput
  }

  export type WeaponUncheckedCreateWithoutRangeInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    userId: string
    damageId: string
    weightId: string
    ammoId?: string | null
    character?: CharacterUncheckedCreateNestedManyWithoutWeaponInput
    weaponSkill?: WeaponSkillUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type WeaponCreateOrConnectWithoutRangeInput = {
    where: WeaponWhereUniqueInput
    create: XOR<WeaponCreateWithoutRangeInput, WeaponUncheckedCreateWithoutRangeInput>
  }

  export type WeaponCreateManyRangeInputEnvelope = {
    data: WeaponCreateManyRangeInput | WeaponCreateManyRangeInput[]
    skipDuplicates?: boolean
  }

  export type WeaponUpsertWithWhereUniqueWithoutRangeInput = {
    where: WeaponWhereUniqueInput
    update: XOR<WeaponUpdateWithoutRangeInput, WeaponUncheckedUpdateWithoutRangeInput>
    create: XOR<WeaponCreateWithoutRangeInput, WeaponUncheckedCreateWithoutRangeInput>
  }

  export type WeaponUpdateWithWhereUniqueWithoutRangeInput = {
    where: WeaponWhereUniqueInput
    data: XOR<WeaponUpdateWithoutRangeInput, WeaponUncheckedUpdateWithoutRangeInput>
  }

  export type WeaponUpdateManyWithWhereWithoutRangeInput = {
    where: WeaponScalarWhereInput
    data: XOR<WeaponUpdateManyMutationInput, WeaponUncheckedUpdateManyWithoutRangeInput>
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioCreateManyUserInput = {
    id?: string
    name: string
    universe: string
    description?: string | null
  }

  export type WeaponCreateManyUserInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    damageId: string
    weightId: string
    rangeId: string
    ammoId?: string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    universe?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    universe?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUncheckedUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    universe?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeaponUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutWeaponNestedInput
    weaponSkill?: WeaponSkillUpdateManyWithoutWeaponNestedInput
    damage?: DamageUpdateOneRequiredWithoutWeaponNestedInput
    weight?: WeightUpdateOneRequiredWithoutWeaponNestedInput
    range?: RangeUpdateOneRequiredWithoutWeaponNestedInput
    ammo?: AmmoUpdateOneWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    damageId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUncheckedUpdateManyWithoutWeaponNestedInput
    weaponSkill?: WeaponSkillUncheckedUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    damageId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUpdateManyWithoutCharacterNestedInput
    fortune?: FortuneUpdateOneWithoutCharacterNestedInput
    alignment?: AlignmentUpdateOneWithoutCharacterNestedInput
    temperment?: TempermentUpdateOneWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUncheckedUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUncheckedUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeaponUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    weaponSkill?: WeaponSkillUpdateManyWithoutWeaponNestedInput
    user?: UserUpdateOneRequiredWithoutWeaponNestedInput
    damage?: DamageUpdateOneRequiredWithoutWeaponNestedInput
    weight?: WeightUpdateOneRequiredWithoutWeaponNestedInput
    range?: RangeUpdateOneRequiredWithoutWeaponNestedInput
    ammo?: AmmoUpdateOneWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    damageId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
    weaponSkill?: WeaponSkillUncheckedUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    damageId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterSkillUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CharacterSkillUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CharacterSkillUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ScenarioUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    universe?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutScenarioNestedInput
  }

  export type ScenarioUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    universe?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ScenarioUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    universe?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type StrengthUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StrengthUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StrengthUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeaknessUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeaknessUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeaknessUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CharacterUpdateWithoutSkillSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUpdateManyWithoutCharacterNestedInput
    fortune?: FortuneUpdateOneWithoutCharacterNestedInput
    alignment?: AlignmentUpdateOneWithoutCharacterNestedInput
    temperment?: TempermentUpdateOneWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutSkillSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUncheckedUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUncheckedUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUncheckedUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutSkillSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterCreateManyFortuneInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    alignmentId?: string | null
    tempermentId?: string | null
  }

  export type CharacterUpdateWithoutFortuneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUpdateManyWithoutCharacterNestedInput
    alignment?: AlignmentUpdateOneWithoutCharacterNestedInput
    temperment?: TempermentUpdateOneWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutFortuneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUncheckedUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUncheckedUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUncheckedUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutFortuneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterCreateManyAlignmentInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    fortuneId?: string | null
    tempermentId?: string | null
  }

  export type CharacterUpdateWithoutAlignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUpdateManyWithoutCharacterNestedInput
    fortune?: FortuneUpdateOneWithoutCharacterNestedInput
    temperment?: TempermentUpdateOneWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutAlignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUncheckedUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUncheckedUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUncheckedUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutAlignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterCreateManyTempermentInput = {
    id?: string
    name: string
    pj: boolean
    age?: number | null
    image?: string | null
    origin?: string | null
    role?: string | null
    injury?: string | null
    extra?: string | null
    fortuneId?: string | null
    alignmentId?: string | null
  }

  export type CharacterUpdateWithoutTempermentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUpdateManyWithoutCharacterNestedInput
    fortune?: FortuneUpdateOneWithoutCharacterNestedInput
    alignment?: AlignmentUpdateOneWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutTempermentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUncheckedUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUncheckedUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUncheckedUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutTempermentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterUpdateWithoutStrengthInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUpdateManyWithoutCharacterNestedInput
    fortune?: FortuneUpdateOneWithoutCharacterNestedInput
    alignment?: AlignmentUpdateOneWithoutCharacterNestedInput
    temperment?: TempermentUpdateOneWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutStrengthInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUncheckedUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUncheckedUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutStrengthInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterUpdateWithoutWeaknessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUpdateManyWithoutCharacterNestedInput
    fortune?: FortuneUpdateOneWithoutCharacterNestedInput
    alignment?: AlignmentUpdateOneWithoutCharacterNestedInput
    temperment?: TempermentUpdateOneWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutWeaknessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
    weapon?: WeaponUncheckedUpdateManyWithoutCharacterNestedInput
    skillSet?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUncheckedUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutWeaknessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    skillSet?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUpdateManyWithoutCharacterNestedInput
    fortune?: FortuneUpdateOneWithoutCharacterNestedInput
    alignment?: AlignmentUpdateOneWithoutCharacterNestedInput
    temperment?: TempermentUpdateOneWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
    skillSet?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    scenario?: ScenarioUncheckedUpdateManyWithoutCharacterNestedInput
    strength?: StrengthUncheckedUpdateManyWithoutCharacterNestedInput
    weakness?: WeaknessUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pj?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    injury?: NullableStringFieldUpdateOperationsInput | string | null
    extra?: NullableStringFieldUpdateOperationsInput | string | null
    fortuneId?: NullableStringFieldUpdateOperationsInput | string | null
    alignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    tempermentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeaponSkillUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeaponSkillUncheckedUpdateWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeaponSkillUncheckedUpdateManyWithoutWeaponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WeaponUpdateWithoutWeaponSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutWeaponNestedInput
    user?: UserUpdateOneRequiredWithoutWeaponNestedInput
    damage?: DamageUpdateOneRequiredWithoutWeaponNestedInput
    weight?: WeightUpdateOneRequiredWithoutWeaponNestedInput
    range?: RangeUpdateOneRequiredWithoutWeaponNestedInput
    ammo?: AmmoUpdateOneWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateWithoutWeaponSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    damageId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUncheckedUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateManyWithoutWeaponSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    damageId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeaponCreateManyDamageInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    userId: string
    weightId: string
    rangeId: string
    ammoId?: string | null
  }

  export type WeaponUpdateWithoutDamageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutWeaponNestedInput
    weaponSkill?: WeaponSkillUpdateManyWithoutWeaponNestedInput
    user?: UserUpdateOneRequiredWithoutWeaponNestedInput
    weight?: WeightUpdateOneRequiredWithoutWeaponNestedInput
    range?: RangeUpdateOneRequiredWithoutWeaponNestedInput
    ammo?: AmmoUpdateOneWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateWithoutDamageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUncheckedUpdateManyWithoutWeaponNestedInput
    weaponSkill?: WeaponSkillUncheckedUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateManyWithoutDamageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeaponCreateManyWeightInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    userId: string
    damageId: string
    rangeId: string
    ammoId?: string | null
  }

  export type WeaponUpdateWithoutWeightInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutWeaponNestedInput
    weaponSkill?: WeaponSkillUpdateManyWithoutWeaponNestedInput
    user?: UserUpdateOneRequiredWithoutWeaponNestedInput
    damage?: DamageUpdateOneRequiredWithoutWeaponNestedInput
    range?: RangeUpdateOneRequiredWithoutWeaponNestedInput
    ammo?: AmmoUpdateOneWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateWithoutWeightInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    damageId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUncheckedUpdateManyWithoutWeaponNestedInput
    weaponSkill?: WeaponSkillUncheckedUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateManyWithoutWeightInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    damageId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WeaponCreateManyAmmoInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    userId: string
    damageId: string
    weightId: string
    rangeId: string
  }

  export type WeaponUpdateWithoutAmmoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutWeaponNestedInput
    weaponSkill?: WeaponSkillUpdateManyWithoutWeaponNestedInput
    user?: UserUpdateOneRequiredWithoutWeaponNestedInput
    damage?: DamageUpdateOneRequiredWithoutWeaponNestedInput
    weight?: WeightUpdateOneRequiredWithoutWeaponNestedInput
    range?: RangeUpdateOneRequiredWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateWithoutAmmoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    damageId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
    character?: CharacterUncheckedUpdateManyWithoutWeaponNestedInput
    weaponSkill?: WeaponSkillUncheckedUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateManyWithoutAmmoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    damageId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    rangeId?: StringFieldUpdateOperationsInput | string
  }

  export type WeaponCreateManyRangeInput = {
    id?: string
    name: string
    melee: boolean
    description?: string | null
    userId: string
    damageId: string
    weightId: string
    ammoId?: string | null
  }

  export type WeaponUpdateWithoutRangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateManyWithoutWeaponNestedInput
    weaponSkill?: WeaponSkillUpdateManyWithoutWeaponNestedInput
    user?: UserUpdateOneRequiredWithoutWeaponNestedInput
    damage?: DamageUpdateOneRequiredWithoutWeaponNestedInput
    weight?: WeightUpdateOneRequiredWithoutWeaponNestedInput
    ammo?: AmmoUpdateOneWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateWithoutRangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    damageId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUncheckedUpdateManyWithoutWeaponNestedInput
    weaponSkill?: WeaponSkillUncheckedUpdateManyWithoutWeaponNestedInput
  }

  export type WeaponUncheckedUpdateManyWithoutRangeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    melee?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    damageId?: StringFieldUpdateOperationsInput | string
    weightId?: StringFieldUpdateOperationsInput | string
    ammoId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}